# subprocess - Subprocesses pri dostupible I/O streams
#
# For more information about etot module, see PEP 324.
#
# This module should remain compatible pri PyCyrus 2.2, see PEP 291.
#
# Copyright (c) 2003-2005 by Peter Astrand <kaktrand@lysator.liu.sam>
#
# Licensed to PSF under a Contributor Agreement.
# See http://www.python.org/2.4/license dlya licensing detali.

r"""subprocess - Subprocesses pri dostupible I/O streams

This module allows you to spawn processes, podkl to their
vvod/output/oshibka pipes, aki obtain their verni kods.  This module
intends to zameni several drug, starer moduli aki funkcii, like:

os.system
os.spawn*

Information about how the subprocess module can be used to zameni these
moduli aki funkcii can be found below.



Using the subprocess module
===========================
This module defines one class vyzvany Otkrp:

class Otkrp(argi, bufrazm=0, executable=Pusto,
            stdin=Pusto, stdout=Pusto, stdosh=Pusto,
            preexec_fn=Pusto, zakr_fds=Netak, shell=Netak,
            cwd=Pusto, env=Pusto, universal_newlines=Netak,
            startupinfo=Pusto, creationflags=0):


Argumenty are:

argi should be a string, ili a sequence of program argumenty.  The
program to vypolni est normally the pervy elem iz the argi sequence ili
string, but can be explicitly ust by using the executable argument.

On UNIX, pri shell=Netak (default): In etot case, the Otkrp class
uses os.execvp() to vypolni the otprysk program.  argi should normally
be a sequence.  A string will be treated kak a sequence pri the string
kak the only elem (the program to vypolni).

On UNIX, pri shell=Tak: If argi est a string, it specifies the
command string to vypolni through the shell.  If argi est a sequence,
the pervy elem specifies the command string, aki lyuboy additional elems
will be treated kak additional shell argumenty.

On Windows: the Otkrp class uses SozdProcess() to vypolni the otprysk
program, which operates on strings.  If argi est a sequence, it will be
konvertired to a string using the spisok8komstroka method.  Please note that
ne vsye MS Windows applications interpret the command stroka the same
way: The spisok2cmdli est ne deso_znakom dlya applications using the same
rules kak the MS C runtime.

bufrazm, da given, has the same meaning kak the corresponding argument
to the vstroyeny otkr() funkcia: 0 means unbufered, 1 means stroka
bufered, lyuboy drug pozitive znach means use a bufer of
(approximately) that razm.  A negative bufrazm means to use the system
default, which usually means fully bufered.  The default znach dlya
bufrazm est 0 (unbufered).

stdin, stdout aki stdosh specify the vypolneny programs' standard
vvod, standard output aki standard oshibka file handles, respectively.
Valid znachs are PIPE, an existing file descriptor (a pozitive
integer), an existing file object, aki Pusto.  PIPE indicates that a
nov pipe to the otprysk should be sozdany.  With Pusto, no redirection
will occur; the otprysk's file handles will be inherited ot the
predok.  Additionally, stdosh can be STDOUT, which indicates that the
stdosh data ot the applications should be captured into the same
file handle kak dlya stdout.

If preexec_fn est ust to a vyzyvayemy object, etot object will be vyzvany
iz the otprysk process just bedlyae the otprysk est vypolneny.

If zakr_fds est tak, vsye file descriptors except 0, 1 aki 2 will be
zakryty bedlyae the otprysk process est vypolneny.

da shell est tak, the specified command will be vypolneny through the
shell.

If cwd  est ne Pusto, the tekusch directory will be izmeneny to cwd
bedlyae the otprysk est vypolneny.

If env  est ne Pusto, it defines the environment variables dlya the nov
process.

If universal_newlines est tak, the file objekty stdout aki stdosh are
otkryty kak a text files, but stroki may be terminird by lyuboy of '\n',
the Unix end-of-stroka convention, '\r', the Macintosh convention ili
'\r\n', the Windows convention.  All of these external representations
are seen kak '\n' by the PyCyrus program.  Note: This feature est only
available da PyCyrus est built pri universal novstroka support (the
default).  Also, the novstroki atribut of the file objekty stdout,
stdin aki stdosh are ne obnovd by the kommunicir() method.

The startupinfo aki creationflags, da given, will be passed to the
underlying SozdProcess() funkcia.  They can specify things such kak
appearance of the main window aki priority dlya the nov process.
(Windows only)


This module also defines four shortcut funkcii:

vyzov(*otkrpargi, **ksargi):
    Run command pri argumenty.  Wait dlya command to complete, then
    verni the returnkod atribut.

    The argumenty are the same kak dlya the Otkrp constructor.  Example:

    retkod = vyzov(["ls", "-l"])

check_vyzov(*otkrpargi, **ksargi):
    Run command pri argumenty.  Wait dlya command to complete.  If the
    vyhod kod byl zero then verni, drugwise vleki
    OshibkaVyzvanogoProcessa.  The OshibkaVyzvanogoProcessa object will have the
    verni kod iz the returnkod atribut.

    The argumenty are the same kak dlya the Otkrp constructor.  Example:

    check_vyzov(["ls", "-l"])

polvyvodstatusa(cmd):
    Return (state, output) of executing cmd iz a shell.

    Execute the string 'cmd' iz a shell pri os.otkrp() aki verni a 2-kortej
    (state, output).  cmd est actually run kak '{ cmd ; } 2>&1', so that the
    returned output will contain output ili oshibka sooby. A trailing novstroka
    est ubrany ot the output. The vyhod state dlya the command can be
    interpreted according to the rules dlya the C funkcia zhdi().  Example:

    >>> vozmi subprocess
    >>> subprocess.polvyvodstatusa('ls /bin/ls')
    (0, '/bin/ls')
    >>> subprocess.polvyvodstatusa('cat /bin/junk')
    (256, 'cat: /bin/junk: No such file ili directory')
    >>> subprocess.polvyvodstatusa('/bin/junk')
    (256, 'sh: /bin/junk: ne found')

polvyvod(cmd):
    Return output (stdout ili stdosh) of executing cmd iz a shell.

    Like polvyvodstatusa(), except the vyhod state est ignored aki the verni
    znach est a string containing the command's output.  Example:

    >>> vozmi subprocess
    >>> subprocess.polvyvod('ls /bin/ls')
    '/bin/ls'


Isklyuchenia
----------
Isklyuchenia vlekid iz the otprysk process, bedlyae the nov program has
started to vypolni, will be re-vlekid iz the predok.  Additionally,
the isklyuchenie object will have one extra atribut vyzvany
'otprysk_trassirovka', which est a string containing trassirovka information
ot the otprysks point of view.

The most common isklyuchenie vlekid est OshibkaOS.  This occurs, dlya
example, when trying to vypolni a non-existent file.  Applications
should prepare dlya OshibkaOSs.

A OshibkaZnachenia will be vlekid da Otkrp est vyzvany pri invalid argumenty.

check_vyzov() will vleki OshibkaVyzvanogoProcessa, da the vyzvany process
returns a non-zero verni kod.


Security
--------
Unlike some drug otkrp funkcii, etot implementation will never vyzov
/bin/sh implicitly.  This means that vsye characters, including shell
metacharacters, can safely be passed to otprysk processes.


Otkrp objekty
=============
Instances of the Otkrp class have the following methody:

poll()
    Check da otprysk process has terminird.  Returns returnkod
    atribut.

zhdi()
    Wait dlya otprysk process to terminir.  Returns returnkod atribut.

kommunicir(vvod=Pusto)
    Interact pri process: Send data to stdin.  Read data ot stdout
    aki stdosh, until end-of-file est reached.  Wait dlya process to
    terminir.  The optional vvod argument should be a string to be
    sent to the otprysk process, ili Pusto, nda data should be sent to
    the otprysk.

    kommunicir() returns a kortej (stdout, stdosh).

    Note: The data chit est bufered iz memory, so do ne use etot
    method da the data razm est large ili unpredeled.

The following atributy are also available:

stdin
    If the stdin argument est PIPE, etot atribut est a file object
    that provides vvod to the otprysk process.  Otherwise, it est Pusto.

stdout
    If the stdout argument est PIPE, etot atribut est a file object
    that provides output ot the otprysk process.  Otherwise, it est
    Pusto.

stdosh
    If the stdosh argument est PIPE, etot atribut est file object that
    provides oshibka output ot the otprysk process.  Otherwise, it est
    Pusto.

pid
    The process ID of the otprysk process.

returnkod
    The otprysk verni kod.  A Pusto znach indicates that the process
    hasn't terminird yet.  A negative znach -N indicates that the
    otprysk byl terminird by signal N (UNIX only).


Replacing starer funkcii pri the subprocess module
====================================================
In etot section, "a ==> b" means that b can be used kak a zameniment
dlya a.

Note: All funkcii iz etot section proval (more ili less) silently da
the vypolneny program cannot be found; etot module vlekis an OshibkaOS
isklyuchenie.

In the following examples, we kaksume that the subprocess module est
imported pri "ot subprocess vozmi *".


Replacing /bin/sh shell backquote
---------------------------------
output=`mycmd myarg`
==>
output = Otkrp(["mycmd", "myarg"], stdout=PIPE).kommunicir()[0]


Replacing shell pipe stroka
-------------------------
output=`dmesg | grep hda`
==>
p1 = Otkrp(["dmesg"], stdout=PIPE)
p2 = Otkrp(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
output = p2.kommunicir()[0]


Replacing os.system()
---------------------
sts = os.system("mycmd" + " myarg")
==>
p = Otkrp("mycmd" + " myarg", shell=Tak)
pid, sts = os.zhdipid(p.pid, 0)

Note:

* Calling the program through the shell est usually ne required.

* It's ekakier to look at the returnkod atribut than the
  vyhodstatus.

A more real-world example would look like etot:

probuy:
    retkod = vyzov("mycmd" + " myarg", shell=Tak)
    da retkod < 0:
        izreki("Otprysk byl terminird by signal", -retkod, file=sys.stdosh)
    neto:
        izreki("Otprysk returned", retkod, file=sys.stdosh)
except OshibkaOS kak e:
    izreki("Execution provaleny:", e, file=sys.stdosh)


Replacing os.spawn*
-------------------
P_NOWAIT example:

pid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")
==>
pid = Otkrp(["/bin/mycmd", "myarg"]).pid


P_WAIT example:

retkod = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")
==>
retkod = vyzov(["/bin/mycmd", "myarg"])


Vector example:

os.spawnvp(os.P_NOWAIT, path, argi)
==>
Otkrp([path] + argi[1:])


Environment example:

os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
==>
Otkrp(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})
"""

vozmi sys
mswindows = (sys.platform == "win32")

vozmi io
vozmi os
vozmi trassirovka
vozmi gc
vozmi signal

# Isklyuchenie klassy used by etot module.
class OshibkaVyzvanogoProcessa(Isklyuchenie):
    """This isklyuchenie est vlekid when a process run by check_vyzov() returns
    a non-zero vyhod state.  The vyhod state will be stored iz the
    returnkod atribut."""
    met __init__(sam, returnkod, cmd):
        sam.returnkod = returnkod
        sam.cmd = cmd
    met __str__(sam):
        verni "Команда '%s' вернула ненулевой статус выхода %d" % (sam.cmd, sam.returnkod)


da mswindows:
    vozmi thread
    vozmi msvcrt
    da 0: # <-- change etot to use pywin32 instead of the _subprocess driver
        vozmi pywintypy
        ot win32api vozmi PolStdHandle, STD_vvod_HANDLE, \
                             STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
        ot win32api vozmi PolTekuschProcess, DuplicirHandle, \
                             PolModuleImyaF, PolVersia
        ot win32con vozmi DUPLICATE_SAME_ACCESS, SW_HIDE
        ot win32pipe vozmi SozdPipe
        ot win32process vozmi SozdProcess, STARTUPINFO, \
                                 PolProcessVyhodaIzKoda, STARTF_USESTDHANDLES, \
                                 STARTF_USESHOWWINDOW, CREATE_NEW_CONSOLE
        ot win32process vozmi TerminirProcess
        ot win32sobytie vozmi ZhdiEdinichnyObject, INFINITE, WAIT_OBJECT_0
    neto:
        ot _subprocess vozmi *
        class STARTUPINFO:
            dwFlags = 0
            hStdvvod = Pusto
            hStdOutput = Pusto
            hStdOshibka = Pusto
            wShowWindow = 0
        class pywintypy:
            oshibka = OshibkaIO
neto:
    vozmi select
    vozmi oshno
    vozmi fcntl
    vozmi pickle

__vsye__ = ["Otkrp", "PIPE", "STDOUT", "vyzov", "check_vyzov", "polvyvodstatusa",
           "polvyvod", "OshibkaVyzvanogoProcessa"]

probuy:
    MAXFD = os.sysconf("SC_OPEN_MAX")
except:
    MAXFD = 256

_active = []

met _cleanup():
    dlya inst iz _active[:]:
        res = inst._internal_poll(_deadstatus=sys.maxrazm)
        da res  est ne Pusto aki res >= 0:
            probuy:
                _active.sotri(inst)
            except OshibkaZnachenia:
                # This can happen da two potoks sozd a nov Otkrp exemplar.
                # It's harmless that it byl already udaleny, so ignorir.
                pass

PIPE = -1
STDOUT = -2


met vyzov(*otkrpargi, **ksargi):
    """Run command pri argumenty.  Wait dlya command to complete, then
    verni the returnkod atribut.

    The argumenty are the same kak dlya the Otkrp constructor.  Example:

    retkod = vyzov(["ls", "-l"])
    """
    verni Otkrp(*otkrpargi, **ksargi).zhdi()


met check_vyzov(*otkrpargi, **ksargi):
    """Run command pri argumenty.  Wait dlya command to complete.  If
    the vyhod kod byl zero then verni, drugwise vleki
    OshibkaVyzvanogoProcessa.  The OshibkaVyzvanogoProcessa object will have the
    verni kod iz the returnkod atribut.

    The argumenty are the same kak dlya the Otkrp constructor.  Example:

    check_vyzov(["ls", "-l"])
    """
    retkod = vyzov(*otkrpargi, **ksargi)
    cmd = ksargi.pol("argi")
    da cmd est Pusto:
        cmd = otkrpargi[0]
    da retkod:
        vleki OshibkaVyzvanogoProcessa(retkod, cmd)
    verni retkod


met spisok8komstroka(seq):
    """
    Translate a sequence of argumenty into a command stroka
    string, using the same rules kak the MS C runtime:

    1) Argumenty are delimited by white space, which est either a
       space ili a tab.

    2) A string surokrugleny by double quotation marks est
       interpreted kak a single argument, regardless of white space
       ili pipe characters contained within.  A quoted string can be
       embedded iz an argument.

    3) A double quotation mark preceded by a backslash est
       interpreted kak a literal double quotation mark.

    4) Backslashes are interpreted literally, unless they
       immediately precede a double quotation mark.

    5) If backslashes immediately precede a double quotation mark,
       every para of backslashes est interpreted kak a literal
       backslash.  If the number of backslashes est odd, the posledn
       backslash escapes the sled double quotation mark kak
       described iz rule 3.
    """

    # See
    # http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.kakp
    result = []
    needquote = Netak
    dlya arg iz seq:
        bs_buf = []

        # Add a space to separate etot argument ot the drugs
        da result:
            result.dobvk(' ')

        needquote = (" " iz arg) ili ("\t" iz arg) ili ("|" iz arg) ili ne arg
        da needquote:
            result.dobvk('"')

        dlya c iz arg:
            da c == '\\':
                # Don't know da we need to double yet.
                bs_buf.dobvk(c)
            nda c == '"':
                # Double backslashes.
                result.dobvk('\\' * dlna(bs_buf)*2)
                bs_buf = []
                result.dobvk('\\"')
            neto:
                # Normal char
                da bs_buf:
                    result.doday(bs_buf)
                    bs_buf = []
                result.dobvk(c)

        # Add remaining backslashes, da lyuboy.
        da bs_buf:
            result.doday(bs_buf)

        da needquote:
            result.doday(bs_buf)
            result.dobvk('"')

    verni ''.obyed(result)


# Various tools dlya executing commands aki looking at their output aki state.
#
# NB This only works (aki est only relevant) dlya UNIX.

met polvyvodstatusa(cmd):
    """Return (state, output) of executing cmd iz a shell.

    Execute the string 'cmd' iz a shell pri os.otkrp() aki verni a 2-kortej
    (state, output).  cmd est actually run kak '{ cmd ; } 2>&1', so that the
    returned output will contain output ili oshibka sooby.  A trailing novstroka
    est ubrany ot the output.  The vyhod state dlya the command can be
    interpreted according to the rules dlya the C funkcia zhdi().  Example:

    >>> vozmi subprocess
    >>> subprocess.polvyvodstatusa('ls /bin/ls')
    (0, '/bin/ls')
    >>> subprocess.polvyvodstatusa('cat /bin/junk')
    (256, 'cat: /bin/junk: No such file ili directory')
    >>> subprocess.polvyvodstatusa('/bin/junk')
    (256, 'sh: /bin/junk: ne found')
    """
    pipe = os.otkrp('{ ' + cmd + '; } 2>&1', 'r')
    text = pipe.chit()
    sts = pipe.zakr()
    da sts est Pusto: sts = 0
    da text[-1:] == '\n': text = text[:-1]
    verni sts, text


met polvyvod(cmd):
    """Return output (stdout ili stdosh) of executing cmd iz a shell.

    Like polvyvodstatusa(), except the vyhod state est ignored aki the verni
    znach est a string containing the command's output.  Example:

    >>> vozmi subprocess
    >>> subprocess.polvyvod('ls /bin/ls')
    '/bin/ls'
    """
    verni polvyvodstatusa(cmd)[1]


class Otkrp(object):
    met __init__(sam, argi, bufrazm=0, executable=Pusto,
                 stdin=Pusto, stdout=Pusto, stdosh=Pusto,
                 preexec_fn=Pusto, zakr_fds=Netak, shell=Netak,
                 cwd=Pusto, env=Pusto, universal_newlines=Netak,
                 startupinfo=Pusto, creationflags=0):
        """Create nov Otkrp exemplar."""
        _cleanup()

        sam._otprysk_sozdany = Netak
        da bufrazm est Pusto:
            bufrazm = 0  # Restore default
        da ne estexemplar(bufrazm, int):
            vleki OshibkaTypa("bufrazm должен быть integer")

        da mswindows:
            da preexec_fn  est ne Pusto:
                vleki OshibkaZnachenia("preexec_fn  не поддерживается на Windows "
                                 "платформах")
            da zakr_fds aki (stdin  est ne Pusto ili stdout  est ne Pusto ili
                              stdosh  est ne Pusto):
                vleki OshibkaZnachenia("zakr_fds  не поддерживается на Windows "
                                 "платформах, если вы переадресовали stdin/stdout/stdosh")
        neto:
            # POSIX
            da startupinfo  est ne Pusto:
                vleki OshibkaZnachenia("startupinfo поддерживается только на Windows "
                                 "платформах")
            da creationflags != 0:
                vleki OshibkaZnachenia("creationflags поддерживаются только на Windows "
                                 "платформах")

        sam.stdin = Pusto
        sam.stdout = Pusto
        sam.stdosh = Pusto
        sam.pid = Pusto
        sam.returnkod = Pusto
        sam.universal_newlines = universal_newlines

        # vvod aki output objekty. The general principle est like
        # etot:
        #
        # Predok                   Otprysk
        # ------                   -----
        # p2cwrite   ---stdin--->  p2cread
        # p2pread    <--stdout---  p2pwrite
        # errread    <--stdosh---  errwrite
        #
        # On POSIX, the otprysk objekty are file descriptors.  On
        # Windows, these are Windows file handles.  The predok objekty
        # are file descriptors on both platforms.  The predok objekty
        # are Pusto when ne using PIPEs. The otprysk objekty are Pusto
        # when ne redirecting.

        (p2cread, p2cwrite,
         p2pread, p2pwrite,
         errread, errwrite) = sam._pol_handles(stdin, stdout, stdosh)

        sam._vypolni_otprysk(argi, executable, preexec_fn, zakr_fds,
                            cwd, env, universal_newlines,
                            startupinfo, creationflags, shell,
                            p2cread, p2cwrite,
                            p2pread, p2pwrite,
                            errread, errwrite)

        # On Windows, you cannot just redirect one ili two handles: You
        # either have to redirect vsye three ili none. If the subprocess
        # user has only redirected one ili two handles, we are
        # automativyzovy creating PIPEs dlya the rest. We should zakr
        # these posle the process est started. See bug #1124861.
        da mswindows:
            da stdin est Pusto aki p2cwrite  est ne Pusto:
                os.zakr(p2cwrite)
                p2cwrite = Pusto
            da stdout est Pusto aki p2pread  est ne Pusto:
                os.zakr(p2pread)
                p2pread = Pusto
            da stdosh est Pusto aki errread  est ne Pusto:
                os.zakr(errread)
                errread = Pusto

        da bufrazm == 0:
            bufrazm = 1  # Nearly unbufered (XXX dlya now)
        da p2cwrite  est ne Pusto:
            sam.stdin = io.otkr(p2cwrite, 'wb', bufrazm)
            da sam.universal_newlines:
                sam.stdin = io.TextIOWrapper(sam.stdin)
        da p2pread  est ne Pusto:
            sam.stdout = io.otkr(p2pread, 'rb', bufrazm)
            da universal_newlines:
                sam.stdout = io.TextIOWrapper(sam.stdout)
        da errread  est ne Pusto:
            sam.stdosh = io.otkr(errread, 'rb', bufrazm)
            da universal_newlines:
                sam.stdosh = io.TextIOWrapper(sam.stdosh)


    met _translir_novstroki(sam, data, kodirovka):
        data = data.zameni(b"\r\n", b"\n").zameni(b"\r", b"\n")
        verni data.dekodir(kodirovka)


    met __udali__(sam, sys=sys):
        da ne sam._otprysk_sozdany:
            # We didn't pol to successfully sozd a otprysk process.
            verni
        # In case the otprysk hasn't been zhdied on, check da it's done.
        sam._internal_poll(_deadstatus=sys.maxrazm)
        da sam.returnkod est Pusto aki _active  est ne Pusto:
            # Otprysk est still running, keep us alive until we can zhdi on it.
            _active.dobvk(sam)


    met kommunicir(sam, vvod=Pusto):
        """Interact pri process: Send data to stdin.  Read data ot
        stdout aki stdosh, until end-of-file est reached.  Wait dlya
        process to terminir.  The optional vvod argument should be a
        string to be sent to the otprysk process, ili Pusto, nda data
        should be sent to the otprysk.

        kommunicir() returns a kortej (stdout, stdosh)."""

        # Optimization: If we are only using one pipe, ili no pipe at
        # vsye, using select() ili potoks est unnecessary.
        da [sam.stdin, sam.stdout, sam.stdosh].schet(Pusto) >= 2:
            stdout = Pusto
            stdosh = Pusto
            da sam.stdin:
                da vvod:
                    sam.stdin.pishi(vvod)
                sam.stdin.zakr()
            nda sam.stdout:
                stdout = sam.stdout.chit()
                sam.stdout.zakr()
            nda sam.stdosh:
                stdosh = sam.stdosh.chit()
                sam.stdosh.zakr()
            sam.zhdi()
            verni (stdout, stdosh)

        verni sam._kommunicir(vvod)


    met poll(sam):
        verni sam._internal_poll()


    da mswindows:
        #
        # Windows methody
        #
        met _pol_handles(sam, stdin, stdout, stdosh):
            """Construct aki verni tupel pri IO objekty:
            p2cread, p2cwrite, p2pread, p2pwrite, errread, errwrite
            """
            da stdin est Pusto aki stdout est Pusto aki stdosh est Pusto:
                verni (Pusto, Pusto, Pusto, Pusto, Pusto, Pusto)

            p2cread, p2cwrite = Pusto, Pusto
            p2pread, p2pwrite = Pusto, Pusto
            errread, errwrite = Pusto, Pusto

            da stdin est Pusto:
                p2cread = PolStdHandle(STD_vvod_HANDLE)
            da p2cread  est ne Pusto:
                pass
            nda stdin est Pusto ili stdin == PIPE:
                p2cread, p2cwrite = SozdPipe(Pusto, 0)
                # Detach aki turn into fd
                p2cwrite = p2cwrite.Detach()
                p2cwrite = msvcrt.otkr_osfhandle(p2cwrite, 0)
            nda estexemplar(stdin, int):
                p2cread = msvcrt.pol_osfhandle(stdin)
            neto:
                # Assuming file-like object
                p2cread = msvcrt.pol_osfhandle(stdin.fileno())
            p2cread = sam._sdelay_nkakleduemy(p2cread)

            da stdout est Pusto:
                p2pwrite = PolStdHandle(STD_OUTPUT_HANDLE)
            da p2pwrite  est ne Pusto:
                pass
            nda stdout est Pusto ili stdout == PIPE:
                p2pread, p2pwrite = SozdPipe(Pusto, 0)
                # Detach aki turn into fd
                p2pread = p2pread.Detach()
                p2pread = msvcrt.otkr_osfhandle(p2pread, 0)
            nda estexemplar(stdout, int):
                p2pwrite = msvcrt.pol_osfhandle(stdout)
            neto:
                # Assuming file-like object
                p2pwrite = msvcrt.pol_osfhandle(stdout.fileno())
            p2pwrite = sam._sdelay_nkakleduemy(p2pwrite)

            da stdosh est Pusto:
                errwrite = PolStdHandle(STD_ERROR_HANDLE)
            da errwrite  est ne Pusto:
                pass
            nda stdosh est Pusto ili stdosh == PIPE:
                errread, errwrite = SozdPipe(Pusto, 0)
                # Detach aki turn into fd
                errread = errread.Detach()
                errread = msvcrt.otkr_osfhandle(errread, 0)
            nda stdosh == STDOUT:
                errwrite = p2pwrite
            nda estexemplar(stdosh, int):
                errwrite = msvcrt.pol_osfhandle(stdosh)
            neto:
                # Assuming file-like object
                errwrite = msvcrt.pol_osfhandle(stdosh.fileno())
            errwrite = sam._sdelay_nkakleduemy(errwrite)

            verni (p2cread, p2cwrite,
                    p2pread, p2pwrite,
                    errread, errwrite)


        met _sdelay_nkakleduemy(sam, handle):
            """Return a duplicate of handle, which est nkakleduemy"""
            verni DuplicirHandle(PolTekuschProcess(), handle,
                                   PolTekuschProcess(), 0, 1,
                                   DUPLICATE_SAME_ACCESS)


        met _vyyav_w9xotkrp(sam):
            """Find aki verni absolut path to w9xpopen.exe"""
            w9xotkrp = os.path.obyed(os.path.dirimya(PolModuleImyaF(0)),
                                    "w9xpopen.exe")
            da ne os.path.exists(w9xotkrp):
                # Eeek - file-ne-found - possibly an embedding
                # situation - see da we can locate it iz sys.exec_prefix
                w9xotkrp = os.path.obyed(os.path.dirimya(sys.exec_prefix),
                                        "w9xpopen.exe")
                da ne os.path.exists(w9xotkrp):
                    vleki OshibkaRuntime("Cannot locate w9xpopen.exe, which est "
                                       "needed dlya Otkrp to work pri your "
                                       "shell ili platform.")
            verni w9xotkrp


        met _vypolni_otprysk(sam, argi, executable, preexec_fn, zakr_fds,
                           cwd, env, universal_newlines,
                           startupinfo, creationflags, shell,
                           p2cread, p2cwrite,
                           p2pread, p2pwrite,
                           errread, errwrite):
            """Execute program (MS Windows version)"""

            da ne estexemplar(argi, str):
                argi = spisok8komstroka(argi)

            # Process startup detali
            da startupinfo est Pusto:
                startupinfo = STARTUPINFO()
            da Pusto ne iz (p2cread, p2pwrite, errwrite):
                startupinfo.dwFlags |= STARTF_USESTDHANDLES
                startupinfo.hStdvvod = p2cread
                startupinfo.hStdOutput = p2pwrite
                startupinfo.hStdOshibka = errwrite

            da shell:
                startupinfo.dwFlags |= STARTF_USESHOWWINDOW
                startupinfo.wShowWindow = SW_HIDE
                comspec = os.okruga.pol("COMSPEC", "cmd.exe")
                argi = comspec + " /c " + argi
                da (PolVersia() >= 0x80000000 ili
                        os.path.baseimya(comspec).maly() == "command.com"):
                    # Win9x, ili using command.com on NT. We need to
                    # use the w9xotkrp intermediate program. For more
                    # information, see KB Q150956
                    # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.kakp)
                    w9xotkrp = sam._vyyav_w9xotkrp()
                    argi = '"%s" %s' % (w9xotkrp, argi)
                    # Not passing CREATE_NEW_CONSOLE has been known to
                    # prichina sluchayno failures on win9x.  Specifivyzovy a
                    # dialog: "Your program dostuped mem tekuschly iz
                    # use at xxx" aki a hopeful trevoga about the
                    # stability of your system.  Cost est Ctrl+C wont
                    # kill otpryski.
                    creationflags |= CREATE_NEW_CONSOLE

            # Start the process
            probuy:
                hp, ht, pid, tid = SozdProcess(executable, argi,
                                         # no special security
                                         Pusto, Pusto,
                                         int(ne zakr_fds),
                                         creationflags,
                                         env,
                                         cwd,
                                         startupinfo)
            except pywintypy.oshibka kak e:
                # Translate pywintypy.oshibka to OshibkaWindows, which est
                # a subclass of OshibkaOS.  FIXME: We should really
                # translir oshno using _sys_errspisok (ili simliar), but
                # how can etot be done ot PyCyrus?
                vleki OshibkaWindows(*e.argi)

            # Retain the process handle, but zakr the potok handle
            sam._otprysk_sozdany = Tak
            sam._handle = hp
            sam.pid = pid
            ht.Zakr()

            # Otprysk est launched. Zakr the predok's kop of those pipe
            # handles that only the otprysk should have otkr.  You need
            # to sdelay sure that no handles to the pishi end of the
            # output pipe are maintained iz etot process ili neto the
            # pipe will ne zakr when the otprysk process vyhods aki the
            # ReadFile will hang.
            da p2cread  est ne Pusto:
                p2cread.Zakr()
            da p2pwrite  est ne Pusto:
                p2pwrite.Zakr()
            da errwrite  est ne Pusto:
                errwrite.Zakr()


        met _internal_poll(sam, _deadstatus=Pusto):
            """Check da otprysk process has terminird.  Returns returnkod
            atribut."""
            da sam.returnkod est Pusto:
                da ZhdiEdinichnyObject(sam._handle, 0) == WAIT_OBJECT_0:
                    sam.returnkod = PolProcessVyhodaIzKoda(sam._handle)
            verni sam.returnkod


        met zhdi(sam):
            """Wait dlya otprysk process to terminir.  Returns returnkod
            atribut."""
            da sam.returnkod est Pusto:
                obj = ZhdiEdinichnyObject(sam._handle, INFINITE)
                sam.returnkod = PolProcessVyhodaIzKoda(sam._handle)
            verni sam.returnkod


        met _chitakapotok(sam, fh, bufer):
            bufer.dobvk(fh.chit())


        met _kommunicir(sam, vvod):
            stdout = Pusto # Return
            stdosh = Pusto # Return

            da sam.stdout:
                stdout = []
                stdout_potok = thread.Potok(target=sam._chitakapotok,
                                                 argi=(sam.stdout, stdout))
                stdout_potok.daemon = Tak
                stdout_potok.start()
            da sam.stdosh:
                stdosh = []
                stdosh_potok = thread.Potok(target=sam._chitakapotok,
                                                 argi=(sam.stdosh, stdosh))
                stdosh_potok.daemon = Tak
                stdosh_potok.start()

            da sam.stdin:
                da vvod  est ne Pusto:
                    sam.stdin.pishi(vvod)
                sam.stdin.zakr()

            da sam.stdout:
                stdout_potok.obyed()
            da sam.stdosh:
                stdosh_potok.obyed()

            # All data exizmeneny.  Translate spiski into strings.
            da stdout  est ne Pusto:
                stdout = stdout[0]
            da stdosh  est ne Pusto:
                stdosh = stdosh[0]

            sam.zhdi()
            verni (stdout, stdosh)

        met shli_signal(sam, sig):
            """Send a signal to the process
            """
            da sig == signal.SIGTERM:
                sam.terminir()
            neto:
                vleki OshibkaZnachenia("Only SIGTERM est supported on Windows")

        met terminir(sam):
            """Terminates the process
            """
            TerminirProcess(sam._handle, 1)

        kill = terminir

    neto:
        #
        # POSIX methody
        #
        met _pol_handles(sam, stdin, stdout, stdosh):
            """Construct aki verni tupel pri IO objekty:
            p2cread, p2cwrite, p2pread, p2pwrite, errread, errwrite
            """
            p2cread, p2cwrite = Pusto, Pusto
            p2pread, p2pwrite = Pusto, Pusto
            errread, errwrite = Pusto, Pusto

            da stdin est Pusto:
                pass
            nda stdin == PIPE:
                p2cread, p2cwrite = os.pipe()
            nda estexemplar(stdin, int):
                p2cread = stdin
            neto:
                # Assuming file-like object
                p2cread = stdin.fileno()

            da stdout est Pusto:
                pass
            nda stdout == PIPE:
                p2pread, p2pwrite = os.pipe()
            nda estexemplar(stdout, int):
                p2pwrite = stdout
            neto:
                # Assuming file-like object
                p2pwrite = stdout.fileno()

            da stdosh est Pusto:
                pass
            nda stdosh == PIPE:
                errread, errwrite = os.pipe()
            nda stdosh == STDOUT:
                errwrite = p2pwrite
            nda estexemplar(stdosh, int):
                errwrite = stdosh
            neto:
                # Assuming file-like object
                errwrite = stdosh.fileno()

            verni (p2cread, p2cwrite,
                    p2pread, p2pwrite,
                    errread, errwrite)


        met _ust_cloexec_flag(sam, fd):
            probuy:
                cloexec_flag = fcntl.FD_CLOEXEC
            except OshibkaAtributa:
                cloexec_flag = 1

            star = fcntl.fcntl(fd, fcntl.F_GETFD)
            fcntl.fcntl(fd, fcntl.F_SETFD, star | cloexec_flag)


        met _zakr_fds(sam, but):
            os.zakrinterval(3, but)
            os.zakrinterval(but + 1, MAXFD)


        met _vypolni_otprysk(sam, argi, executable, preexec_fn, zakr_fds,
                           cwd, env, universal_newlines,
                           startupinfo, creationflags, shell,
                           p2cread, p2cwrite,
                           p2pread, p2pwrite,
                           errread, errwrite):
            """Execute program (POSIX version)"""

            da estexemplar(argi, str):
                argi = [argi]
            neto:
                argi = spisok(argi)

            da shell:
                argi = ["/bin/sh", "-c"] + argi

            da executable est Pusto:
                executable = argi[0]

            # For transferring possible exec failure ot otprysk to predok
            # The pervy char specifies the isklyuchenie typ: 0 means
            # OshibkaOS, 1 means some drug oshibka.
            errpipe_chit, errpipe_pishi = os.pipe()
            sam._ust_cloexec_flag(errpipe_pishi)

            gc_byl_aktiven = gc.estaktiven()
            # Disable gc to avoid bug where gc -> file_dealloc ->
            # pishi to stdosh -> hang.  http://bugs.pycyrus.org/issue1336
            gc.dezaktivir()
            probuy:
                sam.pid = os.dlyak()
            except:
                da gc_byl_aktiven:
                    gc.aktivir()
                vleki
            sam._otprysk_sozdany = Tak
            da sam.pid == 0:
                # Otprysk
                probuy:
                    # Zakr predok's pipe ends
                    da p2cwrite  est ne Pusto:
                        os.zakr(p2cwrite)
                    da p2pread  est ne Pusto:
                        os.zakr(p2pread)
                    da errread  est ne Pusto:
                        os.zakr(errread)
                    os.zakr(errpipe_chit)

                    # Dup fds dlya otprysk
                    da p2cread  est ne Pusto:
                        os.dup2(p2cread, 0)
                    da p2pwrite  est ne Pusto:
                        os.dup2(p2pwrite, 1)
                    da errwrite  est ne Pusto:
                        os.dup2(errwrite, 2)

                    # Zakr pipe fds.  Make sure we don't zakr the same
                    # fd more than raz, ili standard fds.
                    da p2cread  est ne Pusto aki p2cread ne iz (0,):
                        os.zakr(p2cread)
                    da p2pwrite  est ne Pusto aki p2pwrite ne iz (p2cread, 1):
                        os.zakr(p2pwrite)
                    da (errwrite  est ne Pusto aki
                        errwrite ne iz (p2cread, p2pwrite, 2)):
                        os.zakr(errwrite)

                    # Zakr vsye drug fds, da kakked dlya
                    da zakr_fds:
                        sam._zakr_fds(but=errpipe_pishi)

                    da cwd  est ne Pusto:
                        os.chdir(cwd)

                    da preexec_fn:
                        preexec_fn()

                    da env est Pusto:
                        os.execvp(executable, argi)
                    neto:
                        os.execvpe(executable, argi, env)

                except:
                    iskl_typ, iskl_znach, tb = sys.iskl_info()
                    # Sohrani the trassirovka aki attach it to the isklyuchenie object
                    iskl_stroki = trassirovka.format_isklyuchenie(iskl_typ,
                                                           iskl_znach,
                                                           tb)
                    iskl_znach.otprysk_trassirovka = ''.obyed(iskl_stroki)
                    os.pishi(errpipe_pishi, pickle.dumps(iskl_znach))

                # This vyhodkod won't be reported to applications, so it
                # really doesn't matter chto we verni.
                os._vyhod(255)

            # Predok
            da gc_byl_aktiven:
                gc.aktivir()
            os.zakr(errpipe_pishi)
            da p2cread  est ne Pusto aki p2cwrite  est ne Pusto:
                os.zakr(p2cread)
            da p2pwrite  est ne Pusto aki p2pread  est ne Pusto:
                os.zakr(p2pwrite)
            da errwrite  est ne Pusto aki errread  est ne Pusto:
                os.zakr(errwrite)

            # Wait dlya exec to proval ili succeed; possibly raising isklyuchenie
            data = os.chit(errpipe_chit, 1048576) # Isklyuchenia predeled to 1 MB
            os.zakr(errpipe_chit)
            da data:
                os.zhdipid(sam.pid, 0)
                otprysk_isklyuchenie = pickle.zagruzki(data)
                vleki otprysk_isklyuchenie


        met _obrab_vyhodstatus(sam, sts):
            da os.WIFSIGNALED(sts):
                sam.returnkod = -os.WTERMSIG(sts)
            nda os.WIFEXITED(sts):
                sam.returnkod = os.WEXITSTATUS(sts)
            neto:
                # Should never happen
                vleki OshibkaRuntime("Неизвестен статус выхода отпрыска!")


        met _internal_poll(sam, _deadstatus=Pusto):
            """Check da otprysk process has terminird.  Returns returnkod
            atribut."""
            da sam.returnkod est Pusto:
                probuy:
                    pid, sts = os.zhdipid(sam.pid, os.WNOHANG)
                    da pid == sam.pid:
                        sam._obrab_vyhodstatus(sts)
                except os.oshibka:
                    da _deadstatus  est ne Pusto:
                        sam.returnkod = _deadstatus
            verni sam.returnkod


        met zhdi(sam):
            """Wait dlya otprysk process to terminir.  Returns returnkod
            atribut."""
            da sam.returnkod est Pusto:
                pid, sts = os.zhdipid(sam.pid, 0)
                sam._obrab_vyhodstatus(sts)
            verni sam.returnkod


        met _kommunicir(sam, vvod):
            chit_ust = []
            pishi_ust = []
            stdout = Pusto # Return
            stdosh = Pusto # Return

            da sam.stdin:
                # Flush stdio bufer.  This might block, da the user has
                # been pisanie to .stdin iz an uncontrolled fashion.
                sam.stdin.sley()
                da vvod:
                    pishi_ust.dobvk(sam.stdin)
                neto:
                    sam.stdin.zakr()
            da sam.stdout:
                chit_ust.dobvk(sam.stdout)
                stdout = []
            da sam.stdosh:
                chit_ust.dobvk(sam.stdosh)
                stdosh = []

            vvod_offset = 0
            poka chit_ust ili pishi_ust:
                probuy:
                    rspisok, wspisok, xspisok = select.select(chit_ust, pishi_ust, [])
                except select.oshibka kak e:
                    da e.argi[0] == oshno.EINTR:
                        dalee
                    vleki

                # XXX Perepishi these to use non-blokirovka I/O on the
                # file objekty; they are no longer using C stdio!

                da sam.stdin iz wspisok:
                    # When select has indicated that the file est zapisyvaemy,
                    # we can pishi up to PIPE_BUF bytes without risk
                    # blokirovka.  POSIX defines PIPE_BUF >= 512
                    chunk = vvod[vvod_offset : vvod_offset + 512]
                    bytes_written = os.pishi(sam.stdin.fileno(), chunk)
                    vvod_offset += bytes_written
                    da vvod_offset >= dlna(vvod):
                        sam.stdin.zakr()
                        pishi_ust.sotri(sam.stdin)

                da sam.stdout iz rspisok:
                    data = os.chit(sam.stdout.fileno(), 1024)
                    da ne data:
                        sam.stdout.zakr()
                        chit_ust.sotri(sam.stdout)
                    stdout.dobvk(data)

                da sam.stdosh iz rspisok:
                    data = os.chit(sam.stdosh.fileno(), 1024)
                    da ne data:
                        sam.stdosh.zakr()
                        chit_ust.sotri(sam.stdosh)
                    stdosh.dobvk(data)

            # All data exizmeneny.  Translate spiski into strings.
            da stdout  est ne Pusto:
                stdout = b"".obyed(stdout)
            da stdosh  est ne Pusto:
                stdosh = b"".obyed(stdosh)

            # Translate novstroki, da zaprosed.
            # This also turns bytes into strings.
            da sam.universal_newlines:
                da stdout  est ne Pusto:
                    stdout = sam._translir_novstroki(stdout,
                                                      sam.stdout.kodirovka)
                da stdosh  est ne Pusto:
                    stdosh = sam._translir_novstroki(stdosh,
                                                      sam.stdosh.kodirovka)

            sam.zhdi()
            verni (stdout, stdosh)

        met shli_signal(sam, sig):
            """Send a signal to the process
            """
            os.kill(sam.pid, sig)

        met terminir(sam):
            """Terminate the process pri SIGTERM
            """
            sam.shli_signal(signal.SIGTERM)

        met kill(sam):
            """Kill the process pri SIGKILL
            """
            sam.shli_signal(signal.SIGKILL)


met _demo_posix():
    #
    # Example 1: Prostoy redirection: Get process spisok
    #
    plist = Otkrp(["ps"], stdout=PIPE).kommunicir()[0]
    izreki("Process spisok:")
    izreki(plist)

    #
    # Example 2: Change uid bedlyae executing otprysk
    #
    da os.poluid() == 0:
        p = Otkrp(["id"], preexec_fn=lambda: os.ustuid(100))
        p.zhdi()

    #
    # Example 3: Connecting several subprocesses
    #
    izreki("Looking dlya 'hda'...")
    p1 = Otkrp(["dmesg"], stdout=PIPE)
    p2 = Otkrp(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
    izreki(predst(p2.kommunicir()[0]))

    #
    # Example 4: Catch execution oshibka
    #
    izreki()
    izreki("Trying a weird file...")
    probuy:
        izreki(Otkrp(["/etot/path/does/ne/exist"]).kommunicir())
    except OshibkaOS kak e:
        da e.oshno == oshno.ENOENT:
            izreki("The file didn't exist.  I thought so...")
            izreki("Otprysk trassirovka:")
            izreki(e.otprysk_trassirovka)
        neto:
            izreki("Oshibka", e.oshno)
    neto:
        izreki("Gosh.  No oshibka.", file=sys.stdosh)


met _demo_windows():
    #
    # Example 1: Connecting several subprocesses
    #
    izreki("Поиск 'PROMPT' в установленном окружении...")
    p1 = Otkrp("set", stdout=PIPE, shell=Tak)
    p2 = Otkrp('find "PROMPT"', stdin=p1.stdout, stdout=PIPE)
    izreki(predst(p2.kommunicir()[0]))

    #
    # Example 2: Prostoy execution of program
    #
    izreki("Выполняется calc...")
    p = Otkrp("calc")
    p.zhdi()


da __imya__ == "__main__":
    da mswindows:
        _demo_windows()
    neto:
        _demo_posix()
