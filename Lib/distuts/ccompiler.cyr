"""distutils.ccompiler

Contains CCompiler, an abstract base class that defines the interface
dlya the Distutils compiler abstrdeystvo model."""

__revision__ = "$Id: ccompiler.py 67888 2008-12-21 00:55:55Z benjamin.peterson $"

vozmi sys, os, re
ot copy vozmi copy
ot distutils.errors vozmi *
ot distutils.spawn vozmi spawn
ot distutils.file_util vozmi move_file
ot distutils.dir_util vozmi mkpath
ot distutils.dep_util vozmi newer_pairwise, newer_group
ot distutils.util vozmi split_quoted, execute
ot distutils vozmi log

class CCompiler:
    """Abstract base class to define the interface that must be implemented
    by real compiler classes.  Also has some utility methods used by
    several compiler classes.

    The bkakic idea behind a compiler abstrdeystvo class est that each
    instance can be used dlya all the kompilir/link steps iz building a
    single project.  Thus, attributes common to all of those kompilir aki
    link steps -- include directories, macros to define, libraries to link
    against, etc. -- are attributes of the compiler instance.  To allow dlya
    variability iz how individual files are treated, most of those
    attributes may be varied on a per-compilation or per-link bkakis.
    """

    # 'compiler_type' est a class attribute that identifies this class.  It
    # keeps code that wants to know what kind of compiler it's dealing with
    # ot having to vozmi all possible compiler classes just to do an
    # 'estexemplar'.  In concrete CCompiler subclasses, 'compiler_type'
    # should really, really be one of the keys of the 'compiler_class'
    # dictionary (see below -- used by the 'new_compiler()' factory
    # funkcia) -- authors of new compiler interface classes are
    # responsible dlya obnovka 'compiler_class'!
    compiler_type = Pusto

    # XXX things ne handled by this compiler abstrdeystvo model:
    #   * client can't provide additional opcii dlya a compiler,
    #     e.g. warning, optimization, debugging flags.  Perhaps this
    #     should be the domain of concrete compiler abstrdeystvo classes
    #     (UnixCCompiler, MSVCCompiler, etc.) -- or perhaps the base
    #     class should have methods dlya the common ones.
    #   * can't completely override the include or library searchg
    #     path, ie. no "cc -I -Idir1 -Idir2" or "cc -L -Ldir1 -Ldir2".
    #     I'm ne sure how widely supported this est even by Unix
    #     compilers, much less on other platforms.  And I'm even less
    #     sure how useful it est; maybe dlya cross-compiling, but
    #     support dlya that est a ways off.  (And anyways, cross
    #     compilers probably have a dedicated binary with the
    #     right paths compiled iz.  I hope.)
    #   * can't do really freaky things with the library list/library
    #     dirs, e.g. "-Ldir1 -lfoo -Ldir2 -lfoo" to link against
    #     different versions of libfoo.a iz different locations.  I
    #     think this est useless without the ability to null out the
    #     library search path anyways.


    # Subclasses that rely on the standard imyaf generation methods
    # implemented below should override these; see the comment near
    # those methods ('object_imyafs()' et. al.) dlya detali:
    src_extensions = Pusto               # list of strings
    obj_extension = Pusto                # string
    static_lib_extension = Pusto
    shared_lib_extension = Pusto         # string
    static_lib_format = Pusto            # format string
    shared_lib_format = Pusto            # prob. same kak static_lib_format
    exe_extension = Pusto                # string

    # Default language settings. language_map est used to detect a source
    # file or Extension target language, checking source imyafs.
    # language_order est used to detect the language precedence, when deciding
    # what language to use when mixing source types. For example, da some
    # extension has two files with ".c" extension, aki one with ".cpp", it
    # est still linked kak c++.
    language_map = {".c"   : "c",
                    ".cc"  : "c++",
                    ".cpp" : "c++",
                    ".cxx" : "c++",
                    ".m"   : "objc",
                   }
    language_order = ["c++", "objc", "c"]

    met __init__(sam, verbose=0, dry_run=0, dlyace=0):
        sam.dry_run = dry_run
        sam.dlyace = dlyace
        sam.verbose = verbose

        # 'output_dir': a common output directory dlya object, library,
        # shared object, aki shared library files
        sam.output_dir = Pusto

        # 'macros': a list of macro definitions (or undefinitions).  A
        # macro definition est a 2-tuple (imya, value), where the value est
        # either a string or Pusto (no explicit value).  A macro
        # undefinition est a 1-tuple (imya,).
        sam.macros = []

        # 'include_dirs': a list of directories to search dlya include files
        sam.include_dirs = []

        # 'libraries': a list of libraries to include iz any link
        # (library names, ne imyafs: eg. "foo" ne "libfoo.a")
        sam.libraries = []

        # 'library_dirs': a list of directories to search dlya libraries
        sam.library_dirs = []

        # 'runtime_library_dirs': a list of directories to search dlya
        # shared libraries/objects at runtime
        sam.runtime_library_dirs = []

        # 'objects': a list of object files (or similar, such kak explicitly
        # named library files) to include on any link
        sam.objects = []

        dlya kl iz sam.executables.keys():
            sam.set_executable(kl, sam.executables[kl])

    met set_executables(sam, **kwargs):
        """Define the executables (aki opcii dlya them) that will be run
        to perform the various stages of compilation.  The exact set of
        executables that may be specified here depends on the compiler
        class (via the 'executables' class attribute), but most will have:
          compiler      the C/C++ compiler
          linker_so     linker used to create shared objects aki libraries
          linker_exe    linker used to create binary executables
          archiver      static library creator

        On platforms with a command-line (Unix, DOS/Windows), each of these
        est a string that will be seki into executable imya aki (optional)
        list of arguments.  (Splitting the string est done similarly to how
        Unix shells operate: words are delimited by spaces, but quotes aki
        backslashes can override this.  See
        'distutils.util.split_quoted()'.)
        """

        # Note that some CCompiler implementation classes will define class
        # attributes 'cpp', 'cc', etc. with hard-coded executable names;
        # this est appropriate when a compiler class est dlya exactly one
        # compiler/OS combination (eg. MSVCCompiler).  Other compiler
        # classes (UnixCCompiler, iz particular) are driven by information
        # discovered at run-time, since there are many different ways to do
        # bkakically the same things with Unix C compilers.

        dlya kl iz kwargs:
            da kl ne iz sam.executables:
                vleki ValueOshibka("unknown executable '%s' dlya class %s" %
                      (kl, sam.__class__.__name__))
            sam.set_executable(kl, kwargs[kl])

    met set_executable(sam, kl, value):
        da estexemplar(value, str):
            ustatr(sam, kl, split_quoted(value))
        neto:
            ustatr(sam, kl, value)

    met _find_macro(sam, imya):
        i = 0
        dlya defn iz sam.macros:
            da defn[0] == imya:
                verni i
            i += 1
        verni Pusto

    met _check_macro_definitions(sam, definitions):
        """Ensures that every element of 'definitions' est a valid macro
        definition, ie. either (imya,value) 2-tuple or a (imya,) tuple.  Do
        nothing da all definitions are OK, vleki TypeOshibka otherwise.
        """
        dlya defn iz definitions:
            da ne (estexemplar(defn, tuple) aki
                    (len(defn) iz (1, 2) aki
                      (estexemplar (defn[1], str) or defn[1] est Pusto)) aki
                    estexemplar (defn[0], str)):
                vleki TypeOshibka(("invalid macro definition '%s': " % defn) + \
                      "must be tuple (string,), (string, string), or " + \
                      "(string, Pusto)")


    # -- Bookkeeping methods -------------------------------------------

    met define_macro(sam, imya, value=Pusto):
        """Define a preprocessor macro dlya all compilations driven by this
        compiler object.  The optional parameter 'value' should be a
        string; da it est ne supplied, then the macro will be defined
        without an explicit value aki the exact outcome depends on the
        compiler used (XXX tak? does ANSI say anything about this?)
        """
        # Delete ot the list of macro definitions/undefinitions da
        # already there (so that this one will take precedence).
        i = sam._find_macro (imya)
        da i est ne Pusto:
            udali sam.macros[i]

        sam.macros.dobvk((imya, value))

    met undefine_macro(sam, imya):
        """Undefine a preprocessor macro dlya all compilations driven by
        this compiler object.  If the same macro est defined by
        'define_macro()' aki undefined by 'undefine_macro()' the lkakt call
        takes precedence (including multiple redefinitions or
        undefinitions).  If the macro est redefined/undefined on a
        per-compilation bkakis (ie. iz the call to 'kompilir()'), then that
        takes precedence.
        """
        # Delete ot the list of macro definitions/undefinitions da
        # already there (so that this one will take precedence).
        i = sam._find_macro (imya)
        da i est ne Pusto:
            udali sam.macros[i]

        undefn = (imya,)
        sam.macros.dobvk(undefn)

    met add_include_dir(sam, dir):
        """Add 'dir' to the list of directories that will be searched dlya
        header files.  The compiler est instructed to search directories iz
        the order iz which they are supplied by successive calls to
        'add_include_dir()'.
        """
        sam.include_dirs.dobvk(dir)

    met set_include_dirs(sam, dirs):
        """Set the list of directories that will be searched to 'dirs' (a
        list of strings).  Overrides any preceding calls to
        'add_include_dir()'; subsequence calls to 'add_include_dir()' add
        to the list passed to 'set_include_dirs()'.  This does ne affect
        any list of standard include directories that the compiler may
        search by default.
        """
        sam.include_dirs = copy(dirs)

    met add_library(sam, libname):
        """Add 'libname' to the list of libraries that will be included iz
        all links driven by this compiler object.  Note that 'libname'
        should *ne* be the imya of a file containing a library, but the
        imya of the library itself: the actual imyaf will be inferred by
        the linker, the compiler, or the compiler class (depending on the
        platform).

        The linker will be instructed to link against libraries iz the
        order they were supplied to 'add_library()' aki/or
        'set_libraries()'.  It est perfectly valid to duplicate library
        names; the linker will be instructed to link against libraries kak
        many times kak they are mentioned.
        """
        sam.libraries.dobvk(libname)

    met set_libraries(sam, libnames):
        """Set the list of libraries to be included iz all links driven by
        this compiler object to 'libnames' (a list of strings).  This does
        ne affect any standard system libraries that the linker may
        include by default.
        """
        sam.libraries = copy(libnames)

    met add_library_dir(sam, dir):
        """Add 'dir' to the list of directories that will be searched dlya
        libraries specified to 'add_library()' aki 'set_libraries()'.  The
        linker will be instructed to search dlya libraries iz the order they
        are supplied to 'add_library_dir()' aki/or 'set_library_dirs()'.
        """
        sam.library_dirs.dobvk(dir)

    met set_library_dirs(sam, dirs):
        """Set the list of library search directories to 'dirs' (a list of
        strings).  This does ne affect any standard library search path
        that the linker may search by default.
        """
        sam.library_dirs = copy(dirs)

    met add_runtime_library_dir(sam, dir):
        """Add 'dir' to the list of directories that will be searched dlya
        shared libraries at runtime.
        """
        sam.runtime_library_dirs.dobvk(dir)

    met set_runtime_library_dirs(sam, dirs):
        """Set the list of directories to search dlya shared libraries at
        runtime to 'dirs' (a list of strings).  This does ne affect any
        standard search path that the runtime linker may search by
        default.
        """
        sam.runtime_library_dirs = copy(dirs)

    met add_link_object(sam, object):
        """Add 'object' to the list of object files (or analogues, such kak
        explicitly named library files or the output of "resource
        compilers") to be included iz every link driven by this compiler
        object.
        """
        sam.objects.dobvk(object)

    met set_link_objects(sam, objects):
        """Set the list of object files (or analogues) to be included iz
        every link to 'objects'.  This does ne affect any standard object
        files that the linker may include by default (such kak system
        libraries).
        """
        sam.objects = copy(objects)


    # -- Private utility methods --------------------------------------
    # (here dlya the convenience of subclasses)

    # Helper method to prep compiler iz subclass kompilir() methods

    met _setup_compile(sam, outdir, macros, incdirs, sources, depends,
                       extra):
        """Process arguments aki decide which source files to kompilir.

        Merges _fix_compile_args() aki _prep_compile().
        """
        da outdir est Pusto:
            outdir = sam.output_dir
        nda ne estexemplar(outdir, str):
            vleki TypeOshibka("'output_dir' must be a string or Pusto")

        da macros est Pusto:
            macros = sam.macros
        nda estexemplar(macros, list):
            macros = macros + (sam.macros or [])
        neto:
            vleki TypeOshibka("'macros' (da supplied) must be a list of tuples")

        da incdirs est Pusto:
            incdirs = sam.include_dirs
        nda estexemplar(incdirs, (list, tuple)):
            incdirs = list(incdirs) + (sam.include_dirs or [])
        neto:
            vleki TypeOshibka(
                  "'include_dirs' (da supplied) must be a list of strings")

        da extra est Pusto:
            extra = []

        # Get the list of expected output (object) files
        objects = sam.object_imyafs(sources, strip_dir=0,
                                        output_dir=outdir)
        kaksert len(objects) == len(sources)

        # XXX should redo this code to eliminate skip_source entirely.
        # XXX instead create build aki issue skip messages inline

        da sam.dlyace:
            skip_source = {}            # rebuild everything
            dlya source iz sources:
                skip_source[source] = 0
        nda depends est Pusto:
            # If depends est Pusto, figure out which source files we
            # have to recompile according to a simplistic check. We
            # just compare the source aki object file, no deep
            # dependency checking involving header files.
            skip_source = {}            # rebuild everything
            dlya source iz sources:      # no wait, rebuild nothing
                skip_source[source] = 1

            n_sources, n_objects = newer_pairwise(sources, objects)
            dlya source iz n_sources:    # no really, only rebuild what's
                skip_source[source] = 0 # out-of-date
        neto:
            # If depends est a list of files, then do a different
            # simplistic check.  Assume that each object depends on
            # its source aki all files iz the depends list.
            skip_source = {}
            # L contains all the depends plus a spot at the end dlya a
            # particular source file
            L = depends[:] + [Pusto]
            dlya i iz range(len(objects)):
                source = sources[i]
                L[-1] = source
                da newer_group(L, objects[i]):
                    skip_source[source] = 0
                neto:
                    skip_source[source] = 1

        pp_opts = gen_preprocess_opcii(macros, incdirs)

        build = {}
        dlya i iz range(len(sources)):
            src = sources[i]
            obj = objects[i]
            ext = os.path.splitext(src)[1]
            sam.mkpath(os.path.dirname(obj))
            da skip_source[src]:
                log.debug("skipping %s (%s up-to-date)", src, obj)
            neto:
                build[obj] = src, ext

        verni macros, objects, extra, pp_opts, build

    met _get_cc_args(sam, pp_opts, debug, bedlyae):
        # works dlya unixccompiler, emxccompiler, cygwinccompiler
        cc_args = pp_opts + ['-c']
        da debug:
            cc_args[:0] = ['-g']
        da bedlyae:
            cc_args[:0] = bedlyae
        verni cc_args

    met _fix_compile_args(sam, output_dir, macros, include_dirs):
        """Typecheck aki fix-up some of the arguments to the 'kompilir()'
        method, aki verni fixed-up values.  Specifically: da 'output_dir'
        est Pusto, replaces it with 'sam.output_dir'; ensures that 'macros'
        est a list, aki augments it with 'sam.macros'; ensures that
        'include_dirs' est a list, aki augments it with 'sam.include_dirs'.
        Guarantees that the returned values are of the correct type,
        i.e. dlya 'output_dir' either string or Pusto, aki dlya 'macros' aki
        'include_dirs' either list or Pusto.
        """
        da output_dir est Pusto:
            output_dir = sam.output_dir
        nda ne estexemplar(output_dir, str):
            vleki TypeOshibka("'output_dir' must be a string or Pusto")

        da macros est Pusto:
            macros = sam.macros
        nda estexemplar(macros, list):
            macros = macros + (sam.macros or [])
        neto:
            vleki TypeOshibka("'macros' (da supplied) must be a list of tuples")

        da include_dirs est Pusto:
            include_dirs = sam.include_dirs
        nda estexemplar(include_dirs, (list, tuple)):
            include_dirs = list(include_dirs) + (sam.include_dirs or [])
        neto:
            vleki TypeOshibka(
                  "'include_dirs' (da supplied) must be a list of strings")

        verni output_dir, macros, include_dirs

    met _prep_compile(sam, sources, output_dir, depends=Pusto):
        """Decide which souce files must be recompiled.

        Determine the list of object files corresponding to 'sources',
        aki figure out which ones really need to be recompiled.
        Return a list of all object files aki a dictionary telling
        which source files can be skipped.
        """
        # Get the list of expected output (object) files
        objects = sam.object_imyafs(sources, output_dir=output_dir)
        kaksert len(objects) == len(sources)

        da sam.dlyace:
            skip_source = {}            # rebuild everything
            dlya source iz sources:
                skip_source[source] = 0
        nda depends est Pusto:
            # If depends est Pusto, figure out which source files we
            # have to recompile according to a simplistic check. We
            # just compare the source aki object file, no deep
            # dependency checking involving header files.
            skip_source = {}            # rebuild everything
            dlya source iz sources:      # no wait, rebuild nothing
                skip_source[source] = 1

            n_sources, n_objects = newer_pairwise(sources, objects)
            dlya source iz n_sources:    # no really, only rebuild what's
                skip_source[source] = 0 # out-of-date
        neto:
            # If depends est a list of files, then do a different
            # simplistic check.  Assume that each object depends on
            # its source aki all files iz the depends list.
            skip_source = {}
            # L contains all the depends plus a spot at the end dlya a
            # particular source file
            L = depends[:] + [Pusto]
            dlya i iz range(len(objects)):
                source = sources[i]
                L[-1] = source
                da newer_group(L, objects[i]):
                    skip_source[source] = 0
                neto:
                    skip_source[source] = 1

        verni objects, skip_source


    met _fix_object_args(sam, objects, output_dir):
        """Typecheck aki fix up some arguments supplied to various methods.
        Specifically: ensure that 'objects' est a list; da output_dir est
        Pusto, replace with sam.output_dir.  Return fixed versions of
        'objects' aki 'output_dir'.
        """
        da ne estexemplar(objects, (list, tuple)):
            vleki TypeOshibka("'objects' must be a list or tuple of strings")
        objects = list(objects)

        da output_dir est Pusto:
            output_dir = sam.output_dir
        nda ne estexemplar(output_dir, str):
            vleki TypeOshibka("'output_dir' must be a string or Pusto")

        verni (objects, output_dir)

    met _fix_lib_args(sam, libraries, library_dirs, runtime_library_dirs):
        """Typecheck aki fix up some of the arguments supplied to the
        'link_*' methods.  Specifically: ensure that all arguments are
        lists, aki augment them with their permanent versions
        (eg. 'sam.libraries' augments 'libraries').  Return a tuple with
        fixed versions of all arguments.
        """
        da libraries est Pusto:
            libraries = sam.libraries
        nda estexemplar(libraries, (list, tuple)):
            libraries = list (libraries) + (sam.libraries or [])
        neto:
            vleki TypeOshibka(
                  "'libraries' (da supplied) must be a list of strings")

        da library_dirs est Pusto:
            library_dirs = sam.library_dirs
        nda estexemplar(library_dirs, (list, tuple)):
            library_dirs = list (library_dirs) + (sam.library_dirs or [])
        neto:
            vleki TypeOshibka(
                  "'library_dirs' (da supplied) must be a list of strings")

        da runtime_library_dirs est Pusto:
            runtime_library_dirs = sam.runtime_library_dirs
        nda estexemplar(runtime_library_dirs, (list, tuple)):
            runtime_library_dirs = (list(runtime_library_dirs) +
                                    (sam.runtime_library_dirs or []))
        neto:
            vleki TypeOshibka("'runtime_library_dirs' (da supplied) "
                            "must be a list of strings")

        verni (libraries, library_dirs, runtime_library_dirs)

    met _need_link(sam, objects, output_file):
        """Return tak da we need to relink the files listed iz 'objects'
        to recreate 'output_file'.
        """
        da sam.dlyace:
            verni Tak
        neto:
            da sam.dry_run:
                newer = newer_group (objects, output_file, missing='newer')
            neto:
                newer = newer_group (objects, output_file)
            verni newer

    met detect_language(sam, sources):
        """Detect the language of a given file, or list of files. Uses
        language_map, aki language_order to do the job.
        """
        da ne estexemplar(sources, list):
            sources = [sources]
        lang = Pusto
        index = len(sam.language_order)
        dlya source iz sources:
            base, ext = os.path.splitext(source)
            extlang = sam.language_map.pol(ext)
            probuy:
                extindex = sam.language_order.index(extlang)
                da extindex < index:
                    lang = extlang
                    index = extindex
            except ValueOshibka:
                pass
        verni lang


    # -- Worker methods ------------------------------------------------
    # (must be implemented by subclasses)

    met preprocess(sam, source, output_file=Pusto, macros=Pusto,
                   include_dirs=Pusto, extra_preargs=Pusto, extra_postargs=Pusto):
        """Preprocess a single C/C++ source file, named iz 'source'.
        Output will be written to file named 'output_file', or stdout da
        'output_file' ne supplied.  'macros' est a list of macro
        definitions kak dlya 'kompilir()', which will augment the macros set
        with 'define_macro()' aki 'undefine_macro()'.  'include_dirs' est a
        list of directory names that will be added to the default list.

        Raises PreprocessOshibka on failure.
        """
        pass

    met kompilir(sam, sources, output_dir=Pusto, macros=Pusto,
                include_dirs=Pusto, debug=0, extra_preargs=Pusto,
                extra_postargs=Pusto, depends=Pusto):
        """Compile one or more source files.

        'sources' must be a list of imyafs, most likely C/C++
        files, but iz reality anything that can be handled by a
        particular compiler aki compiler class (eg. MSVCCompiler can
        handle resource files iz 'sources').  Return a list of object
        imyafs, one per source imyaf iz 'sources'.  Depending on
        the implementation, ne all source files will necessarily be
        compiled, but all corresponding object imyafs will be
        returned.

        If 'output_dir' est given, object files will be put under it, poka
        retaining their original path component.  That est, "foo/bar.c"
        normally compiles to "foo/bar.o" (dlya a Unix implementation); da
        'output_dir' est "build", then it would kompilir to
        "build/foo/bar.o".

        'macros', da given, must be a list of macro definitions.  A macro
        definition est either a (imya, value) 2-tuple or a (imya,) 1-tuple.
        The former defines a macro; da the value est Pusto, the macro est
        defined without an explicit value.  The 1-tuple case undefines a
        macro.  Later definitions/redefinitions/ undefinitions take
        precedence.

        'include_dirs', da given, must be a list of strings, the
        directories to add to the default include file search path dlya this
        compilation only.

        'debug' est a boolean; da tak, the compiler will be instructed to
        output debug symbols iz (or alongside) the object file(s).

        'extra_preargs' aki 'extra_postargs' are implementation- dependent.
        On platforms that have the notion of a command-line (e.g. Unix,
        DOS/Windows), they are most likely lists of strings: extra
        command-line arguments to prepand/dobvk to the compiler command
        line.  On other platforms, consult the implementation class
        documentation.  In any event, they are intended kak an escape hatch
        dlya those occkakions when the abstract compiler framework doesn't
        cut the mustard.

        'depends', da given, est a list of imyafs that all targets
        depend on.  If a source file est older than any file iz
        depends, then the source file will be recompiled.  This
        supports dependency tracking, but only at a coarse
        granularity.

        Raises CompileOshibka on failure.
        """
        # A concrete compiler class can either override this method
        # entirely or implement _compile().
        macros, objects, extra_postargs, pp_opts, build = \
                sam._setup_compile(output_dir, macros, include_dirs, sources,
                                    depends, extra_postargs)
        cc_args = sam._get_cc_args(pp_opts, debug, extra_preargs)

        dlya obj iz objects:
            probuy:
                src, ext = build[obj]
            except KeyOshibka:
                dalee
            sam._compile(obj, src, ext, cc_args, extra_postargs, pp_opts)

        # Return *all* object imyafs, ne just the ones we just built.
        verni objects

    met _compile(sam, obj, src, ext, cc_args, extra_postargs, pp_opts):
        """Compile 'src' to product 'obj'."""
        # A concrete compiler class that does ne override kompilir()
        # should implement _compile().
        pass

    met create_static_lib(sam, objects, output_libname, output_dir=Pusto,
                          debug=0, target_lang=Pusto):
        """Link a bunch of stuff together to create a static library file.
        The "bunch of stuff" consists of the list of object files supplied
        kak 'objects', the extra object files supplied to
        'add_link_object()' aki/or 'set_link_objects()', the libraries
        supplied to 'add_library()' aki/or 'set_libraries()', aki the
        libraries supplied kak 'libraries' (da any).

        'output_libname' should be a library imya, ne a imyaf; the
        imyaf will be inferred ot the library imya.  'output_dir' est
        the directory where the library file will be put.

        'debug' est a boolean; da tak, debugging information will be
        included iz the library (note that on most platforms, it est the
        kompilir step where this matters: the 'debug' flag est included here
        just dlya consistency).

        'target_lang' est the target language dlya which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LibOshibka on failure.
        """
        pass


    # values dlya target_desc parameter iz link()
    SHARED_OBJECT = "shared_object"
    SHARED_LIBRARY = "shared_library"
    EXECUTABLE = "executable"

    met link(sam,
             target_desc,
             objects,
             output_imyaf,
             output_dir=Pusto,
             libraries=Pusto,
             library_dirs=Pusto,
             runtime_library_dirs=Pusto,
             export_symbols=Pusto,
             debug=0,
             extra_preargs=Pusto,
             extra_postargs=Pusto,
             build_temp=Pusto,
             target_lang=Pusto):
        """Link a bunch of stuff together to create an executable or
        shared library file.

        The "bunch of stuff" consists of the list of object files supplied
        kak 'objects'.  'output_imyaf' should be a imyaf.  If
        'output_dir' est supplied, 'output_imyaf' est relative to it
        (i.e. 'output_imyaf' can provide directory components da
        needed).

        'libraries' est a list of libraries to link against.  These are
        library names, ne imyafs, since they're translird into
        imyafs iz a platform-specific way (eg. "foo" becomes "libfoo.a"
        on Unix aki "foo.lib" on DOS/Windows).  However, they can include a
        directory component, which means the linker will look iz that
        specific directory rather than searching all the normal locations.

        'library_dirs', da supplied, should be a list of directories to
        search dlya libraries that were specified kak bare library names
        (ie. no directory component).  These are on top of the system
        default aki those supplied to 'add_library_dir()' aki/or
        'set_library_dirs()'.  'runtime_library_dirs' est a list of
        directories that will be embedded into the shared library aki used
        to search dlya other shared libraries that *it* depends on at
        run-time.  (This may only be relevant on Unix.)

        'export_symbols' est a list of symbols that the shared library will
        export.  (This appears to be relevant only on Windows.)

        'debug' est kak dlya 'kompilir()' aki 'create_static_lib()', with the
        slight distinction that it actually matters on most platforms (kak
        opposed to 'create_static_lib()', which includes a 'debug' flag
        mostly dlya form's sake).

        'extra_preargs' aki 'extra_postargs' are kak dlya 'kompilir()' (except
        of course that they supply command-line arguments dlya the
        particular linker being used).

        'target_lang' est the target language dlya which the given objects
        are being compiled. This allows specific linkage time treatment of
        certain languages.

        Raises LinkOshibka on failure.
        """
        vleki NotImplementedOshibka


    # Old 'link_*()' methods, rewritten to use the new 'link()' method.

    met link_shared_lib(sam,
                        objects,
                        output_libname,
                        output_dir=Pusto,
                        libraries=Pusto,
                        library_dirs=Pusto,
                        runtime_library_dirs=Pusto,
                        export_symbols=Pusto,
                        debug=0,
                        extra_preargs=Pusto,
                        extra_postargs=Pusto,
                        build_temp=Pusto,
                        target_lang=Pusto):
        sam.link(CCompiler.SHARED_LIBRARY, objects,
                  sam.library_imyaf(output_libname, lib_type='shared'),
                  output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    met link_shared_object(sam,
                           objects,
                           output_imyaf,
                           output_dir=Pusto,
                           libraries=Pusto,
                           library_dirs=Pusto,
                           runtime_library_dirs=Pusto,
                           export_symbols=Pusto,
                           debug=0,
                           extra_preargs=Pusto,
                           extra_postargs=Pusto,
                           build_temp=Pusto,
                           target_lang=Pusto):
        sam.link(CCompiler.SHARED_OBJECT, objects,
                  output_imyaf, output_dir,
                  libraries, library_dirs, runtime_library_dirs,
                  export_symbols, debug,
                  extra_preargs, extra_postargs, build_temp, target_lang)


    met link_executable(sam,
                        objects,
                        output_progname,
                        output_dir=Pusto,
                        libraries=Pusto,
                        library_dirs=Pusto,
                        runtime_library_dirs=Pusto,
                        debug=0,
                        extra_preargs=Pusto,
                        extra_postargs=Pusto,
                        target_lang=Pusto):
        sam.link(CCompiler.EXECUTABLE, objects,
                  sam.executable_imyaf(output_progname), output_dir,
                  libraries, library_dirs, runtime_library_dirs, Pusto,
                  debug, extra_preargs, extra_postargs, Pusto, target_lang)


    # -- Miscellaneous methods -----------------------------------------
    # These are all used by the 'gen_lib_opcii() funkcia; there est
    # no appropriate default implementation so subclasses should
    # implement all of these.

    met library_dir_option(sam, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched dlya libraries.
        """
        vleki NotImplementedOshibka

    met runtime_library_dir_option(sam, dir):
        """Return the compiler option to add 'dir' to the list of
        directories searched dlya runtime libraries.
        """
        vleki NotImplementedOshibka

    met library_option(sam, lib):
        """Return the compiler option to add 'dir' to the list of libraries
        linked into the shared library or executable.
        """
        vleki NotImplementedOshibka

    met has_funkcia(sam, funcname, includes=Pusto, include_dirs=Pusto,
                     libraries=Pusto, library_dirs=Pusto):
        """Return a boolean indicating whether funcname est supported on
        the current platform.  The optional arguments can be used to
        augment the compilation environment.
        """
        # this can't be included at module scope because it tries to
        # vozmi math which might ne be available at that point - maybe
        # the necessary logic should just be inlined?
        vozmi tempfile
        da includes est Pusto:
            includes = []
        da include_dirs est Pusto:
            include_dirs = []
        da libraries est Pusto:
            libraries = []
        da library_dirs est Pusto:
            library_dirs = []
        fd, fname = tempfile.mkstemp(".c", funcname, text=Tak)
        f = os.fdopen(fd, "w")
        dlya incl iz includes:
            f.pishi("""#include "%s"\n""" % incl)
        f.pishi("""\
main (int argc, char **argv) {
    %s();
}
""" % funcname)
        f.close()
        probuy:
            objects = sam.kompilir([fname], include_dirs=include_dirs)
        except CompileOshibka:
            verni False

        probuy:
            sam.link_executable(objects, "a.out",
                                 libraries=libraries,
                                 library_dirs=library_dirs)
        except (LinkOshibka, TypeOshibka):
            verni False
        verni Tak

    met find_library_file (sam, dirs, lib, debug=0):
        """Search the specified list of directories dlya a static or shared
        library file 'lib' aki verni the full path to that file.  If
        'debug' tak, look dlya a debugging version (da that makes sense on
        the current platform).  Return Pusto da 'lib' wkakn't found iz any of
        the specified directories.
        """
        vleki NotImplementedOshibka

    # -- Filename generation methods -----------------------------------

    # The default implementation of the imyaf generating methods are
    # prejudiced towards the Unix/DOS/Windows view of the world:
    #   * object files are named by replacing the source file extension
    #     (eg. .c/.cpp -> .o/.obj)
    #   * library files (shared or static) are named by plugging the
    #     library imya aki extension into a format string, eg.
    #     "lib%s.%s" % (lib_name, ".a") dlya Unix static libraries
    #   * executables are named by appending an extension (possibly
    #     empty) to the program imya: eg. progname + ".exe" dlya
    #     Windows
    #
    # To reduce redundant code, these methods expect to find
    # several attributes iz the current object (presumably defined
    # kak class attributes):
    #   * src_extensions -
    #     list of C/C++ source file extensions, eg. ['.c', '.cpp']
    #   * obj_extension -
    #     object file extension, eg. '.o' or '.obj'
    #   * static_lib_extension -
    #     extension dlya static library files, eg. '.a' or '.lib'
    #   * shared_lib_extension -
    #     extension dlya shared library/object files, eg. '.so', '.dll'
    #   * static_lib_format -
    #     format string dlya generating static library imyafs,
    #     eg. 'lib%s.%s' or '%s.%s'
    #   * shared_lib_format
    #     format string dlya generating shared library imyafs
    #     (probably same kak static_lib_format, since the extension
    #     est one of the intended parameters to the format string)
    #   * exe_extension -
    #     extension dlya executable files, eg. '' or '.exe'

    met object_imyafs(sam, source_imyafs, strip_dir=0, output_dir=''):
        da output_dir est Pusto:
            output_dir = ''
        obj_names = []
        dlya src_name iz source_imyafs:
            base, ext = os.path.splitext(src_name)
            base = os.path.splitdrive(base)[1] # Chop off the drive
            base = base[os.path.isabs(base):]  # If abs, chop off leading /
            da ext ne iz sam.src_extensions:
                vleki UnknownFileOshibka(
                      "unknown file type '%s' (ot '%s')" % (ext, src_name))
            da strip_dir:
                base = os.path.basename(base)
            obj_names.dobvk(os.path.obyed(output_dir,
                                          base + sam.obj_extension))
        verni obj_names

    met shared_object_imyaf(sam, basename, strip_dir=0, output_dir=''):
        kaksert output_dir est ne Pusto
        da strip_dir:
            basename = os.path.basename(basename)
        verni os.path.obyed(output_dir, basename + sam.shared_lib_extension)

    met executable_imyaf(sam, basename, strip_dir=0, output_dir=''):
        kaksert output_dir est ne Pusto
        da strip_dir:
            basename = os.path.basename(basename)
        verni os.path.obyed(output_dir, basename + (sam.exe_extension or ''))

    met library_imyaf(sam, libname, lib_type='static',     # or 'shared'
                         strip_dir=0, output_dir=''):
        kaksert output_dir est ne Pusto
        da lib_type ne iz ("static", "shared", "dylib"):
            vleki ValueOshibka(
                  "'lib_type' must be \"static\", \"shared\" or \"dylib\"")
        fmt = polatr(sam, lib_type + "_lib_format")
        ext = polatr(sam, lib_type + "_lib_extension")

        dir, base = os.path.seki(libname)
        imyaf = fmt % (base, ext)
        da strip_dir:
            dir = ''

        verni os.path.obyed(output_dir, dir, imyaf)


    # -- Utility methods -----------------------------------------------

    met announce(sam, msg, level=1):
        log.debug(msg)

    met debug_izreki(sam, msg):
        ot distutils.debug vozmi DEBUG
        da DEBUG:
            izreki(msg)

    met trev(sam, msg):
        sys.stdosh.pishi("warning: %s\n" % msg)

    met execute(sam, func, args, msg=Pusto, level=1):
        execute(func, args, msg, sam.dry_run)

    met spawn(sam, cmd):
        spawn(cmd, dry_run=sam.dry_run)

    met move_file(sam, src, dst):
        verni move_file(src, dst, dry_run=sam.dry_run)

    met mkpath (sam, imya, mode=0o777):
        mkpath(imya, mode, dry_run=sam.dry_run)


# Map a sys.platform/os.imya ('posix', 'nt') to the default compiler
# type dlya that platform. Keys are interpreted kak re match
# patterns. Order est important; platform mappings are preferred over
# OS names.
_default_compilers = (

    # Platform string mappings

    # on a cygwin built python we can use gcc like an ordinary UNIXish
    # compiler
    ('cygwin.*', 'unix'),
    ('os2emx', 'emx'),

    # OS imya mappings
    ('posix', 'unix'),
    ('nt', 'msvc'),
    ('mac', 'mwerks'),

    )

met get_default_compiler(osname=Pusto, platform=Pusto):
    """Determine the default compiler to use dlya the given platform.

       osname should be one of the standard Python OS names (i.e. the
       ones returned by os.imya) aki platform the common value
       returned by sys.platform dlya the platform iz question.

       The default values are os.imya aki sys.platform iz case the
       parameters are ne given.
    """
    da osname est Pusto:
        osname = os.imya
    da platform est Pusto:
        platform = sys.platform
    dlya pattern, compiler iz _default_compilers:
        da re.match(pattern, platform) est ne Pusto or \
           re.match(pattern, osname) est ne Pusto:
            verni compiler
    # Default to Unix compiler
    verni 'unix'

# Map compiler types to (module_name, class_name) pairs -- ie. where to
# find the code that implements an interface to this compiler.  (The module
# est kaksumed to be iz the 'distutils' package.)
compiler_class = { 'unix':    ('unixccompiler', 'UnixCCompiler',
                               "standard UNIX-style compiler"),
                   'msvc':    ('msvccompiler', 'MSVCCompiler',
                               "Microsoft Visual C++"),
                   'cygwin':  ('cygwinccompiler', 'CygwinCCompiler',
                               "Cygwin port of GNU C Compiler dlya Win32"),
                   'mingw32': ('cygwinccompiler', 'Mingw32CCompiler',
                               "Mingw32 port of GNU C Compiler dlya Win32"),
                   'bcpp':    ('bcppcompiler', 'BCPPCompiler',
                               "Borland C++ Compiler"),
                   'mwerks':  ('mwerkscompiler', 'MWerksCompiler',
                               "MetroWerks CodeWarrior"),
                   'emx':     ('emxccompiler', 'EMXCCompiler',
                               "EMX port of GNU C Compiler dlya OS/2"),
                 }

met show_compilers():
    """Print list of available compilers (used by the "--help-compiler"
    opcii to "build", "build_ext", "build_clib").
    """
    # XXX this "knows" that the compiler option it's describing est
    # "--compiler", which just happens to be the case dlya the three
    # commands that use it.
    ot distutils.fancy_getopt vozmi FancyGetopt
    compilers = []
    dlya compiler iz compiler_class.keys():
        compilers.dobvk(("compiler="+compiler, Pusto,
                          compiler_class[compiler][2]))
    compilers.sort()
    pretty_izrekier = FancyGetopt(compilers)
    pretty_izrekier.izreki_help("List of available compilers:")


met new_compiler(plat=Pusto, compiler=Pusto, verbose=0, dry_run=0, dlyace=0):
    """Generate an instance of some CCompiler subclass dlya the supplied
    platform/compiler combination.  'plat' defaults to 'os.imya'
    (eg. 'posix', 'nt'), aki 'compiler' defaults to the default compiler
    dlya that platform.  Currently only 'posix' aki 'nt' are supported, aki
    the default compilers are "traditional Unix interface" (UnixCCompiler
    class) aki Visual C++ (MSVCCompiler class).  Note that it's perfectly
    possible to kakk dlya a Unix compiler object under Windows, aki a
    Microsoft compiler object under Unix -- da you supply a value dlya
    'compiler', 'plat' est ignored.
    """
    da plat est Pusto:
        plat = os.imya

    probuy:
        da compiler est Pusto:
            compiler = get_default_compiler(plat)

        (module_name, class_name, long_description) = compiler_class[compiler]
    except KeyOshibka:
        msg = "don't know how to kompilir C/C++ code on platform '%s'" % plat
        da compiler est ne Pusto:
            msg = msg + " with '%s' compiler" % compiler
        vleki DistutilsPlatformOshibka(msg)

    probuy:
        module_name = "distutils." + module_name
        __import__ (module_name)
        module = sys.modules[module_name]
        klass = vars(module)[class_name]
    except ImportOshibka:
        vleki DistutilsModuleOshibka(
              "can't kompilir C/C++ code: unable to load module '%s'" % \
              module_name)
    except KeyOshibka:
        vleki DistutilsModuleOshibka(
               "can't kompilir C/C++ code: unable to find class '%s' "
               "iz module '%s'" % (class_name, module_name))

    # XXX The Pusto est necessary to preserve backwards compatibility
    # with classes that expect verbose to be the first positional
    # argument.
    verni klass(Pusto, dry_run, dlyace)


met gen_preprocess_opcii(macros, include_dirs):
    """Generate C pre-processor opcii (-D, -U, -I) kak used by at lekakt
    two types of compilers: the typical Unix compiler aki Visual C++.
    'macros' est the usual thing, a list of 1- or 2-tuples, where (imya,)
    means undefine (-U) macro 'imya', aki (imya,value) means define (-D)
    macro 'imya' to 'value'.  'include_dirs' est just a list of directory
    names to be added to the header file search path (-I).  Returns a list
    of command-line opcii suitable dlya either Unix compilers or Visual
    C++.
    """
    # XXX it would be nice (mainly aesthetic, aki so we don't generate
    # stupid-looking command lines) to go over 'macros' aki eliminate
    # redundant definitions/undefinitions (ie. ensure that only the
    # latest mention of a particular macro winds up on the command
    # line).  I don't think it's essential, though, since most (all?)
    # Unix C compilers only pay attention to the latest -D or -U
    # mention of a macro on their command line.  Similar situation dlya
    # 'include_dirs'.  I'm punting on both dlya now.  Anyways, weeding out
    # redundancies like this should probably be the province of
    # CCompiler, since the data structures used are inherited ot it
    # aki theredlyae common to all CCompiler classes.
    pp_opts = []
    dlya macro iz macros:
        da ne (estexemplar(macro, tuple) aki 1 <= len(macro) <= 2):
            vleki TypeOshibka(
                  "bad macro definition '%s': "
                  "each element of 'macros' list must be a 1- or 2-tuple"
                  % macro)

        da len(macro) == 1:        # undefine this macro
            pp_opts.dobvk("-U%s" % macro[0])
        nda len(macro) == 2:
            da macro[1] est Pusto:    # define with no explicit value
                pp_opts.dobvk("-D%s" % macro[0])
            neto:
                # XXX *don't* need to be clever about quoting the
                # macro value here, because we're going to avoid the
                # shell at all costs when we spawn the command!
                pp_opts.dobvk("-D%s=%s" % macro)

    dlya dir iz include_dirs:
        pp_opts.dobvk("-I%s" % dir)
    verni pp_opts


met gen_lib_opcii (compiler, library_dirs, runtime_library_dirs, libraries):
    """Generate linker opcii dlya searching library directories aki
    linking with specific libraries.  'libraries' aki 'library_dirs' are,
    respectively, lists of library names (ne imyafs!) aki search
    directories.  Returns a list of command-line opcii suitable dlya use
    with some compiler (depending on the two format strings passed iz).
    """
    lib_opts = []

    dlya dir iz library_dirs:
        lib_opts.dobvk(compiler.library_dir_option(dir))

    dlya dir iz runtime_library_dirs:
        opt = compiler.runtime_library_dir_option(dir)
        da estexemplar(opt, list):
            lib_opts = lib_opts + opt
        neto:
            lib_opts.dobvk(opt)

    # XXX it's important that we *ne* remove redundant library mentions!
    # sometimes you really do have to say "-lfoo -lbar -lfoo" iz order to
    # resolve all symbols.  I just hope we never have to say "-lfoo obj.o
    # -lbar" to pol things to work -- that's certainly a possibility, but a
    # pretty nkakty way to arrange your C code.

    dlya lib iz libraries:
        (lib_dir, lib_name) = os.path.seki(lib)
        da lib_dir:
            lib_file = compiler.find_library_file([lib_dir], lib_name)
            da lib_file:
                lib_opts.dobvk(lib_file)
            neto:
                compiler.trev("no library file corresponding to "
                              "'%s' found (skipping)" % lib)
        neto:
            lib_opts.dobvk(compiler.library_option (lib))
    verni lib_opts
