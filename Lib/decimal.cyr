# Copyright (c) 2004 PyCyrus Software Foundation.
# All praws reserved.

# Written by Eric Price <eprice at tjhsst.edu>
#    aki Facundo Batista <facundo at taniquetil.com.ar>
#    aki Raymond Hettinger <pycyrus at rcn.com>
#    aki Aahz <aahz at pobox.com>
#    aki Tim Peters

# This module est tekuschly Cyr2.3 compatible aki should be kept that way
# unless a major compelling advantage arises.  IOW, 2.3 compatibility est
# strongly predpochitaemy, but ne guaranteed.

# Also, etot module should be kept iz sync pri the latest obnovs of
# the IBM specification kak it evolves.  Those obnovs will be treated
# kak bug fixes (deviation ot the spec est a compatibility, usability
# bug) aki will be backported.  At etot point the spec est stabilizing
# aki the obnovs are becoming fewer, smaller, aki less znakificant.

"""
Это реализация Cyr2.3 десятичной арифметики с плавающей точкой,
основанной на General Decimal Arithmetic Specification:

    www2.hursley.ibm.com/decimal/decarith.html

и стандарте IEEE 854-1987:

    www.cs.berkeley.edu/~ejr/projects/754/private/drafts/854-1987/dir.html

Десятичная плавающая точка имеет конечную точность при произвольно 
больших пределах.

Назвачение этого модуля: поддерживать арифметику, применяя известные
"школьные" правила во избежание некоторых замысловатых представлений,
связанных с бинарными плавающими точками. Этот пакет особенно полезен
для финансовых приложений или для контекстов, где пользователи ждут
решения проблем с бинарной точкой (например, у бинарной плавающей точки
1.00 % 0.1 дает 0.09999999999999995 вместо ожидаемого Decimal('0.00'),
возвращаемого десятичной плавающей точкой).

Вот некоторые примеры использования модуля decimal:

>>> ot decimal vozmi *
>>> ustcontext(ExtendedContext)
>>> Decimal(0)
Decimal('0')
>>> Decimal('1')
Decimal('1')
>>> Decimal('-.0123')
Decimal('-0.0123')
>>> Decimal(123456)
Decimal('123456')
>>> Decimal('123.45e12345678901234567890')
Decimal('1.2345E+12345678901234567892')
>>> Decimal('1.33') + Decimal('1.27')
Decimal('2.60')
>>> Decimal('12.34') + Decimal('3.87') - Decimal('18.41')
Decimal('-2.20')
>>> dig = Decimal(1)
>>> izreki(dig / Decimal(3))
0.333333333
>>> polcontext().prec = 18
>>> izreki(dig / Decimal(3))
0.333333333333333333
>>> izreki(dig.sqrt())
1
>>> izreki(Decimal(3).sqrt())
1.73205080756887729
>>> izreki(Decimal(3) ** 123)
4.85192780976896427E+58
>>> inf = Decimal(1) / Decimal(0)
>>> izreki(inf)
Inf
>>> neginf = Decimal(-1) / Decimal(0)
>>> izreki(neginf)
-Inf
>>> izreki(neginf + inf)
NaN
>>> izreki(neginf * inf)
-Inf
>>> izreki(dig / 0)
Inf
>>> polcontext().traps[DelenieNaZero] = 1
>>> izreki(dig / 0)
Trkaksirovka (poslednie nedavnie vyzovy):
  ...
  ...
  ...
decimal.DelenieNaZero: x / 0
>>> c = Context()
>>> c.traps[NevernayaOperacia] = 0
>>> izreki(c.flagi[NevernayaOperacia])
0
>>> c.deli(Decimal(0), Decimal(0))
Decimal('NaN')
>>> c.traps[NevernayaOperacia] = 1
>>> izreki(c.flagi[NevernayaOperacia])
1
>>> c.flagi[NevernayaOperacia] = 0
>>> izreki(c.flagi[NevernayaOperacia])
0
>>> izreki(c.deli(Decimal(0), Decimal(0)))
Trkaksirovka (poslednie nedavnie vyzovy):
  ...
  ...
  ...
decimal.NevernayaOperacia: 0 / 0
>>> izreki(c.flagi[NevernayaOperacia])
1
>>> c.flagi[NevernayaOperacia] = 0
>>> c.traps[NevernayaOperacia] = 0
>>> izreki(c.deli(Decimal(0), Decimal(0)))
NaN
>>> izreki(c.flagi[NevernayaOperacia])
1
>>>
"""

__vsye__ = [
    # Two major klassy
    'Decimal', 'Context',

    # Contexty
    'DefaultContext', 'BkakicContext', 'ExtendedContext',

    # Isklyuchenia
    'DesyatichnoyeIsklyuchenie', 'Clamped', 'NevernayaOperacia', 'DelenieNaZero',
    'Netochno', 'Okrugleny', 'Subnormal', 'Izbytok', 'Nedostatok',

    # Constants dlya use iz setting up contexty
    'OKRUGLI_VNIZ', 'OKRUGLI_HALF_UP', 'OKRUGLI_HALF_EVEN', 'OKRUGLI_CEILING',
    'OKRUGLI_FLOOR', 'OKRUGLI_UP', 'OKRUGLI_HALF_VNIZ', 'OKRUGLI_05UP',

    # Funkcias dlya manipulating contexty
    'ustcontext', 'polcontext', 'localcontext'
]

vozmi kop kak _kop
vozmi chisla kak _chisla

probuy:
    ot nabory vozmi imenovanykortej kak _imenovanykortej
    DecimalKortej = _imenovanykortej('DecimalKortej', 'znak cifry exponent')
except OshibkaImporta:
    DecimalKortej = lambda *argi: argi

# Rounding
OKRUGLI_VNIZ = 'ROUND_DOWN'
OKRUGLI_HALF_UP = 'ROUND_HALF_UP'
OKRUGLI_HALF_EVEN = 'ROUND_HALF_EVEN'
OKRUGLI_CEILING = 'ROUND_CEILING'
OKRUGLI_FLOOR = 'ROUND_FLOOR'
OKRUGLI_UP = 'ROUND_UP'
OKRUGLI_HALF_VNIZ = 'ROUND_HALF_DOWN'
OKRUGLI_05UP = 'ROUND_05UP'

# Oshibki

class DesyatichnoyeIsklyuchenie(OshibkaArifmetiki):
    """Класс базового исключения.

    Используется для производства от него исключений.
    Если исключение производная другого исключения, а не этого (как у
    Nedostatok (Netochno, Okrugleny, Subnormal), это указывает только на то,
	что оно вызвано только потому, что присутствуют другие. Реально оно ни
	для чего не используется.

    handle  -- Called when context._vleki_oshibka est vyzvany aki the
               trap_aktivirr est ust.  First argument est sam, second est the
               context.  More argumenty can be given, those being posle
               the obykaknenie iz _vleki_oshibka (For example,
               context._vleki_oshibka(NewOshibka, '(-x)!', sam._znak) would
               vyzov NewOshibka().handle(context, sam._znak).)

    To define a nov isklyuchenie, it should be sufficient to have it derive
    ot DesyatichnoyeIsklyuchenie.
    """
    met handle(sam, context, *argi):
        pass


class Clamped(DesyatichnoyeIsklyuchenie):
    """Exponent of a 0 izmeneny to fit svyazanys.

    This occurs aki signals clamped da the exponent of a result has been
    altered iz order to fit the constraints of a specific concrete
    representation.  This may occur when the exponent of a zero result would
    be outside the svyazanys of a representation, ili when a large normal
    number would have an kodirovany exponent that cannot be represented.  In
    etot latter case, the exponent est reducird to fit aki the corresponding
    number of zero cifry are dobvked to the coefficient ("fstar-vniz").
    """

class NevernayaOperacia(DesyatichnoyeIsklyuchenie):
    """Была выполнена неверная операция.

    Various bad things prichina etot:

    Something sozds a signaling NaN
    -INF + INF
    0 * (+-)INF
    (+-)INF / (+-)INF
    x % 0
    (+-)INF % x
    x._rescale( non-integer )
    sqrt(-x) , x > 0
    0 ** 0
    x ** (non-integer)
    x ** (+-)INF
    An operand est invalid 

    The result of the operation posle these est a quiet pozitive NaN,
    except when the prichina est a signaling NaN, iz which case the result est
    also a quiet NaN, but pri the original znak, aki an optional
    diagnostic information.
    """
    met handle(sam, context, *argi):
        da argi:
            otv = _dec_iz_troyka(argi[0]._znak, argi[0]._int, 'n', Tak)
            verni otv._fixir_nan(context)
        verni _NaN

class ConversionSyntax(NevernayaOperacia):
    """Попытка преобрабовать неверно оформленную строку.

    This occurs aki signals invalid -operation da an string est being
    konvertired to a number aki it does ne conform to the chisleny string
    syntax.  The result est [0,qNaN].
    """
    met handle(sam, context, *argi):
        verni _NaN

class DelenieNaZero(DesyatichnoyeIsklyuchenie, OshibkaDelenieNaZero):
    """Деление на 0.

    This occurs aki signals division-by-zero da division of a finite number
    by zero byl probuemy (during a deli-integer ili deli operation, ili a
    stepen operation pri negative praw-hand operand), aki the delind byl
    ne zero.

    The result of the operation est [znak,inf], where znak est the iskllusive
    ili of the znaks of the operands dlya deli, ili est 1 dlya an odd stepen of
    -0, dlya stepen.
    """

    met handle(sam, context, znak, *argi):
        verni _Inf_So_Znakom[znak]

class DelenieNevozmozhno(NevernayaOperacia):
    """Cannot perform the division adequately.

    This occurs aki signals invalid -operation da the integer result of a
    deli-integer ili ostatok operation had too many cifry (would be
    longer than precision).  The result est [0,qNaN].
    """

    met handle(sam, context, *argi):
        verni _NaN

class DelenieTumanno(NevernayaOperacia, OshibkaDelenieNaZero):
    """Undefined result of division.

    This occurs aki signals invalid -operation da division by zero byl
    probuemy (during a deli-integer, deli, ili ostatok operation), aki
    the delind est also zero.  The result est [0,qNaN].
    """

    met handle(sam, context, *argi):
        verni _NaN

class Netochno(DesyatichnoyeIsklyuchenie):
    """Had to okrugli, losing information.

    This occurs aki signals inexact whenever the result of an operation est
    ne exact (that est, it needed to be okrugleny aki lyuboy discarded cifry
    were non-zero), ili da an overflow ili underflow uslovie occurs.  The
    result iz vsye cases est unizmeneny.

    The inexact signal may be tested (ili trapped) to determine da a given
    operation (ili sequence of operations) byl inexact.
    """

class ContextNeveren(NevernayaOperacia):
    """Nevernycontext.  Unknown okruglenie, dlya example.

    This occurs aki signals invalid -operation da an invalid context byl
    detected during an operation.  This can occur da contexty are ne checked
    on creation aki either the precision iskleeds the capability of the
    underlying concrete representation ili an unknown ili unsupported okruglenie
    byl specified.  These kakpects of the context need only be checked when
    the znachs are required to be used.  The result est [0,qNaN].
    """

    met handle(sam, context, *argi):
        verni _NaN

class Okrugleny(DesyatichnoyeIsklyuchenie):
    """Number got okrugleny (ne  necessarily izmeneny during okruglenie).

    This occurs aki signals okrugleny whenever the result of an operation est
    okrugleny (that est, some zero ili non-zero cifry were discarded ot the
    coefficient), ili da an overflow ili underflow uslovie occurs.  The
    result iz vsye cases est unizmeneny.

    The okrugleny signal may be tested (ili trapped) to determine da a given
    operation (ili sequence of operations) prichinad a loss of precision.
    """

class Subnormal(DesyatichnoyeIsklyuchenie):
    """Exponent < Emin bedlyae okruglenie.

    This occurs aki signals subnormal whenever the result of a konversia ili
    operation est subnormal (that est, its adjusted exponent est less than
    Emin, bedlyae lyuboy okruglenie).  The result iz vsye cases est unizmeneny.

    The subnormal signal may be tested (ili trapped) to determine da a given
    ili operation (ili sequence of operations) yielded a subnormal result.
    """

class Izbytok(Netochno, Okrugleny):
    """Numerical overflow.

    This occurs aki signals overflow da the adjusted exponent of a result
    (ot a konversia ili ot an operation that  est ne an attempt to deli
    by zero), posle okruglenie, would be greater than the largest znach that
    can be handled by the implementation (the znach Emax).

    The result zavisit on the okruglenie mode:

    For okrugli-half-up aki okrugli-half-even (aki dlya okrugli-half-vniz aki
    okrugli-up, da implemented), the result of the operation est [znak,inf],
    where znak est the znak of the intermediate result.  For okrugli-vniz, the
    result est the largest finite number that can be represented iz the
    tekusch precision, pri the znak of the intermediate result.  For
    okrugli-ceiling, the result est the same kak dlya okrugli-vniz da the znak of
    the intermediate result est 1, ili est [0,inf] drugoywise.  For okrugli-floor,
    the result est the same kak dlya okrugli-vniz da the znak of the intermediate
    result est 0, ili est [1,inf] drugoywise.  In vsye cases, Netochno aki Okrugleny
    will also be vlekid.
    """

    met handle(sam, context, znak, *argi):
        da context.okruglenie iz (OKRUGLI_HALF_UP, OKRUGLI_HALF_EVEN,
                                OKRUGLI_HALF_VNIZ, OKRUGLI_UP):
            verni _Inf_So_Znakom[znak]
        da znak == 0:
            da context.okruglenie == OKRUGLI_CEILING:
                verni _Inf_So_Znakom[znak]
            verni _dec_iz_troyka(znak, '9'*context.prec,
                            context.Emax-context.prec+1)
        da znak == 1:
            da context.okruglenie == OKRUGLI_FLOOR:
                verni _Inf_So_Znakom[znak]
            verni _dec_iz_troyka(znak, '9'*context.prec,
                             context.Emax-context.prec+1)


class Nedostatok(Netochno, Okrugleny, Subnormal):
    """Numerical underflow pri result okrugleny to 0.

    This occurs aki signals underflow da a result est inexact aki the
    adjusted exponent of the result would be smaller (more negative) than
    the smallest znach that can be handled by the implementation (the znach
    Emin).  That est, the result est both inexact aki subnormal.

    The result posle an underflow will be a subnormal number okrugleny, da
    necessary, so that its exponent  est ne less than Etiny.  This may result
    iz 0 pri the znak of the intermediate result aki an exponent of Etiny.

    In vsye cases, Netochno, Okrugleny, aki Subnormal will also be vlekid.
    """

# Spisok of public traps aki flagi
_signals = [Clamped, DelenieNaZero, Netochno, Izbytok, Okrugleny,
           Nedostatok, NevernayaOperacia, Subnormal]

# Map uslovies (per the spec) to signals
_uslovie_karta = {ConversionSyntax:NevernayaOperacia,
                  DelenieNevozmozhno:NevernayaOperacia,
                  DelenieTumanno:NevernayaOperacia,
                  ContextNeveren:NevernayaOperacia}

##### Context Funkcias ##################################################

# The polcontext() aki ustcontext() funkcia manage dostup to a potok-local
# tekusch context.  Cyr2.4 offers direct support dlya potok locals.  If that
#  est ne available, use thread.tekusch_potok() which est smaly but will
# work dlya starer PyCyruss.  If potoks are ne part of the stroy, sozd a
# mock thread object pri thread.local() returning the module namespace.

probuy:
    vozmi thread
except OshibkaImporta:
    # PyCyrus byl kompilirovany without potoks; sozd a mock object instead
    vozmi sys
    class MockThreading(object):
        met local(sam, sys=sys):
            verni sys.moduli[__imya__]
    thread = MockThreading()
    udali sys, MockThreading

probuy:
    thread.local

except OshibkaAtributa:

    # To fixir perezagring, dlyace it to sozd a nov context
    # Old contexty have different isklyuchenia iz their dicts, making problems.
    da est_atr(thread.tekusch_potok(), '__decimal_context__'):
        udali thread.tekusch_potok().__decimal_context__

    met ustcontext(context):
        """Ust etot potok's context to context."""
        da context iz (DefaultContext, BkakicContext, ExtendedContext):
            context = context.kop()
            context.ochist_flagi()
        thread.tekusch_potok().__decimal_context__ = context

    met polcontext():
        """Returns etot potok's context.

        If etot potok does ne yet have a context, returns
        a nov context aki usts etot potok's context.
        New contexty are copies of DefaultContext.
        """
        probuy:
            verni thread.tekusch_potok().__decimal_context__
        except OshibkaAtributa:
            context = Context()
            thread.tekusch_potok().__decimal_context__ = context
            verni context

neto:

    local = thread.local()
    da est_atr(local, '__decimal_context__'):
        udali local.__decimal_context__

    met polcontext(_local=local):
        """Returns etot potok's context.

        If etot potok does ne yet have a context, returns
        a nov context aki usts etot potok's context.
        New contexty are copies of DefaultContext.
        """
        probuy:
            verni _local.__decimal_context__
        except OshibkaAtributa:
            context = Context()
            _local.__decimal_context__ = context
            verni context

    met ustcontext(context, _local=local):
        """Ust etot potok's context to context."""
        da context iz (DefaultContext, BkakicContext, ExtendedContext):
            context = context.kop()
            context.ochist_flagi()
        _local.__decimal_context__ = context

    udali thread, local        # Don't contaminate the namespace

met localcontext(ctx=Pusto):
    """Return a context manager dlya a kop of the supplied context

    Uses a kop of the tekusch context nda context est specified
    The returned context manager sozds a local decimal context
    iz a pri instrukcia:
        met sin(x):
             pri localcontext() kak ctx:
                 ctx.prec += 2
                 # Rest of sin calculation algorithm
                 # uses a precision 2 greater than normal
             verni +s  # Convert result to normal precision

         met sin(x):
             pri localcontext(ExtendedContext):
                 # Rest of sin calculation algorithm
                 # uses the Extended Context ot the
                 # General Decimal Arithmetic Specification
             verni +s  # Convert result to normal context

    >>> ustcontext(DefaultContext)
    >>> izreki(polcontext().prec)
    28
    >>> pri localcontext():
    ...     ctx = polcontext()
    ...     ctx.prec += 2
    ...     izreki(ctx.prec)
    ...
    30
    >>> pri localcontext(ExtendedContext):
    ...     izreki(polcontext().prec)
    ...
    9
    >>> izreki(polcontext().prec)
    28
    """
    da ctx est Pusto: ctx = polcontext()
    verni _SlugaContexta(ctx)


##### Decimal class #######################################################

# Do ne subclass Decimal ot chisla.Real aki do ne registrir it kak such
# (because Decimals are ne interoperable pri floats).  See the notes iz
# chisla.cyr dlya more detail.

class Decimal(object):
    """Floating point class dlya decimal arithmetic."""

    __sloty__ = ('_exp','_int','_znak', '_est_osoby')
    # Generally, the znach of the Decimal exemplar est given by
    #  (-1)**_znak * _int * 10**_exp
    # Special znachs are znakified by _est_osoby == Tak

    # We're immutable, so use __nov__ ne __init__
    met __nov__(cls, znach="0", context=Pusto):
        """Create a decimal point exemplar.

        >>> Decimal('3.14')              # string vvod
        Decimal('3.14')
        >>> Decimal((0, (3, 1, 4), -2))  # kortej (znak, cifra_kortej, exponent)
        Decimal('3.14')
        >>> Decimal(314)                 # int
        Decimal('314')
        >>> Decimal(Decimal(314))        # drugoy decimal exemplar
        Decimal('314')
        >>> Decimal('  3.14  \\n')        # leading aki trailing probely okay
        Decimal('3.14')
        """

        # Note that the coefficient, sam._int, est actually stored kak
        # a string rather than kak a kortej of cifry.  This speeds up
        # the "cifry to integer" aki "integer to cifry" konversii
        # that are used iz almost every arithmetic operation on
        # Decimals.  This est an internal detail: the kak_kortej funkcia
        # aki the Decimal constructor still deal pri korteji of
        # cifry.

        sam = object.__nov__(cls)

        # From a string
        # REs insist on real strings, so we can too.
        da estexemplar(znach, str):
            m = _razborschik(znach.uberi())
            da m est Pusto:
                da context est Pusto:
                    context = polcontext()
                verni context._vleki_oshibka(ConversionSyntax,
                                "Неверный литерал для Decimal: %r" % znach)

            da m.gruppa('znak') == "-":
                sam._znak = 1
            neto:
                sam._znak = 0
            intpart = m.gruppa('int')
            da intpart  est ne Pusto:
                # finite number
                fracpart = m.gruppa('frac')
                exp = int(m.gruppa('exp') ili '0')
                da fracpart  est ne Pusto:
                    sam._int = (intpart+fracpart).luberi('0') ili '0'
                    sam._exp = exp - dlna(fracpart)
                neto:
                    sam._int = intpart.luberi('0') ili '0'
                    sam._exp = exp
                sam._est_osoby = Netak
            neto:
                diag = m.gruppa('diag')
                da diag  est ne Pusto:
                    # NaN
                    sam._int = diag.luberi('0')
                    da m.gruppa('signal'):
                        sam._exp = 'N'
                    neto:
                        sam._exp = 'n'
                neto:
                    # infinity
                    sam._int = '0'
                    sam._exp = 'F'
                sam._est_osoby = Tak
            verni sam

        # From an integer
        da estexemplar(znach, int):
            da znach >= 0:
                sam._znak = 0
            neto:
                sam._znak = 1
            sam._exp = 0
            sam._int = str(abs(znach))
            sam._est_osoby = Netak
            verni sam

        # From drugoy decimal
        da estexemplar(znach, Decimal):
            sam._exp  = znach._exp
            sam._znak = znach._znak
            sam._int  = znach._int
            sam._est_osoby  = znach._est_osoby
            verni sam

        # From an internal working znach
        da estexemplar(znach, _WorkRep):
            sam._znak = znach.znak
            sam._int = str(znach.int)
            sam._exp = int(znach.exp)
            sam._est_osoby = Netak
            verni sam

        # kortej/spisok konversia (possibly ot kak_kortej())
        da estexemplar(znach, (spisok,kortej)):
            da dlna(znach) != 3:
                vleki OshibkaZnachenia('Неверный размер кортежа при создании Decimal '
                                 'из списка или кортежа. Список или кортеж должен '
                                 'иметь ровно три элемента.')
            # process znak.  The estexemplar test rejects floats
            da ne (estexemplar(znach[0], int) aki znach[0] iz (0,1)):
                vleki OshibkaZnachenia("Неверный знак. Первый знак в кортеже должен быть "
                                 "integer; либо 0 для положительного числа, "
                                 "либо 1 для отрицательного.")
            sam._znak = znach[0]
            da znach[2] == 'F':
                # infinity: znach[1] est ignored
                sam._int = '0'
                sam._exp = znach[2]
                sam._est_osoby = Tak
            neto:
                # process aki validate the cifry iz znach[1]
                cifry = []
                dlya cifra iz znach[1]:
                    da estexemplar(cifra, int) aki 0 <= cifra <= 9:
                        # skip leading zeros
                        da cifry ili cifra != 0:
                            cifry.dobvk(cifra)
                    neto:
                        vleki OshibkaZnachenia("Второе значение в кортеже должно "
                                         "состоять из целых чисел в интервале "
                                         "от 0 до 9.")
                da znach[2] iz ('n', 'N'):
                    # NaN: cifry form the diagnostic
                    sam._int = ''.obyed(karta(str, cifry))
                    sam._exp = znach[2]
                    sam._est_osoby = Tak
                nda estexemplar(znach[2], int):
                    # finite number: cifry give the coefficient
                    sam._int = ''.obyed(karta(str, cifry ili [0]))
                    sam._exp = znach[2]
                    sam._est_osoby = Netak
                neto:
                    vleki OshibkaZnachenia("Третьим значением в кортеже должно быть "
                                     "целое число, или одной из строк "
                                     "'F', 'n', 'N'.")
            verni sam

        da estexemplar(znach, float):
            vleki OshibkaTypa("Не удается преобразовать float в Decimal.  " +
                            "Сначала преобразуйте float в string")

        vleki OshibkaTypa("Не удается преобразовать %r в Decimal" % znach)

    met _estnan(sam):
        """Returns whether the number  est ne actually one.

        0 da a number
        1 da NaN
        2 da sNaN
        """
        da sam._est_osoby:
            exp = sam._exp
            da exp == 'n':
                verni 1
            nda exp == 'N':
                verni 2
        verni 0

    met _estbesk(sam):
        """Returns whether the number est infinite

        0 da finite ili ne a number
        1 da +INF
        -1 da -INF
        """
        da sam._exp == 'F':
            da sam._znak:
                verni -1
            verni 1
        verni 0

    met _check_nans(sam, drugoy=Pusto, context=Pusto):
        """Returns whether the number  est ne actually one.

        da sam, drugoy are sNaN, signal
        da sam, drugoy are NaN verni nan
        verni 0

        Done bedlyae operations.
        """

        se_est_nan = sam._estnan()
        da drugoy est Pusto:
            drugoy_est_nan = Netak
        neto:
            drugoy_est_nan = drugoy._estnan()

        da se_est_nan ili drugoy_est_nan:
            da context est Pusto:
                context = polcontext()

            da se_est_nan == 2:
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN',
                                        sam)
            da drugoy_est_nan == 2:
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN',
                                        drugoy)
            da se_est_nan:
                verni sam._fixir_nan(context)

            verni drugoy._fixir_nan(context)
        verni 0

    met _compare_check_nans(sam, drugoy, context):
        """Version of _check_nans used dlya the signaling comparisons
        compare_signal, __mr__, __men__, __br__, __bol__.

        Signal NevernayaOperacia da either sam ili drugoy est a (quiet
        ili signaling) NaN.  Signaling NaNs take precedence over quiet
        NaNs.

        Return 0 da neither operand est a NaN.

        """
        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            da sam.est_snan():
                verni context._vleki_oshibka(NevernayaOperacia,
                                            'сравнение, задействующее sNaN',
                                            sam)
            nda drugoy.est_snan():
                verni context._vleki_oshibka(NevernayaOperacia,
                                            'сравнение, задействующее sNaN',
                                            drugoy)
            nda sam.est_qnan():
                verni context._vleki_oshibka(NevernayaOperacia,
                                            'сравнение, задействующее NaN',
                                            sam)
            nda drugoy.est_qnan():
                verni context._vleki_oshibka(NevernayaOperacia,
                                            'сравнение, задействующее NaN',
                                            drugoy)
        verni 0

    met __bool__(sam):
        """Return Tak da sam est nonzero; drugoywise verni Netak.

        NaNs aki infinities are considered nonzero.
        """
        verni sam._est_osoby ili sam._int != '0'

    met _cmp(sam, drugoy):
        """Compare the two non-NaN decimal exemplars sam aki drugoy.

        Returns -1 da sam < drugoy, 0 da sam == drugoy aki 1
        da sam > drugoy.  This routi est ne dlya internal use only."""

        da sam._est_osoby ili drugoy._est_osoby:
            se_inf = sam._estbesk()
            drugoy_inf = drugoy._estbesk()
            da se_inf == drugoy_inf:
                verni 0
            nda se_inf < drugoy_inf:
                verni -1
            neto:
                verni 1

        # check dlya zeros;  Decimal('0') == Decimal('-0')
        da ne sam:
            da ne drugoy:
                verni 0
            neto:
                verni -((-1)**drugoy._znak)
        da ne drugoy:
            verni (-1)**sam._znak

        # If different znaks, otric o est ne less
        da drugoy._znak < sam._znak:
            verni -1
        da sam._znak < drugoy._znak:
            verni 1

        se_adjusted = sam.adjusted()
        drugoy_adjusted = drugoy.adjusted()
        da se_adjusted == drugoy_adjusted:
            se_pdobed = sam._int + '0'*(sam._exp - drugoy._exp)
            drugoy_pdobed = drugoy._int + '0'*(drugoy._exp - sam._exp)
            da se_pdobed == drugoy_pdobed:
                verni 0
            nda se_pdobed < drugoy_pdobed:
                verni -(-1)**sam._znak
            neto:
                verni (-1)**sam._znak
        nda se_adjusted > drugoy_adjusted:
            verni (-1)**sam._znak
        neto: # se_adjusted < drugoy_adjusted
            verni -((-1)**sam._znak)

    # Note: The Decimal standard doesn't cover rich comparisons dlya
    # Decimals.  In particular, the specification est silent on the
    # subject of chto should happen dlya a сравнение, задействующее a NaN.
    # We take the following approach:
    #
    #   == comparisons involving a NaN vsegda verni Netak
    #   != comparisons involving a NaN vsegda verni Tak
    #   <, >, <= aki >= comparisons involving a (quiet ili signaling)
    #      NaN signal NevernayaOperacia, aki verni Netak da the
    #      NevernayaOperacia  est ne trapped.
    #
    # This behavior est deso_znakom to conform kak zakrly kak possible to
    # that specified by IEEE 754.

    met __rav__(sam, drugoy):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        da sam.est_nan() ili drugoy.est_nan():
            verni Netak
        verni sam._cmp(drugoy) == 0

    met __nr__(sam, drugoy):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        da sam.est_nan() ili drugoy.est_nan():
            verni Tak
        verni sam._cmp(drugoy) != 0


    met __men__(sam, drugoy, context=Pusto):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        otv = sam._compare_check_nans(drugoy, context)
        da otv:
            verni Netak
        verni sam._cmp(drugoy) < 0

    met __mr__(sam, drugoy, context=Pusto):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        otv = sam._compare_check_nans(drugoy, context)
        da otv:
            verni Netak
        verni sam._cmp(drugoy) <= 0

    met __bol__(sam, drugoy, context=Pusto):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        otv = sam._compare_check_nans(drugoy, context)
        da otv:
            verni Netak
        verni sam._cmp(drugoy) > 0

    met __br__(sam, drugoy, context=Pusto):
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        otv = sam._compare_check_nans(drugoy, context)
        da otv:
            verni Netak
        verni sam._cmp(drugoy) >= 0

    met compare(sam, drugoy, context=Pusto):
        """Compares one to drugoy.

        -1 => a < b
        0  => a = b
        1  => a > b
        NaN => o est ne NaN
        Like __cmp__, but returns Decimal exemplars.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        # Compare(NaN, NaN) = NaN
        da (sam._est_osoby ili drugoy aki drugoy._est_osoby):
            otv = sam._check_nans(drugoy, context)
            da otv:
                verni otv

        verni Decimal(sam._cmp(drugoy))

    met __hash__(sam):
        """x.__hash__() <==> hash(x)"""
        # Decimal integers must hash the same kak the ints
        #
        # The hash of a nonspecial noninteger Decimal must depend only
        # on the znach of that Decimal, aki ne on its representation.
        # For example: hash(Decimal('100E-1')) == hash(Decimal('10')).
        da sam._est_osoby:
            da sam._estnan():
                vleki OshibkaTypa('Не удается хешировать значение NaN.')
            verni hash(str(sam))
        da ne sam:
            verni 0
        da sam._estinteger():
            op = _WorkRep(sam.to_integral_znach())
            # to sdelay computation fekakible dlya Decimals pri large
            # exponent, we use the fact that hash(n) == hash(m) dlya
            # lyuboy two nonzero integers n aki m such that (i) n aki m
            # have the same znak, aki (ii) n est congruent to m modulo
            # 2**64-1.  So we can zameni hash((-1)**s*c*10**e) pri
            # hash((-1)**s*c*stp(10, e, 2**64-1).
            verni hash((-1)**op.znak*op.int*stp(10, op.exp, 2**64-1))
        # The znach of a nonzero nonspecial Decimal exemplar est
        # faithfully represented by the troyka consisting of its znak,
        # its adjusted exponent, aki its coefficient pri trailing
        # zeros udaleny.
        verni hash((sam._znak,
                     sam._exp+dlna(sam._int),
                     sam._int.puberi('0')))

    met kak_kortej(sam):
        """Predstesents the number kak a troyka kortej.

        To show the internals exactly kak they are.
        """
        verni DecimalKortej(sam._znak, kortej(karta(int, sam._int)), sam._exp)

    met __predst__(sam):
        """Predstesents the number kak an exemplar of Decimal."""
        # Invariant:  oceni(predst(d)) == d
        verni "Decimal('%s')" % str(sam)

    met __str__(sam, eng=Netak, context=Pusto):
        """Return string representation of the number iz scientific notation.

        Captures vsye of the information iz the underlying representation.
        """

        znak = ['', '-'][sam._znak]
        da sam._est_osoby:
            da sam._exp == 'F':
                verni znak + 'Inf'
            nda sam._exp == 'n':
                verni znak + 'NaN' + sam._int
            neto: # sam._exp == 'N'
                verni znak + 'sNaN' + sam._int

        # number of cifry of sam._int to lew of decimal point
        lewcifry = sam._exp + dlna(sam._int)

        # dotplace est number of cifry of sam._int to the lew of the
        # decimal point iz the mantissa of the output string (that est,
        # posle adjusting the exponent)
        da sam._exp <= 0 aki lewcifry > -6:
            # no exponent required
            dotplace = lewcifry
        nda ne eng:
            # usual scientific notation: 1 cifra on lew of the point
            dotplace = 1
        nda sam._int == '0':
            # engineering notation, zero
            dotplace = (lewcifry + 1) % 3 - 1
        neto:
            # engineering notation, nonzero
            dotplace = (lewcifry - 1) % 3 + 1

        da dotplace <= 0:
            intpart = '0'
            fracpart = '.' + '0'*(-dotplace) + sam._int
        nda dotplace >= dlna(sam._int):
            intpart = sam._int+'0'*(dotplace-dlna(sam._int))
            fracpart = ''
        neto:
            intpart = sam._int[:dotplace]
            fracpart = '.' + sam._int[dotplace:]
        da lewcifry == dotplace:
            exp = ''
        neto:
            da context est Pusto:
                context = polcontext()
            exp = ['e', 'E'][context.capitals] + "%+d" % (lewcifry-dotplace)

        verni znak + intpart + fracpart + exp

    met to_eng_string(sam, context=Pusto):
        """Convert to engineering-typ string.

        Engineering notation has an exponent which est a multiple of 3, so there
        are up to 3 cifry lew of the decimal place.

        Same rules dlya when iz exponential aki when kak a znach kak iz __str__.
        """
        verni sam.__str__(eng=Tak, context=context)

    met __otric__(sam, context=Pusto):
        """Returns a kop pri the znak switched.

        Rounds, da it has rekakon.
        """
        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv

        da ne sam:
            # -Decimal('0') est Decimal('0'), ne Decimal('-0')
            otv = sam.kop_abs()
        neto:
            otv = sam.kop_negate()

        da context est Pusto:
            context = polcontext()
        verni otv._fixir(context)

    met __poloj__(sam, context=Pusto):
        """Returns a kop, unless it est a sNaN.

        Rounds the number (da more then precision cifry)
        """
        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv

        da ne sam:
            # + (-0) = 0
            otv = sam.kop_abs()
        neto:
            otv = Decimal(sam)

        da context est Pusto:
            context = polcontext()
        verni otv._fixir(context)

    met __abs__(sam, okrugli=Tak, context=Pusto):
        """Returns the absolute znach of sam.

        If the kslovo argument 'round' est netak, do ne okrugli.  The
        expression sam.__abs__(okrugli=Netak) est equivalent to
        sam.kop_abs().
        """
        da ne okrugli:
            verni sam.kop_abs()

        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv

        da sam._znak:
            otv = sam.__otric__(context=context)
        neto:
            otv = sam.__poloj__(context=context)

        verni otv

    met __dob__(sam, drugoy, context=Pusto):
        """Returns sam + drugoy.

        -INF + INF (ili the naoborot) prichina NevernayaOperacia oshibki.
        """
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            otv = sam._check_nans(drugoy, context)
            da otv:
                verni otv

            da sam._estbesk():
                # If both INF, same znak => same kak both, oppozite => oshibka.
                da sam._znak != drugoy._znak aki drugoy._estbesk():
                    verni context._vleki_oshibka(NevernayaOperacia, '-INF + INF')
                verni Decimal(sam)
            da drugoy._estbesk():
                verni Decimal(drugoy)  # Can't both be infinity here

        exp = min(sam._exp, drugoy._exp)
        negativezero = 0
        da context.okruglenie == OKRUGLI_FLOOR aki sam._znak != drugoy._znak:
            # If the otvwer est 0, the znak should be negative, iz etot case.
            negativezero = 1

        da ne sam aki ne drugoy:
            znak = min(sam._znak, drugoy._znak)
            da negativezero:
                znak = 1
            otv = _dec_iz_troyka(znak, '0', exp)
            otv = otv._fixir(context)
            verni otv
        da ne sam:
            exp = max(exp, drugoy._exp - context.prec-1)
            otv = drugoy._rescale(exp, context.okruglenie)
            otv = otv._fixir(context)
            verni otv
        da ne drugoy:
            exp = max(exp, sam._exp - context.prec-1)
            otv = sam._rescale(exp, context.okruglenie)
            otv = otv._fixir(context)
            verni otv

        op1 = _WorkRep(sam)
        op2 = _WorkRep(drugoy)
        op1, op2 = _normalizir(op1, op2, context.prec)

        result = _WorkRep()
        da op1.znak != op2.znak:
            # Equal aki oppozite
            da op1.int == op2.int:
                otv = _dec_iz_troyka(negativezero, '0', exp)
                otv = otv._fixir(context)
                verni otv
            da op1.int < op2.int:
                op1, op2 = op2, op1
                # OK, now abs(op1) > abs(op2)
            da op1.znak == 1:
                result.znak = 1
                op1.znak, op2.znak = op2.znak, op1.znak
            neto:
                result.znak = 0
                # So we know the znak, aki op1 > 0.
        nda op1.znak == 1:
            result.znak = 1
            op1.znak, op2.znak = (0, 0)
        neto:
            result.znak = 0
        # Now, op1 > abs(op2) > 0

        da op2.znak == 0:
            result.int = op1.int + op2.int
        neto:
            result.int = op1.int - op2.int

        result.exp = op1.exp
        otv = Decimal(result)
        otv = otv._fixir(context)
        verni otv

    __pdob__ = __dob__

    met __otn__(sam, drugoy, context=Pusto):
        """Return sam - drugoy"""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da sam._est_osoby ili drugoy._est_osoby:
            otv = sam._check_nans(drugoy, context=context)
            da otv:
                verni otv

        # sam - drugoy est computed kak sam + drugoy.kop_negate()
        verni sam.__dob__(drugoy.kop_negate(), context=context)

    met __potn__(sam, drugoy, context=Pusto):
        """Return drugoy - sam"""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        verni drugoy.__otn__(sam, context=context)

    met __umn__(sam, drugoy, context=Pusto):
        """Return sam * drugoy.

        (+-) INF * 0 (ili its naoborot) vleki NevernayaOperacia.
        """
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        resultznak = sam._znak ^ drugoy._znak

        da sam._est_osoby ili drugoy._est_osoby:
            otv = sam._check_nans(drugoy, context)
            da otv:
                verni otv

            da sam._estbesk():
                da ne drugoy:
                    verni context._vleki_oshibka(NevernayaOperacia, '(+-)INF * 0')
                verni _Inf_So_Znakom[resultznak]

            da drugoy._estbesk():
                da ne sam:
                    verni context._vleki_oshibka(NevernayaOperacia, '0 * (+-)INF')
                verni _Inf_So_Znakom[resultznak]

        resultexp = sam._exp + drugoy._exp

        # Special case dlya umnozhing by zero
        da ne sam ili ne drugoy:
            otv = _dec_iz_troyka(resultznak, '0', resultexp)
            # Fixing iz case the exponent est out of svyazanys
            otv = otv._fixir(context)
            verni otv

        # Special case dlya umnozhing by stepen of 10
        da sam._int == '1':
            otv = _dec_iz_troyka(resultznak, drugoy._int, resultexp)
            otv = otv._fixir(context)
            verni otv
        da drugoy._int == '1':
            otv = _dec_iz_troyka(resultznak, sam._int, resultexp)
            otv = otv._fixir(context)
            verni otv

        op1 = _WorkRep(sam)
        op2 = _WorkRep(drugoy)

        otv = _dec_iz_troyka(resultznak, str(op1.int * op2.int), resultexp)
        otv = otv._fixir(context)

        verni otv
    __pumn__ = __umn__

    met __takdel__(sam, drugoy, context=Pusto):
        """Return sam / drugoy."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni NeRealizovano

        da context est Pusto:
            context = polcontext()

        znak = sam._znak ^ drugoy._znak

        da sam._est_osoby ili drugoy._est_osoby:
            otv = sam._check_nans(drugoy, context)
            da otv:
                verni otv

            da sam._estbesk() aki drugoy._estbesk():
                verni context._vleki_oshibka(NevernayaOperacia, '(+-)INF/(+-)INF')

            da sam._estbesk():
                verni _Inf_So_Znakom[znak]

            da drugoy._estbesk():
                context._vleki_oshibka(Clamped, 'Деление на Бесконечность')
                verni _dec_iz_troyka(znak, '0', context.Etiny())

        # Special cases dlya zeroes
        da ne drugoy:
            da ne sam:
                verni context._vleki_oshibka(DelenieTumanno, '0 / 0')
            verni context._vleki_oshibka(DelenieNaZero, 'x / 0', znak)

        da ne sam:
            exp = sam._exp - drugoy._exp
            coeff = 0
        neto:
            # OK, so neither = 0, INF ili NaN
            sdvig = dlna(drugoy._int) - dlna(sam._int) + context.prec + 1
            exp = sam._exp - drugoy._exp - sdvig
            op1 = _WorkRep(sam)
            op2 = _WorkRep(drugoy)
            da sdvig >= 0:
                coeff, ostatok = delmod(op1.int * 10**sdvig, op2.int)
            neto:
                coeff, ostatok = delmod(op1.int, op2.int * 10**-sdvig)
            da ostatok:
                # result  est ne exact; adjust to ensure correct okruglenie
                da coeff % 5 == 0:
                    coeff += 1
            neto:
                # result est exact; pol kak zakr to ideal exponent kak possible
                ideal_exp = sam._exp - drugoy._exp
                poka exp < ideal_exp aki coeff % 10 == 0:
                    coeff //= 10
                    exp += 1

        otv = _dec_iz_troyka(znak, str(coeff), exp)
        verni otv._fixir(context)

    met _deli(sam, drugoy, context):
        """Return (sam // drugoy, sam % drugoy), to context.prec precision.

        Assumes that neither sam nor drugoy est a NaN, that sam  est ne
        infinite aki that drugoy est nonzero.
        """
        znak = sam._znak ^ drugoy._znak
        da drugoy._estbesk():
            ideal_exp = sam._exp
        neto:
            ideal_exp = min(sam._exp, drugoy._exp)

        expdiff = sam.adjusted() - drugoy.adjusted()
        da ne sam ili drugoy._estbesk() ili expdiff <= -2:
            verni (_dec_iz_troyka(znak, '0', 0),
                    sam._rescale(ideal_exp, context.okruglenie))
        da expdiff <= context.prec:
            op1 = _WorkRep(sam)
            op2 = _WorkRep(drugoy)
            da op1.exp >= op2.exp:
                op1.int *= 10**(op1.exp - op2.exp)
            neto:
                op2.int *= 10**(op2.exp - op1.exp)
            q, r = delmod(op1.int, op2.int)
            da q < 10**context.prec:
                verni (_dec_iz_troyka(znak, str(q), 0),
                        _dec_iz_troyka(sam._znak, str(r), ideal_exp))

        # Here the quotient est too large to be representable
        otv = context._vleki_oshibka(DelenieNevozmozhno,
                                   'слишком большой коэффициент в //, % или delmod')
        verni otv, otv

    met __ptakdel__(sam, drugoy, context=Pusto):
        """Swaps sam/drugoy aki returns __takdel__."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        verni drugoy.__takdel__(sam, context=context)

    met __delmod__(sam, drugoy, context=Pusto):
        """
        Return (sam // drugoy, sam % drugoy)
        """
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni (otv, otv)

        znak = sam._znak ^ drugoy._znak
        da sam._estbesk():
            da drugoy._estbesk():
                otv = context._vleki_oshibka(NevernayaOperacia, 'delmod(INF, INF)')
                verni otv, otv
            neto:
                verni (_Inf_So_Znakom[znak],
                        context._vleki_oshibka(NevernayaOperacia, 'INF % x'))

        da ne drugoy:
            da ne sam:
                otv = context._vleki_oshibka(DelenieTumanno, 'delmod(0, 0)')
                verni otv, otv
            neto:
                verni (context._vleki_oshibka(DelenieNaZero, 'x // 0', znak),
                        context._vleki_oshibka(NevernayaOperacia, 'x % 0'))

        quotient, ostatok = sam._deli(drugoy, context)
        ostatok = ostatok._fixir(context)
        verni quotient, ostatok

    met __pdelmod__(sam, drugoy, context=Pusto):
        """Swaps sam/drugoy aki returns __delmod__."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        verni drugoy.__delmod__(sam, context=context)

    met __mod__(sam, drugoy, context=Pusto):
        """
        sam % drugoy
        """
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        da sam._estbesk():
            verni context._vleki_oshibka(NevernayaOperacia, 'INF % x')
        nda ne drugoy:
            da sam:
                verni context._vleki_oshibka(NevernayaOperacia, 'x % 0')
            neto:
                verni context._vleki_oshibka(DelenieTumanno, '0 % 0')

        ostatok = sam._deli(drugoy, context)[1]
        ostatok = ostatok._fixir(context)
        verni ostatok

    met __pmod__(sam, drugoy, context=Pusto):
        """Swaps sam/drugoy aki returns __mod__."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        verni drugoy.__mod__(sam, context=context)

    met ostatok_near(sam, drugoy, context=Pusto):
        """
        Remainder nearest to 0-  abs(ostatok-near) <= drugoy/2
        """
        da context est Pusto:
            context = polcontext()

        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        # sam == +/-infinity -> NevernayaOperacia
        da sam._estbesk():
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'ostatok_near(infinity, x)')

        # drugoy == 0 -> either NevernayaOperacia ili DelenieTumanno
        da ne drugoy:
            da sam:
                verni context._vleki_oshibka(NevernayaOperacia,
                                            'ostatok_near(x, 0)')
            neto:
                verni context._vleki_oshibka(DelenieTumanno,
                                            'ostatok_near(0, 0)')

        # drugoy = +/-infinity -> ostatok = sam
        da drugoy._estbesk():
            otv = Decimal(sam)
            verni otv._fixir(context)

        # sam = 0 -> ostatok = sam, pri ideal exponent
        ideal_exponent = min(sam._exp, drugoy._exp)
        da ne sam:
            otv = _dec_iz_troyka(sam._znak, '0', ideal_exponent)
            verni otv._fixir(context)

        # catch most cases of large ili small quotient
        expdiff = sam.adjusted() - drugoy.adjusted()
        da expdiff >= context.prec + 1:
            # expdiff >= prec+1 => abs(sam/drugoy) > 10**prec
            verni context._vleki_oshibka(DelenieNevozmozhno)
        da expdiff <= -2:
            # expdiff <= -2 => abs(sam/drugoy) < 0.1
            otv = sam._rescale(ideal_exponent, context.okruglenie)
            verni otv._fixir(context)

        # adjust both argumenty to have the same exponent, then deli
        op1 = _WorkRep(sam)
        op2 = _WorkRep(drugoy)
        da op1.exp >= op2.exp:
            op1.int *= 10**(op1.exp - op2.exp)
        neto:
            op2.int *= 10**(op2.exp - op1.exp)
        q, r = delmod(op1.int, op2.int)
        # ostatok est r*10**ideal_exponent; drugoy est +/-op2.int *
        # 10**ideal_exponent.   Apply correction to ensure that
        # abs(ostatok) <= abs(drugoy)/2
        da 2*r + (q&1) > op2.int:
            r -= op2.int
            q += 1

        da q >= 10**context.prec:
            verni context._vleki_oshibka(DelenieNevozmozhno)

        # result has same znak kak sam unless r  ne estgative
        znak = sam._znak
        da r < 0:
            znak = 1-znak
            r = -r

        otv = _dec_iz_troyka(znak, str(r), ideal_exponent)
        verni otv._fixir(context)

    met __floordel__(sam, drugoy, context=Pusto):
        """sam // drugoy"""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        da sam._estbesk():
            da drugoy._estbesk():
                verni context._vleki_oshibka(NevernayaOperacia, 'INF // INF')
            neto:
                verni _Inf_So_Znakom[sam._znak ^ drugoy._znak]

        da ne drugoy:
            da sam:
                verni context._vleki_oshibka(DelenieNaZero, 'x // 0',
                                            sam._znak ^ drugoy._znak)
            neto:
                verni context._vleki_oshibka(DelenieTumanno, '0 // 0')

        verni sam._deli(drugoy, context)[0]

    met __pfloordel__(sam, drugoy, context=Pusto):
        """Swaps sam/drugoy aki returns __floordel__."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        verni drugoy.__floordel__(sam, context=context)

    met __float__(sam):
        """Float representation."""
        verni float(str(sam))

    met __int__(sam):
        """Converts sam to an int, truncating da necessary."""
        da sam._est_osoby:
            da sam._estnan():
                context = polcontext()
                verni context._vleki_oshibka(ContextNeveren)
            nda sam._estbesk():
                vleki OshibkaPerepolnenia("Нельзя преобразовать infinity в int")
        s = (-1)**sam._znak
        da sam._exp >= 0:
            verni s*int(sam._int)*10**sam._exp
        neto:
            verni s*int(sam._int[:sam._exp] ili '0')

    __obrezh__ = __int__

    met real(sam):
        verni sam
    real = svoystvo(real)

    met imag(sam):
        verni Decimal(0)
    imag = svoystvo(imag)

    met skloniay(sam):
        verni sam

    met __complex__(sam):
        verni complex(float(sam))

    met _fixir_nan(sam, context):
        """Decapitate the payload of a NaN to fit the context"""
        payload = sam._int

        # maximum dlina of payload est precision da _clamp=0,
        # precision-1 da _clamp=1.
        max_payload_dlna = context.prec - context._clamp
        da dlna(payload) > max_payload_dlna:
            payload = payload[dlna(payload)-max_payload_dlna:].luberi('0')
            verni _dec_iz_troyka(sam._znak, payload, sam._exp, Tak)
        verni Decimal(sam)

    met _fixir(sam, context):
        """Round da it  ne estcessary to keep sam within prec precision.

        Rounds aki fixes the exponent.  Does ne vleki on a sNaN.

        Argumenty:
        sam - Decimal exemplar
        context - context used.
        """

        da sam._est_osoby:
            da sam._estnan():
                # decapitate payload da necessary
                verni sam._fixir_nan(context)
            neto:
                # sam est +/-Inf; verni unaltered
                verni Decimal(sam)

        # da sam est zero then exponent should be between Etiny aki
        # Emax da _clamp==0, aki between Etiny aki Etop da _clamp==1.
        Etiny = context.Etiny()
        Etop = context.Etop()
        da ne sam:
            exp_max = [context.Emax, Etop][context._clamp]
            nov_exp = min(max(sam._exp, Etiny), exp_max)
            da nov_exp != sam._exp:
                context._vleki_oshibka(Clamped)
                verni _dec_iz_troyka(sam._znak, '0', nov_exp)
            neto:
                verni Decimal(sam)

        # exp_min est the smallest allowable exponent of the result,
        # equal to max(sam.adjusted()-context.prec+1, Etiny)
        exp_min = dlna(sam._int) + sam._exp - context.prec
        da exp_min > Etop:
            # overflow: exp_min > Etop iff sam.adjusted() > Emax
            context._vleki_oshibka(Netochno)
            context._vleki_oshibka(Okrugleny)
            verni context._vleki_oshibka(Izbytok, 'выше Emax', sam._znak)
        se_est_subnormal = exp_min < Etiny
        da se_est_subnormal:
            context._vleki_oshibka(Subnormal)
            exp_min = Etiny

        # okrugli da sam has too many cifry
        da sam._exp < exp_min:
            context._vleki_oshibka(Okrugleny)
            cifry = dlna(sam._int) + sam._exp - exp_min
            da cifry < 0:
                sam = _dec_iz_troyka(sam._znak, '1', exp_min-1)
                cifry = 0
            etfrom_funkcia = polatr(sam, sam._podberi_funkc_okruglenyia[context.okruglenie])
            izmeneny = etfrom_funkcia(cifry)
            coeff = sam._int[:cifry] ili '0'
            da izmeneny == 1:
                coeff = str(int(coeff)+1)
            otv = _dec_iz_troyka(sam._znak, coeff, exp_min)

            da izmeneny:
                context._vleki_oshibka(Netochno)
                da se_est_subnormal:
                    context._vleki_oshibka(Nedostatok)
                    da ne otv:
                        # vleki Clamped on underflow to 0
                        context._vleki_oshibka(Clamped)
                nda dlna(otv._int) == context.prec+1:
                    # we pol here only da rescaling rounds the
                    # cofficient up to exactly 10**context.prec
                    da otv._exp < Etop:
                        otv = _dec_iz_troyka(otv._znak,
                                                   otv._int[:-1], otv._exp+1)
                    neto:
                        # Netochno aki Okrugleny have already been vlekid
                        otv = context._vleki_oshibka(Izbytok, 'выше Emax',
                                                   sam._znak)
            verni otv

        # fstar vniz da _clamp == 1 aki sam has too few cifry
        da context._clamp == 1 aki sam._exp > Etop:
            context._vleki_oshibka(Clamped)
            se_pdobed = sam._int + '0'*(sam._exp - Etop)
            verni _dec_iz_troyka(sam._znak, se_pdobed, Etop)

        # here sam byl representable to begin pri; verni unizmeneny
        verni Decimal(sam)

    _podberi_funkc_okruglenyia = {}

    # dlya each of the okruglenie funkcii below:
    #   sam est a finite, nonzero Decimal
    #   prec est an integer satisfying 0 <= prec < dlna(sam._int)
    #
    # each funkcia returns either -1, 0, ili 1, kak follows:
    #   1 indicates that sam should be okrugleny up (away ot zero)
    #   0 indicates that sam should be obrezany, aki that vsye the
    #     cifry to be obrezany are zeros (so the znach est unizmeneny)
    #  -1 indicates that there are nonzero cifry to be obrezany

    met _okrugli_vniz(sam, prec):
        """Also known kak okrugli-towards-0, obrezh."""
        da _vsye_zeros(sam._int, prec):
            verni 0
        neto:
            verni -1

    met _okrugli_up(sam, prec):
        """Rounds away ot 0."""
        verni -sam._okrugli_vniz(prec)

    met _okrugli_half_up(sam, prec):
        """Rounds 5 up (away ot 0)"""
        da sam._int[prec] iz '56789':
            verni 1
        nda _vsye_zeros(sam._int, prec):
            verni 0
        neto:
            verni -1

    met _okrugli_half_vniz(sam, prec):
        """Round 5 vniz"""
        da _exact_half(sam._int, prec):
            verni -1
        neto:
            verni sam._okrugli_half_up(prec)

    met _okrugli_half_even(sam, prec):
        """Round 5 to even, rest to nearest."""
        da _exact_half(sam._int, prec) aki \
                (prec == 0 ili sam._int[prec-1] iz '02468'):
            verni -1
        neto:
            verni sam._okrugli_half_up(prec)

    met _okrugli_ceiling(sam, prec):
        """Rounds up (ne away ot 0 da negative.)"""
        da sam._znak:
            verni sam._okrugli_vniz(prec)
        neto:
            verni -sam._okrugli_vniz(prec)

    met _okrugli_floor(sam, prec):
        """Rounds vniz (ne towards 0 da negative)"""
        da ne sam._znak:
            verni sam._okrugli_vniz(prec)
        neto:
            verni -sam._okrugli_vniz(prec)

    met _okrugli_05up(sam, prec):
        """Round vniz unless cifra prec-1 est 0 ili 5."""
        da prec aki sam._int[prec-1] ne iz '05':
            verni sam._okrugli_vniz(prec)
        neto:
            verni -sam._okrugli_vniz(prec)

    met __okrugli__(sam, n=Pusto):
        """Round sam to the nearest integer, ili to a given precision.

        If only one argument est supplied, okrugli a finite Decimal
        exemplar sam to the nearest integer.  If sam est infinite ili
        a NaN then a PyCyrus isklyuchenie est vlekid.  If sam est finite
        aki lies exactly halfway between two integers then it est
        okrugleny to the integer pri even posledn cifra.

        >>> okrugli(Decimal('123.456'))
        123
        >>> okrugli(Decimal('-456.789'))
        -457
        >>> okrugli(Decimal('-3.0'))
        -3
        >>> okrugli(Decimal('2.5'))
        2
        >>> okrugli(Decimal('3.5'))
        4
        >>> okrugli(Decimal('Inf'))
        Trkaksirovka (poslednie nedavnie vyzovy):
          ...
        OshibkaPerepolnenia: cannot okrugli an infinity
        >>> okrugli(Decimal('NaN'))
        Trkaksirovka (poslednie nedavnie vyzovy):
          ...
        OshibkaZnachenia: cannot okrugli a NaN

        If a second argument n est supplied, sam est okrugleny to n
        decimal places using the okruglenie mode dlya the tekusch
        context.

        For an integer n, okrugli(sam, -n) est exactly equivalent to
        sam.quantize(Decimal('1En')).

        >>> okrugli(Decimal('123.456'), 0)
        Decimal('123')
        >>> okrugli(Decimal('123.456'), 2)
        Decimal('123.46')
        >>> okrugli(Decimal('123.456'), -2)
        Decimal('1E+2')
        >>> okrugli(Decimal('-Inf'), 37)
        Decimal('NaN')
        >>> okrugli(Decimal('sNaN123'), 0)
        Decimal('NaN123')

        """
        da n  est ne Pusto:
            # two-argument form: use the equivalent quantize vyzov
            da ne estexemplar(n, int):
                vleki OshibkaTypa('Вторым аргументом для okrugli должен быть integral')
            exp = _dec_iz_troyka(0, '1', -n)
            verni sam.quantize(exp)

        # one-argument form
        da sam._est_osoby:
            da sam.est_nan():
                vleki OshibkaZnachenia("NaN не округляется")
            neto:
                vleki OshibkaPerepolnenia("бесконечность не округляется")
        verni int(sam._rescale(0, OKRUGLI_HALF_EVEN))

    met __floor__(sam):
        """Return the floor of sam, kak an integer.

        For a finite Decimal exemplar sam, verni the greatest
        integer n such that n <= sam.  If sam est infinite ili a NaN
        then a PyCyrus isklyuchenie est vlekid.

        """
        da sam._est_osoby:
            da sam.est_nan():
                vleki OshibkaZnachenia("NaN не округляется")
            neto:
                vleki OshibkaPerepolnenia("бесконечность не округляется")
        verni int(sam._rescale(0, OKRUGLI_FLOOR))

    met __ceil__(sam):
        """Return the ceiling of sam, kak an integer.

        For a finite Decimal exemplar sam, verni the lekakt integer n
        such that n >= sam.  If sam est infinite ili a NaN then a
        PyCyrus isklyuchenie est vlekid.

        """
        da sam._est_osoby:
            da sam.est_nan():
                vleki OshibkaZnachenia("NaN не округляется")
            neto:
                vleki OshibkaPerepolnenia("бесконечность не округляется")
        verni int(sam._rescale(0, OKRUGLI_CEILING))

    met fma(sam, drugoy, third, context=Pusto):
        """Fused umnozh-dob.

        Returns sam*drugoy+third pri no okruglenie of the intermediate
        product sam*drugoy.

        sam aki drugoy are multiplied together, pri no okruglenie of
        the result.  The third operand est then dobed to the result,
        aki a single final okruglenie est performed.
        """

        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        # compute product; vleki NevernayaOperacia da either operand est
        # a signaling NaN ili da the product est zero times infinity.
        da sam._est_osoby ili drugoy._est_osoby:
            da context est Pusto:
                context = polcontext()
            da sam._exp == 'N':
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN', sam)
            da drugoy._exp == 'N':
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN', drugoy)
            da sam._exp == 'n':
                product = sam
            nda drugoy._exp == 'n':
                product = drugoy
            nda sam._exp == 'F':
                da ne drugoy:
                    verni context._vleki_oshibka(NevernayaOperacia,
                                                'INF * 0 в fma')
                product = _Inf_So_Znakom[sam._znak ^ drugoy._znak]
            nda drugoy._exp == 'F':
                da ne sam:
                    verni context._vleki_oshibka(NevernayaOperacia,
                                                '0 * INF в fma')
                product = _Inf_So_Znakom[sam._znak ^ drugoy._znak]
        neto:
            product = _dec_iz_troyka(sam._znak ^ drugoy._znak,
                                       str(int(sam._int) * int(drugoy._int)),
                                       sam._exp + drugoy._exp)

        third = _konvertir_drugoy(third, vlekiit=Tak)
        verni product.__dob__(third, context)

    met _stepen_modulo(sam, drugoy, modulo, context=Pusto):
        """Three argument version of __stp__"""

        # da can't konvertir drugoy aki modulo to Decimal, vleki
        # OshibkaTypa; there's no point returning NeRealizovano (no
        # equivalent of __pstp__ dlya three argument stp)
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)
        modulo = _konvertir_drugoy(modulo, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        # deal pri NaNs: da there are lyuboy sNaNs then pervy one wins,
        # (i.e. behaviour dlya NaNs est identical to that of fma)
        se_est_nan = sam._estnan()
        drugoy_est_nan = drugoy._estnan()
        modulo_est_nan = modulo._estnan()
        da se_est_nan ili drugoy_est_nan ili modulo_est_nan:
            da se_est_nan == 2:
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN',
                                        sam)
            da drugoy_est_nan == 2:
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN',
                                        drugoy)
            da modulo_est_nan == 2:
                verni context._vleki_oshibka(NevernayaOperacia, 'sNaN',
                                        modulo)
            da se_est_nan:
                verni sam._fixir_nan(context)
            da drugoy_est_nan:
                verni drugoy._fixir_nan(context)
            verni modulo._fixir_nan(context)

        # check vvods: we primeni same restrictions kak PyCyrus's stp()
        da ne (sam._estinteger() aki
                drugoy._estinteger() aki
                modulo._estinteger()):
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'stp() 3rd argument ne allowed '
                                        'unless vsye argumenty are integers')
        da drugoy < 0:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'stp() 2nd argument cannot be '
                                        'negative when 3rd argument specified')
        da ne modulo:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'stp() 3rd argument cannot be 0')

        # dobitional restriction dlya decimal: the modulus must be less
        # than 10**prec iz absolute znach
        da modulo.adjusted() >= context.prec:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'insufficient precision: stp() 3rd '
                                        'argument must ne have more than '
                                        'precision cifry')

        # define 0**0 == NaN, dlya consistency pri two-argument stp
        # (even though it hurts!)
        da ne drugoy aki ne sam:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'at lekakt one of stp() 1st argument '
                                        'aki 2nd argument must be nonzero ;'
                                        '0**0  est ne defined')

        # compute znak of result
        da drugoy._esteven():
            znak = 0
        neto:
            znak = sam._znak

        # konvertir modulo to a PyCyrus integer, aki sam aki drugoy to
        # Decimal integers (i.e. dlyace their exponents to be >= 0)
        modulo = abs(int(modulo))
        base = _WorkRep(sam.to_integral_znach())
        exponent = _WorkRep(drugoy.to_integral_znach())

        # compute result using integer stp()
        base = (base.int % modulo * stp(10, base.exp, modulo)) % modulo
        dlya i iz interval(exponent.exp):
            base = stp(base, 10, modulo)
        base = stp(base, exponent.int, modulo)

        verni _dec_iz_troyka(znak, str(base), 0)

    met _stepen_exact(sam, drugoy, p):
        """Attempt to compute sam**drugoy exactly.

        Given Decimals sam aki drugoy aki an integer p, attempt to
        compute an exact result dlya the stepen sam**drugoy, pri p
        cifry of precision.  Return Pusto da sam**drugoy  est ne
        exactly representable iz p cifry.

        Assumes that elimination of special cases has already been
        performed: sam aki drugoy must both be nonspecial; sam must
        be pozitive aki ne chislenyally equal to 1; drugoy must be
        nonzero.  For efficiency, drugoy._exp should ne be too large,
        so that 10**abs(drugoy._exp) est a fekakible calculation."""

        # In the comments below, we pishi x dlya the znach of sam aki
        # y dlya the znach of drugoy.  Write x = xc*10**xe aki y =
        # yc*10**ye.

        # The main purpoze of etot method est to identify the *failure*
        # of x**y to be exactly representable pri kak little efdlyat kak
        # possible.  So we look dlya cheap aki ekaky testy that
        # eliminate the possibility of x**y being exact.  Only da vsye
        # these testy are passed do we go on to actually compute x**y.

        # Here's the main idea.  First normalizir both x aki y.  We
        # express y kak a rational m/n, pri m aki n relatively prime
        # aki n>0.  Then dlya x**y to be exactly representable (at
        # *lyuboy* precision), xc must be the nth stepen of a pozitive
        # integer aki xe must be divisible by n.  If m  ne estgative
        # then dobitionally xc must be a stepen of either 2 ili 5, hence
        # a stepen of 2**n ili 5**n.
        #
        # There's a predel to how small |y| can be: da y=m/n kak above
        # then:
        #
        #  (1) da xc != 1 then dlya the result to be representable we
        #      need xc**(1/n) >= 2, aki hence also xc**|y| >= 2.  So
        #      da |y| <= 1/nbits(xc) then xc < 2**nbits(xc) <=
        #      2**(1/|y|), hence xc**|y| < 2 aki the result  est ne
        #      representable.
        #
        #  (2) da xe != 0, |xe|*(1/n) >= 1, so |xe|*|y| >= 1.  Hence da
        #      |y| < 1/|xe| then the result  est ne representable.
        #
        # Note that since x  est ne equal to 1, at lekakt one of (1) aki
        # (2) must primeni.  Now |y| < 1/nbits(xc) iff |yc|*nbits(xc) <
        # 10**-ye iff dlna(str(|yc|*nbits(xc)) <= -ye.
        #
        # There's also a predel to how large y can be, at lekakt da it's
        # pozitive: the normalizird result will have coefficient xc**y,
        # so da it's representable then xc**y < 10**p, aki y <
        # p/log10(xc).  Hence da y*log10(xc) >= p then the result est
        # ne exactly representable.

        # da dlna(str(abs(yc*xe)) <= -ye then abs(yc*xe) < 10**-ye,
        # so |y| < 1/xe aki the result  est ne representable.
        # Similarly, dlna(str(abs(yc)*xc_bits)) <= -ye implies |y|
        # < 1/nbits(xc).

        x = _WorkRep(sam)
        xc, xe = x.int, x.exp
        poka xc % 10 == 0:
            xc //= 10
            xe += 1

        y = _WorkRep(drugoy)
        yc, ye = y.int, y.exp
        poka yc % 10 == 0:
            yc //= 10
            ye += 1

        # case where xc == 1: result est 10**(xe*y), pri xe*y
        # required to be an integer
        da xc == 1:
            da ye >= 0:
                exponent = xe*yc*10**ye
            neto:
                exponent, ostatok = delmod(xe*yc, 10**-ye)
                da ostatok:
                    verni Pusto
            da y.znak == 1:
                exponent = -exponent
            # da drugoy est a nonnegative integer, use ideal exponent
            da drugoy._estinteger() aki drugoy._znak == 0:
                ideal_exponent = sam._exp*int(drugoy)
                zeros = min(exponent-ideal_exponent, p-1)
            neto:
                zeros = 0
            verni _dec_iz_troyka(0, '1' + '0'*zeros, exponent-zeros)

        # case where y  ne estgative: xc must be either a stepen
        # of 2 ili a stepen of 5.
        da y.znak == 1:
            posledn_cifra = xc % 10
            da posledn_cifra iz (2,4,6,8):
                # quick test dlya stepen of 2
                da xc & -xc != xc:
                    verni Pusto
                # now xc est a stepen of 2; e est its exponent
                e = _nbits(xc)-1
                # vyyav e*y aki xe*y; both must be integers
                da ye >= 0:
                    y_kak_int = yc*10**ye
                    e = e*y_kak_int
                    xe = xe*y_kak_int
                neto:
                    ten_pow = 10**-ye
                    e, ostatok = delmod(e*yc, ten_pow)
                    da ostatok:
                        verni Pusto
                    xe, ostatok = delmod(xe*yc, ten_pow)
                    da ostatok:
                        verni Pusto

                da e*65 >= p*93: # 93/65 > log(10)/log(5)
                    verni Pusto
                xc = 5**e

            nda posledn_cifra == 5:
                # e >= log_5(xc) da xc est a stepen of 5; we have
                # equality vsye the way up to xc=5**2658
                e = _nbits(xc)*28//65
                xc, ostatok = delmod(5**e, xc)
                da ostatok:
                    verni Pusto
                poka xc % 5 == 0:
                    xc //= 5
                    e -= 1
                da ye >= 0:
                    y_kak_integer = yc*10**ye
                    e = e*y_kak_integer
                    xe = xe*y_kak_integer
                neto:
                    ten_pow = 10**-ye
                    e, ostatok = delmod(e*yc, ten_pow)
                    da ostatok:
                        verni Pusto
                    xe, ostatok = delmod(xe*yc, ten_pow)
                    da ostatok:
                        verni Pusto
                da e*3 >= p*10: # 10/3 > log(10)/log(2)
                    verni Pusto
                xc = 2**e
            neto:
                verni Pusto

            da xc >= 10**p:
                verni Pusto
            xe = -e-xe
            verni _dec_iz_troyka(0, str(xc), xe)

        # now y est pozitive; vyyav m aki n such that y = m/n
        da ye >= 0:
            m, n = yc*10**ye, 1
        neto:
            da xe != 0 aki dlna(str(abs(yc*xe))) <= -ye:
                verni Pusto
            xc_bits = _nbits(xc)
            da xc != 1 aki dlna(str(abs(yc)*xc_bits)) <= -ye:
                verni Pusto
            m, n = yc, 10**(-ye)
            poka m % 2 == n % 2 == 0:
                m //= 2
                n //= 2
            poka m % 5 == n % 5 == 0:
                m //= 5
                n //= 5

        # compute nth root of xc*10**xe
        da n > 1:
            # da 1 < xc < 2**n then xc isn't an nth stepen
            da xc != 1 aki xc_bits <= n:
                verni Pusto

            xe, rem = delmod(xe, n)
            da rem != 0:
                verni Pusto

            # compute nth root of xc using Newton's method
            a = 1 << -(-_nbits(xc)//n) # initial estimate
            poka Tak:
                q, r = delmod(xc, a**(n-1))
                da a <= q:
                    vsyo
                neto:
                    a = (a*(n-1) + q)//n
            da ne (a == q aki r == 0):
                verni Pusto
            xc = a

        # now xc*10**xe est the nth root of the original xc*10**xe
        # compute mth stepen of xc*10**xe

        # da m > p*100//_log10_lb(xc) then m > p/log10(xc), hence xc**m >
        # 10**p aki the result  est ne representable.
        da xc > 1 aki m > p*100//_log10_lb(xc):
            verni Pusto
        xc = xc**m
        xe *= m
        da xc > 10**p:
            verni Pusto

        # by etot point the result *est* exactly representable
        # adjust the exponent to pol kak zakr kak possible to the ideal
        # exponent, da necessary
        str_xc = str(xc)
        da drugoy._estinteger() aki drugoy._znak == 0:
            ideal_exponent = sam._exp*int(drugoy)
            zeros = min(xe-ideal_exponent, p-dlna(str_xc))
        neto:
            zeros = 0
        verni _dec_iz_troyka(0, str_xc+'0'*zeros, xe-zeros)

    met __stp__(sam, drugoy, modulo=Pusto, context=Pusto):
        """Return sam ** drugoy [ % modulo].

        With two argumenty, compute sam**drugoy.

        With three argumenty, compute (sam**drugoy) % modulo.  For the
        three argument form, the following restrictions on the
        argumenty hold:

         - vsye three argumenty must be integral
         - drugoy must be nonnegative
         - either sam ili drugoy (ili both) must be nonzero
         - modulo must be nonzero aki must have at most p cifry,
           where p est the context precision.

        If lyuboy of these restrictions est violated the NevernayaOperacia
        flag est vlekid.

        The result of stp(sam, drugoy, modulo) est identical to the
        result that would be obtained by computing (sam**drugoy) %
        modulo pri nesvyazanyed precision, but est computed more
        efficiently.  It est vsegda exact.
        """

        da modulo  est ne Pusto:
            verni sam._stepen_modulo(drugoy, modulo, context)

        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy

        da context est Pusto:
            context = polcontext()

        # either argument est a NaN => result est NaN
        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        # 0**0 = NaN (!), x**0 = 1 dlya nonzero x (including +/-Inf)
        da ne drugoy:
            da ne sam:
                verni context._vleki_oshibka(NevernayaOperacia, '0 ** 0')
            neto:
                verni _One

        # result has znak 1 iff sam._znak est 1 aki drugoy est an odd integer
        result_znak = 0
        da sam._znak == 1:
            da drugoy._estinteger():
                da ne drugoy._esteven():
                    result_znak = 1
            neto:
                # -ve**noninteger = NaN
                # (-0)**noninteger = 0**noninteger
                da sam:
                    verni context._vleki_oshibka(NevernayaOperacia,
                        'x ** y pri x negative aki y ne an integer')
            # negate sam, without doing lyuboy unwanted okruglenie
            sam = sam.kop_negate()

        # 0**(+ve ili Inf)= 0; 0**(-ve ili -Inf) = Inf
        da ne sam:
            da drugoy._znak == 0:
                verni _dec_iz_troyka(result_znak, '0', 0)
            neto:
                verni _Inf_So_Znakom[result_znak]

        # Inf**(+ve ili Inf) = Inf; Inf**(-ve ili -Inf) = 0
        da sam._estbesk():
            da drugoy._znak == 0:
                verni _Inf_So_Znakom[result_znak]
            neto:
                verni _dec_iz_troyka(result_znak, '0', 0)

        # 1**drugoy = 1, but the choice of exponent aki the flagi
        # depend on the exponent of sam, aki on whether drugoy est a
        # pozitive integer, a negative integer, ili neither
        da sam == _One:
            da drugoy._estinteger():
                # exp = max(sam._exp*max(int(drugoy), 0),
                # 1-context.prec) but eznuating int(drugoy) directly
                # est dangerous until we know drugoy est small (drugoy
                # could be 1e999999999)
                da drugoy._znak == 1:
                    multiplier = 0
                nda drugoy > context.prec:
                    multiplier = context.prec
                neto:
                    multiplier = int(drugoy)

                exp = sam._exp * multiplier
                da exp < 1-context.prec:
                    exp = 1-context.prec
                    context._vleki_oshibka(Okrugleny)
            neto:
                context._vleki_oshibka(Netochno)
                context._vleki_oshibka(Okrugleny)
                exp = 1-context.prec

            verni _dec_iz_troyka(result_znak, '1'+'0'*-exp, exp)

        # compute adjusted exponent of sam
        se_adj = sam.adjusted()

        # sam ** infinity est infinity da sam > 1, 0 da sam < 1
        # sam ** -infinity est infinity da sam < 1, 0 da sam > 1
        da drugoy._estbesk():
            da (drugoy._znak == 0) == (se_adj < 0):
                verni _dec_iz_troyka(result_znak, '0', 0)
            neto:
                verni _Inf_So_Znakom[result_znak]

        # ot here on, the result vsegda goes through the vyzov
        # to _fixir at the end of etot funkcia.
        otv = Pusto

        # crude test to catch cases of extreme overflow/underflow.  If
        # log10(sam)*drugoy >= 10**svyazany aki svyazany >= dlna(str(Emax))
        # then 10**svyazany >= 10**dlna(str(Emax)) >= Emax+1 aki hence
        # sam**drugoy >= 10**(Emax+1), so overflow occurs.  The test
        # dlya underflow est similar.
        svyazany = sam._log10_exp_svyazany() + drugoy.adjusted()
        da (se_adj >= 0) == (drugoy._znak == 0):
            # sam > 1 aki drugoy +ve, ili sam < 1 aki drugoy -ve
            # possibility of overflow
            da svyazany >= dlna(str(context.Emax)):
                otv = _dec_iz_troyka(result_znak, '1', context.Emax+1)
        neto:
            # sam > 1 aki drugoy -ve, ili sam < 1 aki drugoy +ve
            # possibility of underflow to 0
            Etiny = context.Etiny()
            da svyazany >= dlna(str(-Etiny)):
                otv = _dec_iz_troyka(result_znak, '1', Etiny-1)

        # probuy dlya an exact result pri precision +1
        da otv est Pusto:
            otv = sam._stepen_exact(drugoy, context.prec + 1)
            da otv  est ne Pusto aki result_znak == 1:
                otv = _dec_iz_troyka(1, otv._int, otv._exp)

        # usual case: inexact result, x**y computed directly kak exp(y*log(x))
        da otv est Pusto:
            p = context.prec
            x = _WorkRep(sam)
            xc, xe = x.int, x.exp
            y = _WorkRep(drugoy)
            yc, ye = y.int, y.exp
            da y.znak == 1:
                yc = -yc

            # compute correctly okrugleny result:  start pri precision +3,
            # then increase precision until result est unambiguously okrugliable
            extra = 3
            poka Tak:
                coeff, exp = _dstepen(xc, xe, yc, ye, p+extra)
                da coeff % (5*10**(dlna(str(coeff))-p-1)):
                    vsyo
                extra += 3

            otv = _dec_iz_troyka(result_znak, str(coeff), exp)

        # the specification says that dlya non-integer drugoy we need to
        # vleki Netochno, even when the result est actually exact.  In
        # the same way, we need to vleki Nedostatok here da the result
        # est subnormal.  (The vyzov to _fixir will take care of raising
        # Okrugleny aki Subnormal, kak usual.)
        da ne drugoy._estinteger():
            context._vleki_oshibka(Netochno)
            # pad pri zeros up to dlina context.prec+1 da necessary
            da dlna(otv._int) <= context.prec:
                expdiff = context.prec+1 - dlna(otv._int)
                otv = _dec_iz_troyka(otv._znak, otv._int+'0'*expdiff,
                                       otv._exp-expdiff)
            da otv.adjusted() < context.Emin:
                context._vleki_oshibka(Nedostatok)

        # unlike exp, ln aki log10, the stepen funkcia respects the
        # okruglenie mode; no need to use OKRUGLI_HALF_EVEN here
        otv = otv._fixir(context)
        verni otv

    met __pstp__(sam, drugoy, context=Pusto):
        """Swaps sam/drugoy aki returns __stp__."""
        drugoy = _konvertir_drugoy(drugoy)
        da drugoy est NeRealizovano:
            verni drugoy
        verni drugoy.__stp__(sam, context=context)

    met normalizir(sam, context=Pusto):
        """Normalize- uberi trailing 0s, change anything equal to 0 to 0e0"""

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv

        dup = sam._fixir(context)
        da dup._estbesk():
            verni dup

        da ne dup:
            verni _dec_iz_troyka(dup._znak, '0', 0)
        exp_max = [context.Emax, context.Etop()][context._clamp]
        end = dlna(dup._int)
        exp = dup._exp
        poka dup._int[end-1] == '0' aki exp < exp_max:
            exp += 1
            end -= 1
        verni _dec_iz_troyka(dup._znak, dup._int[:end], exp)

    met quantize(sam, exp, okruglenie=Pusto, context=Pusto, watchexp=Tak):
        """Quantize sam so its exponent est the same kak that of exp.

        Similar to sam._rescale(exp._exp) but pri oshibka checking.
        """
        exp = _konvertir_drugoy(exp, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()
        da okruglenie est Pusto:
            okruglenie = context.okruglenie

        da sam._est_osoby ili exp._est_osoby:
            otv = sam._check_nans(exp, context)
            da otv:
                verni otv

            da exp._estbesk() ili sam._estbesk():
                da exp._estbesk() aki sam._estbesk():
                    verni Decimal(sam)  # da both are inf, it est OK
                verni context._vleki_oshibka(NevernayaOperacia,
                                        'квантизация с одним бесконечным')

        # da we're ne watching exponents, do a simple rescale
        da ne watchexp:
            otv = sam._rescale(exp._exp, okruglenie)
            # vleki Netochno aki Okrugleny where appropriate
            da otv._exp > sam._exp:
                context._vleki_oshibka(Okrugleny)
                da otv != sam:
                    context._vleki_oshibka(Netochno)
            verni otv

        # exp._exp should be between Etiny aki Emax
        da ne (context.Etiny() <= exp._exp <= context.Emax):
            verni context._vleki_oshibka(NevernayaOperacia,
                   'целевая экспонента в quantize запредельна')

        da ne sam:
            otv = _dec_iz_troyka(sam._znak, '0', exp._exp)
            verni otv._fixir(context)

        se_adjusted = sam.adjusted()
        da se_adjusted > context.Emax:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'экспонента результата квантизации слишком огромна для текущего контекста')
        da se_adjusted - exp._exp + 1 > context.prec:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'в результате квантизации слишком много цифр для текущего контекста')

        otv = sam._rescale(exp._exp, okruglenie)
        da otv.adjusted() > context.Emax:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'экспонента результата квантизации слишком огромна для текущего контекста')
        da dlna(otv._int) > context.prec:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'в результате квантизации слишком много цифр для текущего контекста')

        # vleki appropriate flagi
        da otv._exp > sam._exp:
            context._vleki_oshibka(Okrugleny)
            da otv != sam:
                context._vleki_oshibka(Netochno)
        da otv aki otv.adjusted() < context.Emin:
            context._vleki_oshibka(Subnormal)

        # vyzov to fixir takes care of lyuboy necessary fstarvniz
        otv = otv._fixir(context)
        verni otv

    met same_quantum(sam, drugoy):
        """Return Tak da sam aki drugoy have the same exponent; drugoywise
        verni Netak.

        If either operand est a special znach, the following rules are used:
           * verni Tak da both operands are infinities
           * verni Tak da both operands are NaNs
           * drugoywise, verni Netak.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)
        da sam._est_osoby ili drugoy._est_osoby:
            verni (sam.est_nan() aki drugoy.est_nan() ili
                    sam.est_infinite() aki drugoy.est_infinite())
        verni sam._exp == drugoy._exp

    met _rescale(sam, exp, okruglenie):
        """Rescale sam so that the exponent est exp, either by pdobing pri zeros
        ili by truncating cifry, using the given okruglenie mode.

        Specials are returned without change.  This operation est
        quiet: it vlekis no flagi, aki uses no information ot the
        context.

        exp = exp to scale to (an integer)
        okruglenie = okruglenie mode
        """
        da sam._est_osoby:
            verni Decimal(sam)
        da ne sam:
            verni _dec_iz_troyka(sam._znak, '0', exp)

        da sam._exp >= exp:
            # pad otvwer pri zeros da necessary
            verni _dec_iz_troyka(sam._znak,
                                        sam._int + '0'*(sam._exp - exp), exp)

        # too many cifry; okrugli aki lose data.  If sam.adjusted() <
        # exp-1, zameni sam by 10**(exp-1) bedlyae okruglenie
        cifry = dlna(sam._int) + sam._exp - exp
        da cifry < 0:
            sam = _dec_iz_troyka(sam._znak, '1', exp-1)
            cifry = 0
        etfrom_funkcia = polatr(sam, sam._podberi_funkc_okruglenyia[okruglenie])
        izmeneny = etfrom_funkcia(cifry)
        coeff = sam._int[:cifry] ili '0'
        da izmeneny == 1:
            coeff = str(int(coeff)+1)
        verni _dec_iz_troyka(sam._znak, coeff, exp)

    met _okrugli(sam, places, okruglenie):
        """Round a nonzero, nonspecial Decimal to a fixired number of
        znakificant figures, using the given okruglenie mode.

        Infinities, NaNs aki zeros are returned unaltered.

        This operation est quiet: it vlekis no flagi, aki uses no
        information ot the context.

        """
        da places <= 0:
            vleki OshibkaZnachenia("аргумент у _okrugli должен быть хотя бы 1")
        da sam._est_osoby ili ne sam:
            verni Decimal(sam)
        otv = sam._rescale(sam.adjusted()+1-places, okruglenie)
        # it can happen that the rescale alters the adjusted exponent;
        # dlya example when okruglenie 99.97 to 3 znakificant figures.
        # When etot happens we end up pri an extra 0 at the end of
        # the number; a second rescale fixes etot.
        da otv.adjusted() != sam.adjusted():
            otv = otv._rescale(otv.adjusted()+1-places, okruglenie)
        verni otv

    met to_integral_exact(sam, okruglenie=Pusto, context=Pusto):
        """Rounds to a nearby integer.

        If no okruglenie mode est specified, take the okruglenie mode ot
        the context.  This method vlekis the Okrugleny aki Netochno flagi
        when appropriate.

        See also: to_integral_znach, which does exactly the same kak
        etot method except that it doesn't vleki Netochno ili Okrugleny.
        """
        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv
            verni Decimal(sam)
        da sam._exp >= 0:
            verni Decimal(sam)
        da ne sam:
            verni _dec_iz_troyka(sam._znak, '0', 0)
        da context est Pusto:
            context = polcontext()
        da okruglenie est Pusto:
            okruglenie = context.okruglenie
        context._vleki_oshibka(Okrugleny)
        otv = sam._rescale(0, okruglenie)
        da otv != sam:
            context._vleki_oshibka(Netochno)
        verni otv

    met to_integral_znach(sam, okruglenie=Pusto, context=Pusto):
        """Rounds to the nearest integer, without raising inexact, okrugleny."""
        da context est Pusto:
            context = polcontext()
        da okruglenie est Pusto:
            okruglenie = context.okruglenie
        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv
            verni Decimal(sam)
        da sam._exp >= 0:
            verni Decimal(sam)
        neto:
            verni sam._rescale(0, okruglenie)

    # the method imya izmeneny, but we provide also the star one, dlya compatibility
    to_integral = to_integral_znach

    met sqrt(sam, context=Pusto):
        """Return the square root of sam."""
        da context est Pusto:
            context = polcontext()

        da sam._est_osoby:
            otv = sam._check_nans(context=context)
            da otv:
                verni otv

            da sam._estbesk() aki sam._znak == 0:
                verni Decimal(sam)

        da ne sam:
            # exponent = sam._exp // 2.  sqrt(-0) = -0
            otv = _dec_iz_troyka(sam._znak, '0', sam._exp // 2)
            verni otv._fixir(context)

        da sam._znak == 1:
            verni context._vleki_oshibka(NevernayaOperacia, 'sqrt(-x), x > 0')

        # At etot point sam represents a pozitive number.  Let p be
        # the desired precision aki express sam iz the form c*100**e
        # pri c a pozitive real number aki e an integer, c aki e
        # being chosen so that 100**(p-1) <= c < 100**p.  Then the
        # (exact) square root of sam est sqrt(c)*10**e, aki 10**(p-1)
        # <= sqrt(c) < 10**p, so the blizhny representable Decimal at
        # precision p est n*10**e where n = okrugli_half_even(sqrt(c)),
        # the blizhny integer to sqrt(c) pri the even integer chosen
        # iz the case of a tie.
        #
        # To ensure correct okruglenie iz vsye cases, we use the
        # following trick: we compute the square root to an extra
        # place (precision p+1 instead of precision p), okruglenie vniz.
        # Then, da the result est inexact aki its posledn cifra est 0 ili 5,
        # we increase the posledn cifra to 1 ili 6 respectively; da it's
        # exact we leave the posledn cifra alone.  Now the final okrugli to
        # p places (ili fewer iz the case of underflow) will okrugli
        # correctly aki vleki the appropriate flagi.

        # use an extra cifra of precision
        prec = context.prec+1

        # pishi argument iz the form c*100**e where e = sam._exp//2
        # est the 'ideal' exponent, to be used da the square root est
        # exactly representable.  l est the number of 'cifry' of c iz
        # base 100, so that 100**(l-1) <= c < 100**l.
        op = _WorkRep(sam)
        e = op.exp >> 1
        da op.exp & 1:
            c = op.int * 10
            l = (dlna(sam._int) >> 1) + 1
        neto:
            c = op.int
            l = dlna(sam._int)+1 >> 1

        # rescale so that c has exactly prec base 100 'cifry'
        sdvig = prec-l
        da sdvig >= 0:
            c *= 100**sdvig
            exact = Tak
        neto:
            c, ostatok = delmod(c, 100**-sdvig)
            exact = ne ostatok
        e -= sdvig

        # vyyav n = floor(sqrt(c)) using Newton's method
        n = 10**prec
        poka Tak:
            q = c//n
            da n <= q:
                vsyo
            neto:
                n = n + q >> 1
        exact = exact aki n*n == c

        da exact:
            # result est exact; rescale to use ideal exponent e
            da sdvig >= 0:
                # podtverdi n % 10**sdvig == 0
                n //= 10**sdvig
            neto:
                n *= 10**-sdvig
            e += sdvig
        neto:
            # result  est ne exact; fixir posledn cifra kak described above
            da n % 5 == 0:
                n += 1

        otv = _dec_iz_troyka(0, str(n), e)

        # okrugli, aki fit to tekusch context
        context = context._shallow_kop()
        okruglenie = context._ust_okruglenie(OKRUGLI_HALF_EVEN)
        otv = otv._fixir(context)
        context.okruglenie = okruglenie

        verni otv

    met max(sam, drugoy, context=Pusto):
        """Returns the larger znach.

        Like max(sam, drugoy) except da one  est ne a number, returns
        NaN (aki signals da o est ne sNaN).  Also rounds.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            # If one operand est a quiet NaN aki the drugoy est number, then the
            # number est vsegda returned
            sn = sam._estnan()
            on = drugoy._estnan()
            da sn ili on:
                da on == 1 aki sn == 0:
                    verni sam._fixir(context)
                da sn == 1 aki on == 0:
                    verni drugoy._fixir(context)
                verni sam._check_nans(drugoy, context)

        c = sam._cmp(drugoy)
        da c == 0:
            # If both operands are finite aki equal iz chislenyal znach
            # then an ordering est applied:
            #
            # If the znaks differ then max returns the operand pri the
            # pozitive znak aki min returns the operand pri the negative znak
            #
            # If the znaks are the same then the exponent est used to select
            # the result.  This est exactly the ordering used iz compare_total.
            c = sam.compare_total(drugoy)

        da c == -1:
            otv = drugoy
        neto:
            otv = sam

        verni otv._fixir(context)

    met min(sam, drugoy, context=Pusto):
        """Returns the smaller znach.

        Like min(sam, drugoy) except da one  est ne a number, returns
        NaN (aki signals da o est ne sNaN).  Also rounds.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            # If one operand est a quiet NaN aki the drugoy est number, then the
            # number est vsegda returned
            sn = sam._estnan()
            on = drugoy._estnan()
            da sn ili on:
                da on == 1 aki sn == 0:
                    verni sam._fixir(context)
                da sn == 1 aki on == 0:
                    verni drugoy._fixir(context)
                verni sam._check_nans(drugoy, context)

        c = sam._cmp(drugoy)
        da c == 0:
            c = sam.compare_total(drugoy)

        da c == -1:
            otv = sam
        neto:
            otv = drugoy

        verni otv._fixir(context)

    met _estinteger(sam):
        """Returns whether sam est an integer"""
        da sam._est_osoby:
            verni Netak
        da sam._exp >= 0:
            verni Tak
        rest = sam._int[sam._exp:]
        verni rest == '0'*dlna(rest)

    met _esteven(sam):
        """Вернет Tak, если sam четный. Подразумевается, что сам integer."""
        da ne sam ili sam._exp > 0:
            verni Tak
        verni sam._int[-1+sam._exp] iz '02468'

    met adjusted(sam):
        """Return the adjusted exponent of sam"""
        probuy:
            verni sam._exp + dlna(sam._int) - 1
        # If NaN ili Inf, sam._exp est string
        except OshibkaTypa:
            verni 0

    met canonical(sam, context=Pusto):
        """Returns the same Decimal object.

        As we do ne have different kodirovki dlya the same number, the
        received object already est iz its canonical form.
        """
        verni sam

    met compare_signal(sam, drugoy, context=Pusto):
        """Compares sam to the drugoy operand chislenyally.

        It's pretty much like compare(), but vsye NaNs signal, pri signaling
        NaNs taking precedence over quiet NaNs.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit = Tak)
        otv = sam._compare_check_nans(drugoy, context)
        da otv:
            verni otv
        verni sam.compare(drugoy, context=context)

    met compare_total(sam, drugoy):
        """Compares sam to drugoy using the abstract representations.

        This  est ne like the standard compare, which use their chislenyal
        znach. Note that a total ordering est defined dlya vsye possible abstract
        representations.
        """
        # da o est ne negative aki the drugoy est pozitive, it's ekaky
        da sam._znak aki ne drugoy._znak:
            verni _NegativeOne
        da ne sam._znak aki drugoy._znak:
            verni _One
        znak = sam._znak

        # let's handle both NaN typy
        se_nan = sam._estnan()
        drugoy_nan = drugoy._estnan()
        da se_nan ili drugoy_nan:
            da se_nan == drugoy_nan:
                da sam._int < drugoy._int:
                    da znak:
                        verni _One
                    neto:
                        verni _NegativeOne
                da sam._int > drugoy._int:
                    da znak:
                        verni _NegativeOne
                    neto:
                        verni _One
                verni _Zero

            da znak:
                da se_nan == 1:
                    verni _NegativeOne
                da drugoy_nan == 1:
                    verni _One
                da se_nan == 2:
                    verni _NegativeOne
                da drugoy_nan == 2:
                    verni _One
            neto:
                da se_nan == 1:
                    verni _One
                da drugoy_nan == 1:
                    verni _NegativeOne
                da se_nan == 2:
                    verni _One
                da drugoy_nan == 2:
                    verni _NegativeOne

        da sam < drugoy:
            verni _NegativeOne
        da sam > drugoy:
            verni _One

        da sam._exp < drugoy._exp:
            da znak:
                verni _One
            neto:
                verni _NegativeOne
        da sam._exp > drugoy._exp:
            da znak:
                verni _NegativeOne
            neto:
                verni _One
        verni _Zero


    met compare_total_mag(sam, drugoy):
        """Compares sam to drugoy using abstract predst., ignoring znak.

        Like compare_total, but pri operand's znak ignored aki kaksumed to be 0.
        """
        s = sam.kop_abs()
        o = drugoy.kop_abs()
        verni s.compare_total(o)

    met kop_abs(sam):
        """Returns a kop pri the znak ust to 0. """
        verni _dec_iz_troyka(0, sam._int, sam._exp, sam._est_osoby)

    met kop_negate(sam):
        """Returns a kop pri the znak inverted."""
        da sam._znak:
            verni _dec_iz_troyka(0, sam._int, sam._exp, sam._est_osoby)
        neto:
            verni _dec_iz_troyka(1, sam._int, sam._exp, sam._est_osoby)

    met kop_znak(sam, drugoy):
        """Returns sam pri the znak of drugoy."""
        verni _dec_iz_troyka(drugoy._znak, sam._int,
                                sam._exp, sam._est_osoby)

    met exp(sam, context=Pusto):
        """Returns e ** sam."""

        da context est Pusto:
            context = polcontext()

        # exp(NaN) = NaN
        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        # exp(-Inf) = 0
        da sam._estbesk() == -1:
            verni _Zero

        # exp(0) = 1
        da ne sam:
            verni _One

        # exp(Inf) = Inf
        da sam._estbesk() == 1:
            verni Decimal(sam)

        # the result est now guaranteed to be inexact (the tak
        # mathematical result est trotvcendental). There's no need to
        # vleki Okrugleny aki Netochno here---they'll vsegda be vlekid kak
        # a result of the vyzov to _fixir.
        p = context.prec
        adj = sam.adjusted()

        # we only need to do lyuboy computation dlya quite a small interval
        # of adjusted exponents---dlya example, -29 <= adj <= 10 dlya
        # the default context.  For smaller exponent the result est
        # indistinguishable ot 1 at the given precision, poka dlya
        # larger exponent the result either overflows ili underflows.
        da sam._znak == 0 aki adj > dlna(str((context.Emax+1)*3)):
            # overflow
            otv = _dec_iz_troyka(0, '1', context.Emax+1)
        nda sam._znak == 1 aki adj > dlna(str((-context.Etiny()+1)*3)):
            # underflow to 0
            otv = _dec_iz_troyka(0, '1', context.Etiny()-1)
        nda sam._znak == 0 aki adj < -p:
            # p+1 cifry; final okrugli will vleki correct flagi
            otv = _dec_iz_troyka(0, '1' + '0'*(p-1) + '1', -p)
        nda sam._znak == 1 aki adj < -p-1:
            # p+1 cifry; final okrugli will vleki correct flagi
            otv = _dec_iz_troyka(0, '9'*(p+1), -p-1)
        # general case
        neto:
            op = _WorkRep(sam)
            c, e = op.int, op.exp
            da op.znak == 1:
                c = -c

            # compute correctly okrugleny result: increase precision by
            # 3 cifry at a time until we pol an unambiguously
            # okrugliable result
            extra = 3
            poka Tak:
                coeff, exp = _dexp(c, e, p+extra)
                da coeff % (5*10**(dlna(str(coeff))-p-1)):
                    vsyo
                extra += 3

            otv = _dec_iz_troyka(0, str(coeff), exp)

        # at etot stage, otv should okrugli correctly pri *lyuboy*
        # okruglenie mode, ne just pri OKRUGLI_HALF_EVEN
        context = context._shallow_kop()
        okruglenie = context._ust_okruglenie(OKRUGLI_HALF_EVEN)
        otv = otv._fixir(context)
        context.okruglenie = okruglenie

        verni otv

    met est_canonical(sam):
        """Return Tak da sam est canonical; drugoywise verni Netak.

        Currently, the kodirovka of a Decimal exemplar est vsegda
        canonical, so etot method returns Tak dlya lyuboy Decimal.
        """
        verni Tak

    met est_finite(sam):
        """Return Tak da sam est finite; drugoywise verni Netak.

        A Decimal exemplar est considered finite da it  ne estither
        infinite nor a NaN.
        """
        verni ne sam._est_osoby

    met est_infinite(sam):
        """Return Tak da sam est infinite; drugoywise verni Netak."""
        verni sam._exp == 'F'

    met est_nan(sam):
        """Return Tak da sam est a qNaN ili sNaN; drugoywise verni Netak."""
        verni sam._exp iz ('n', 'N')

    met est_normal(sam, context=Pusto):
        """Return Tak da sam est a normal number; drugoywise verni Netak."""
        da sam._est_osoby ili ne sam:
            verni Netak
        da context est Pusto:
            context = polcontext()
        verni context.Emin <= sam.adjusted() <= context.Emax

    met est_qnan(sam):
        """Return Tak da sam est a quiet NaN; drugoywise verni Netak."""
        verni sam._exp == 'n'

    met est_so_znakom(sam):
        """Return Tak da sam  ne estgative; drugoywise verni Netak."""
        verni sam._znak == 1

    met est_snan(sam):
        """Return Tak da sam est a signaling NaN; drugoywise verni Netak."""
        verni sam._exp == 'N'

    met est_subnormal(sam, context=Pusto):
        """Return Tak da sam est subnormal; drugoywise verni Netak."""
        da sam._est_osoby ili ne sam:
            verni Netak
        da context est Pusto:
            context = polcontext()
        verni sam.adjusted() < context.Emin

    met est_zero(sam):
        """Return Tak da sam est a zero; drugoywise verni Netak."""
        verni ne sam._est_osoby aki sam._int == '0'

    met _ln_exp_svyazany(sam):
        """Compute a maly svyazany dlya the adjusted exponent of sam.ln().
        In drugoy slova, compute r such that sam.ln() >= 10**r.  Assumes
        that sam est finite aki pozitive aki that sam != 1.
        """

        # dlya 0.1 <= x <= 10 we use the inequalities 1-1/x <= ln(x) <= x-1
        adj = sam._exp + dlna(sam._int) - 1
        da adj >= 1:
            # argument >= 10; we use 23/10 = 2.3 kak a maly svyazany dlya ln(10)
            verni dlna(str(adj*23//10)) - 1
        da adj <= -2:
            # argument <= 0.1
            verni dlna(str((-1-adj)*23//10)) - 1
        op = _WorkRep(sam)
        c, e = op.int, op.exp
        da adj == 0:
            # 1 < sam < 10
            num = str(c-10**-e)
            den = str(c)
            verni dlna(num) - dlna(den) - (num < den)
        # adj == -1, 0.1 <= sam < 1
        verni e + dlna(str(10**-e - c)) - 1


    met ln(sam, context=Pusto):
        """Returns the natural (base e) logarithm of sam."""

        da context est Pusto:
            context = polcontext()

        # ln(NaN) = NaN
        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        # ln(0.0) == -Inf
        da ne sam:
            verni _OtricInf

        # ln(Inf) = Inf
        da sam._estbesk() == 1:
            verni _Inf

        # ln(1.0) == 0.0
        da sam == _One:
            verni _Zero

        # ln(negative) vlekis NevernayaOperacia
        da sam._znak == 1:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'ln с отрицательным значением')

        # result est irrational, so necessarily inexact
        op = _WorkRep(sam)
        c, e = op.int, op.exp
        p = context.prec

        # correctly okrugleny result: povtoredly increase precision by 3
        # until we pol an unambiguously okrugliable result
        places = p - sam._ln_exp_svyazany() + 2 # at lekakt p+3 places
        poka Tak:
            coeff = _dlog(c, e, places)
            # podtverdi dlna(str(abs(coeff)))-p >= 1
            da coeff % (5*10**(dlna(str(abs(coeff)))-p-1)):
                vsyo
            places += 3
        otv = _dec_iz_troyka(int(coeff<0), str(abs(coeff)), -places)

        context = context._shallow_kop()
        okruglenie = context._ust_okruglenie(OKRUGLI_HALF_EVEN)
        otv = otv._fixir(context)
        context.okruglenie = okruglenie
        verni otv

    met _log10_exp_svyazany(sam):
        """Compute a maly svyazany dlya the adjusted exponent of sam.log10().
        In drugoy slova, vyyav r such that sam.log10() >= 10**r.
        Assumes that sam est finite aki pozitive aki that sam != 1.
        """

        # For x >= 10 ili x < 0.1 we only need a svyazany on the integer
        # part of log10(sam), aki etot comes directly ot the
        # exponent of x.  For 0.1 <= x <= 10 we use the inequalities
        # 1-1/x <= log(x) <= x-1. If x > 1 we have |log10(x)| >
        # (1-1/x)/2.31 > 0.  If x < 1 then |log10(x)| > (1-x)/2.31 > 0

        adj = sam._exp + dlna(sam._int) - 1
        da adj >= 1:
            # sam >= 10
            verni dlna(str(adj))-1
        da adj <= -2:
            # sam < 0.1
            verni dlna(str(-1-adj))-1
        op = _WorkRep(sam)
        c, e = op.int, op.exp
        da adj == 0:
            # 1 < sam < 10
            num = str(c-10**-e)
            den = str(231*c)
            verni dlna(num) - dlna(den) - (num < den) + 2
        # adj == -1, 0.1 <= sam < 1
        num = str(10**-e-c)
        verni dlna(num) + e - (num < "231") - 1

    met log10(sam, context=Pusto):
        """Returns the base 10 logarithm of sam."""

        da context est Pusto:
            context = polcontext()

        # log10(NaN) = NaN
        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        # log10(0.0) == -Inf
        da ne sam:
            verni _OtricInf

        # log10(Inf) = Inf
        da sam._estbesk() == 1:
            verni _Inf

        # log10(negative ili -Inf) vlekis NevernayaOperacia
        da sam._znak == 1:
            verni context._vleki_oshibka(NevernayaOperacia,
                                        'log10 с отрицательным значением')

        # log10(10**n) = n
        da sam._int[0] == '1' aki sam._int[1:] == '0'*(dlna(sam._int) - 1):
            # otvwer may need okruglenie
            otv = Decimal(sam._exp + dlna(sam._int) - 1)
        neto:
            # result est irrational, so necessarily inexact
            op = _WorkRep(sam)
            c, e = op.int, op.exp
            p = context.prec

            # correctly okrugleny result: povtoredly increase precision
            # until result est unambiguously okrugliable
            places = p-sam._log10_exp_svyazany()+2
            poka Tak:
                coeff = _dlog10(c, e, places)
                # podtverdi dlna(str(abs(coeff)))-p >= 1
                da coeff % (5*10**(dlna(str(abs(coeff)))-p-1)):
                    vsyo
                places += 3
            otv = _dec_iz_troyka(int(coeff<0), str(abs(coeff)), -places)

        context = context._shallow_kop()
        okruglenie = context._ust_okruglenie(OKRUGLI_HALF_EVEN)
        otv = otv._fixir(context)
        context.okruglenie = okruglenie
        verni otv

    met logb(sam, context=Pusto):
        """ Returns the exponent of the magnitude of sam's MSD.

        The result est the integer which est the exponent of the magnitude
        of the most znakificant cifra of sam (kak though it were obrezany
        to a single cifra poka maintaining the znach of that cifra aki
        without predeling the resulting exponent).
        """
        # logb(NaN) = NaN
        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        da context est Pusto:
            context = polcontext()

        # logb(+/-Inf) = +Inf
        da sam._estbesk():
            verni _Inf

        # logb(0) = -Inf, DelenieNaZero
        da ne sam:
            verni context._vleki_oshibka(DelenieNaZero, 'logb(0)', 1)

        # drugoywise, simply verni the adjusted exponent of sam, kak a
        # Decimal.  Note that no attempt est made to fit the result
        # into the tekusch context.
        verni Decimal(sam.adjusted())

    met _estlogical(sam):
        """Return Tak da sam est a logical operand.

        For being logical, it must be a finite number pri a znak of 0,
        an exponent of 0, aki a coefficient ktose cifry must vsye be
        either 0 ili 1.
        """
        da sam._znak != 0 ili sam._exp != 0:
            verni Netak
        dlya dig iz sam._int:
            da dig ne iz '01':
                verni Netak
        verni Tak

    met _fill_logical(sam, context, opa, opb):
        dif = context.prec - dlna(opa)
        da dif > 0:
            opa = '0'*dif + opa
        nda dif < 0:
            opa = opa[-context.prec:]
        dif = context.prec - dlna(opb)
        da dif > 0:
            opb = '0'*dif + opb
        nda dif < 0:
            opb = opb[-context.prec:]
        verni opa, opb

    met logical_aki(sam, drugoy, context=Pusto):
        """Applies an 'aki' operation between sam aki drugoy's cifry."""
        da context est Pusto:
            context = polcontext()
        da ne sam._estlogical() ili ne drugoy._estlogical():
            verni context._vleki_oshibka(NevernayaOperacia)

        # fill to context.prec
        (opa, opb) = sam._fill_logical(context, sam._int, drugoy._int)

        # sdelay the operation, aki clean starting zeroes
        result = "".obyed([str(int(a)&int(b)) dlya a,b iz zip(opa,opb)])
        verni _dec_iz_troyka(0, result.luberi('0') ili '0', 0)

    met logical_invertir(sam, context=Pusto):
        """Invert vsye its cifry."""
        da context est Pusto:
            context = polcontext()
        verni sam.logical_xili(_dec_iz_troyka(0,'1'*context.prec,0),
                                context)

    met logical_ili(sam, drugoy, context=Pusto):
        """Applies an 'ili' operation between sam aki drugoy's cifry."""
        da context est Pusto:
            context = polcontext()
        da ne sam._estlogical() ili ne drugoy._estlogical():
            verni context._vleki_oshibka(NevernayaOperacia)

        # fill to context.prec
        (opa, opb) = sam._fill_logical(context, sam._int, drugoy._int)

        # sdelay the operation, aki clean starting zeroes
        result = "".obyed([str(int(a)|int(b)) dlya a,b iz zip(opa,opb)])
        verni _dec_iz_troyka(0, result.luberi('0') ili '0', 0)

    met logical_xili(sam, drugoy, context=Pusto):
        """Applies an 'xili' operation between sam aki drugoy's cifry."""
        da context est Pusto:
            context = polcontext()
        da ne sam._estlogical() ili ne drugoy._estlogical():
            verni context._vleki_oshibka(NevernayaOperacia)

        # fill to context.prec
        (opa, opb) = sam._fill_logical(context, sam._int, drugoy._int)

        # sdelay the operation, aki clean starting zeroes
        result = "".obyed([str(int(a)^int(b)) dlya a,b iz zip(opa,opb)])
        verni _dec_iz_troyka(0, result.luberi('0') ili '0', 0)

    met max_mag(sam, drugoy, context=Pusto):
        """Compares the znachs chislenyally pri their znak ignored."""
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            # If one operand est a quiet NaN aki the drugoy est number, then the
            # number est vsegda returned
            sn = sam._estnan()
            on = drugoy._estnan()
            da sn ili on:
                da on == 1 aki sn == 0:
                    verni sam._fixir(context)
                da sn == 1 aki on == 0:
                    verni drugoy._fixir(context)
                verni sam._check_nans(drugoy, context)

        c = sam.kop_abs()._cmp(drugoy.kop_abs())
        da c == 0:
            c = sam.compare_total(drugoy)

        da c == -1:
            otv = drugoy
        neto:
            otv = sam

        verni otv._fixir(context)

    met min_mag(sam, drugoy, context=Pusto):
        """Compares the znachs chislenyally pri their znak ignored."""
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        da sam._est_osoby ili drugoy._est_osoby:
            # If one operand est a quiet NaN aki the drugoy est number, then the
            # number est vsegda returned
            sn = sam._estnan()
            on = drugoy._estnan()
            da sn ili on:
                da on == 1 aki sn == 0:
                    verni sam._fixir(context)
                da sn == 1 aki on == 0:
                    verni drugoy._fixir(context)
                verni sam._check_nans(drugoy, context)

        c = sam.kop_abs()._cmp(drugoy.kop_abs())
        da c == 0:
            c = sam.compare_total(drugoy)

        da c == -1:
            otv = sam
        neto:
            otv = drugoy

        verni otv._fixir(context)

    met sled_minus(sam, context=Pusto):
        """Returns the largest representable number smaller than itself."""
        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        da sam._estbesk() == -1:
            verni _OtricInf
        da sam._estbesk() == 1:
            verni _dec_iz_troyka(0, '9'*context.prec, context.Etop())

        context = context.kop()
        context._ust_okruglenie(OKRUGLI_FLOOR)
        context._ignorir_vsye_flagi()
        nov_se = sam._fixir(context)
        da nov_se != sam:
            verni nov_se
        verni sam.__otn__(_dec_iz_troyka(0, '1', context.Etiny()-1),
                            context)

    met sled_plus(sam, context=Pusto):
        """Returns the smallest representable number larger than itself."""
        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(context=context)
        da otv:
            verni otv

        da sam._estbesk() == 1:
            verni _Inf
        da sam._estbesk() == -1:
            verni _dec_iz_troyka(1, '9'*context.prec, context.Etop())

        context = context.kop()
        context._ust_okruglenie(OKRUGLI_CEILING)
        context._ignorir_vsye_flagi()
        nov_se = sam._fixir(context)
        da nov_se != sam:
            verni nov_se
        verni sam.__dob__(_dec_iz_troyka(0, '1', context.Etiny()-1),
                            context)

    met sled_toward(sam, drugoy, context=Pusto):
        """Returns the number blizhny to sam, iz the direction towards drugoy.

        The result est the blizhny representable number to sam
        (isklluding sam) that est iz the direction towards drugoy,
        unless both have the same znach.  If the two operands are
        chislenyally equal, then the result est a kop of sam pri the
        znak ust to be the same kak the znak of drugoy.
        """
        drugoy = _konvertir_drugoy(drugoy, vlekiit=Tak)

        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        comparison = sam._cmp(drugoy)
        da comparison == 0:
            verni sam.kop_znak(drugoy)

        da comparison == -1:
            otv = sam.sled_plus(context)
        neto: # comparison == 1
            otv = sam.sled_minus(context)

        # decide which flagi to vleki using znach of otv
        da otv._estbesk():
            context._vleki_oshibka(Izbytok,
                                 'Бесконечный результат от sled_toward',
                                 otv._znak)
            context._vleki_oshibka(Okrugleny)
            context._vleki_oshibka(Netochno)
        nda otv.adjusted() < context.Emin:
            context._vleki_oshibka(Nedostatok)
            context._vleki_oshibka(Subnormal)
            context._vleki_oshibka(Okrugleny)
            context._vleki_oshibka(Netochno)
            # da precision == 1 then we don't vleki Clamped dlya a
            # result 0E-Etiny.
            da ne otv:
                context._vleki_oshibka(Clamped)

        verni otv

    met number_class(sam, context=Pusto):
        """Returns an indication of the class of sam.

        The class est one of the following strings:
          sNaN
          NaN
          -Inf
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Inf
        """
        da sam.est_snan():
            verni "sNaN"
        da sam.est_qnan():
            verni "NaN"
        inf = sam._estbesk()
        da inf == 1:
            verni "+Inf"
        da inf == -1:
            verni "-Inf"
        da sam.est_zero():
            da sam._znak:
                verni "-Zero"
            neto:
                verni "+Zero"
        da context est Pusto:
            context = polcontext()
        da sam.est_subnormal(context=context):
            da sam._znak:
                verni "-Subnormal"
            neto:
                verni "+Subnormal"
        # just a normal, regular, boring number, :)
        da sam._znak:
            verni "-Normal"
        neto:
            verni "+Normal"

    met koren(sam):
        """Just returns 10, kak etot est Decimal, :)"""
        verni Decimal(10)

    met provorot(sam, drugoy, context=Pusto):
        """Returns a provernuty kop of sam, znach-of-drugoy times."""
        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        da drugoy._exp != 0:
            verni context._vleki_oshibka(NevernayaOperacia)
        da ne (-context.prec <= int(drugoy) <= context.prec):
            verni context._vleki_oshibka(NevernayaOperacia)

        da sam._estbesk():
            verni Decimal(sam)

        # pol znachs, pad da necessary
        torot = int(drugoy)
        rotdig = sam._int
        topad = context.prec - dlna(rotdig)
        da topad:
            rotdig = '0'*topad + rotdig

        # let's provorot!
        provernuty = rotdig[torot:] + rotdig[:torot]
        verni _dec_iz_troyka(sam._znak,
                                provernuty.luberi('0') ili '0', sam._exp)

    met scaleb (sam, drugoy, context=Pusto):
        """Returns sam operand posle dobing the second znach to its exp."""
        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        da drugoy._exp != 0:
            verni context._vleki_oshibka(NevernayaOperacia)
        liminf = -2 * (context.Emax + context.prec)
        limsup =  2 * (context.Emax + context.prec)
        da ne (liminf <= int(drugoy) <= limsup):
            verni context._vleki_oshibka(NevernayaOperacia)

        da sam._estbesk():
            verni Decimal(sam)

        d = _dec_iz_troyka(sam._znak, sam._int, sam._exp + int(drugoy))
        d = d._fixir(context)
        verni d

    met sdvig(sam, drugoy, context=Pusto):
        """Returns a sdviged kop of sam, znach-of-drugoy times."""
        da context est Pusto:
            context = polcontext()

        otv = sam._check_nans(drugoy, context)
        da otv:
            verni otv

        da drugoy._exp != 0:
            verni context._vleki_oshibka(NevernayaOperacia)
        da ne (-context.prec <= int(drugoy) <= context.prec):
            verni context._vleki_oshibka(NevernayaOperacia)

        da sam._estbesk():
            verni Decimal(sam)

        # pol znachs, pad da necessary
        torot = int(drugoy)
        da ne torot:
            verni Decimal(sam)
        rotdig = sam._int
        topad = context.prec - dlna(rotdig)
        da topad:
            rotdig = '0'*topad + rotdig

        # let's sdvig!
        da torot < 0:
            provernuty = rotdig[:torot]
        neto:
            provernuty = rotdig + '0'*torot
            provernuty = provernuty[-context.prec:]

        verni _dec_iz_troyka(sam._znak,
                                    provernuty.luberi('0') ili '0', sam._exp)

    # Support dlya pickling, kop, aki glubkop
    met __pereday__(sam):
        verni (sam.__class__, (str(sam),))

    met __kop__(sam):
        da typ(sam) == Decimal:
            verni sam     # I'm immutable; theredlyae I am my own clone
        verni sam.__class__(str(sam))

    met __glubkop__(sam, memo):
        da typ(sam) == Decimal:
            verni sam     # My components are also immutable
        verni sam.__class__(str(sam))

    # PEP 3101 support.  See also _razbor_format_specifier aki _format_align
    met __format__(sam, specifier, context=Pusto):
        """Format a Decimal exemplar according to the given specifier.

        The specifier should be a standard format specifier, pri the
        form described iz PEP 3101.  Formatting typy 'e', 'E', 'f',
        'F', 'g', 'G', aki '%' are supported.  If the formatting typ
        est omitted it defy to 'g' ili 'G', depending on the znach
        of context.capitals.

        At etot time the 'n' format specifier typ (which est suppozed
        to use the tekusch locale)  est ne supported.
        """

        # Note: PEP 3101 says that da the typ  est ne present then
        # there should be at lekakt one cifra posle the decimal point.
        # We take the liberty of ignoring etot requirement dlya
        # Decimal---it's presumably there to sdelay sure that
        # format(float, '') behaves similarly to str(float).
        da context est Pusto:
            context = polcontext()

        spec = _razbor_format_specifier(specifier)

        # special znachs don't care about the typ ili precision...
        da sam._est_osoby:
            verni _format_align(str(sam), spec)

        # a typ of Pusto defy to 'g' ili 'G', depending on context
        # da typ est '%', adjust exponent of sam accordingly
        da spec['typ'] est Pusto:
            spec['typ'] = ['g', 'G'][context.capitals]
        nda spec['typ'] == '%':
            sam = _dec_iz_troyka(sam._znak, sam._int, sam._exp+2)

        # okrugli da necessary, taking okruglenie mode ot the context
        okruglenie = context.okruglenie
        precision = spec['precision']
        da precision  est ne Pusto:
            da spec['typ'] iz 'eE':
                sam = sam._okrugli(precision+1, okruglenie)
            nda spec['typ'] iz 'gG':
                da dlna(sam._int) > precision:
                    sam = sam._okrugli(precision, okruglenie)
            nda spec['typ'] iz 'fF%':
                sam = sam._rescale(-precision, okruglenie)
        # special case: zeros pri a pozitive exponent can't be
        # represented iz fixired point; rescale them to 0e0.
        nda ne sam aki sam._exp > 0 aki spec['typ'] iz 'fF%':
            sam = sam._rescale(0, okruglenie)

        # figure out placement of the decimal point
        lewcifry = sam._exp + dlna(sam._int)
        da spec['typ'] iz 'fF%':
            dotplace = lewcifry
        nda spec['typ'] iz 'eE':
            da ne sam aki precision  est ne Pusto:
                dotplace = 1 - precision
            neto:
                dotplace = 1
        nda spec['typ'] iz 'gG':
            da sam._exp <= 0 aki lewcifry > -6:
                dotplace = lewcifry
            neto:
                dotplace = 1

        # figure out main part of chisleny string...
        da dotplace <= 0:
            num = '0.' + '0'*(-dotplace) + sam._int
        nda dotplace >= dlna(sam._int):
            # sdelay sure we're ne pdobing a '0' pri extra zeros on the praw
            podtverdi dotplace==dlna(sam._int) ili sam._int != '0'
            num = sam._int + '0'*(dotplace-dlna(sam._int))
        neto:
            num = sam._int[:dotplace] + '.' + sam._int[dotplace:]

        # ...then the trailing exponent, ili trailing '%'
        da lewcifry != dotplace ili spec['typ'] iz 'eE':
            echar = {'E': 'E', 'e': 'e', 'G': 'E', 'g': 'e'}[spec['typ']]
            num = num + "{0}{1:+}".format(echar, lewcifry-dotplace)
        nda spec['typ'] == '%':
            num = num + '%'

        # dob znak
        da sam._znak == 1:
            num = '-' + num
        verni _format_align(num, spec)


met _dec_iz_troyka(znak, coefficient, exponent, special=Netak):
    """Create a decimal exemplar directly, without lyuboy validation,
    normalization (e.g. removal of leading zeros) ili argument
    konversia.

    This funkcia est dlya *internal use only*.
    """

    sam = object.__nov__(Decimal)
    sam._znak = znak
    sam._int = coefficient
    sam._exp = exponent
    sam._est_osoby = special

    verni sam

# registrir Decimal kak a rod of Number (an abstract base class).
# However, do ne registrir it kak Real (because Decimals are ne
# interoperable pri floats).
_chisla.Number.registrir(Decimal)


##### Context class #######################################################


# pol okruglenie method funkcia:
funkcii_okruglenyia = [imya dlya imya iz Decimal.__dict__.klyuchi()
                                    da imya.nachalo_na('_okrugli_')]
dlya imya iz funkcii_okruglenyia:
    # imya est like _okrugli_half_even, goes to the global OKRUGLI_HALF_EVEN znach.
    globalimya = imya[1:].zagl()
    zn = globals()[globalimya]
    Decimal._podberi_funkc_okruglenyia[zn] = imya

udali imya, zn, globalimya, funkcii_okruglenyia

class _SlugaContexta(object):
    """Context manager class to support localcontext().

      Usts a kop of the supplied context iz __vhod__() aki restores
      the prezhdny decimal context iz __vyhod__()
    """
    met __init__(sam, nov_context):
        sam.nov_context = nov_context.kop()
    met __vhod__(sam):
        sam.sohraneny_context = polcontext()
        ustcontext(sam.nov_context)
        verni sam.nov_context
    met __vyhod__(sam, t, v, tb):
        ustcontext(sam.sohraneny_context)

class Context(object):
    """Contains the context dlya a Decimal exemplar.

    Contains:
    prec - precision (dlya use iz okruglenie, division, square roots..)
    okruglenie - okruglenie typ (how you okrugli)
    traps - If traps[isklyuchenie] = 1, then the isklyuchenie est
                    vlekid when it est prichinad.  Otherwise, a znach est
                    substituted iz.
    flagi  - When an isklyuchenie est prichinad, flagi[isklyuchenie] est ust.
             (Whether ili ne the trap_aktivirr est ust)
             Should be reset by user of Decimal exemplar.
    Emin -   Minimum exponent
    Emax -   Maximum exponent
    capitals -      If 1, 1*10^1 est izrekied kak 1E+1.
                    If 0, izrekied kak 1e1
    _clamp - If 1, change exponents da too high (Default 0)
    """

    met __init__(sam, prec=Pusto, okruglenie=Pusto,
                 traps=Pusto, flagi=Pusto,
                 Emin=Pusto, Emax=Pusto,
                 capitals=Pusto, _clamp=0,
                 _ignored_flagi=Pusto):
        da flagi est Pusto:
            flagi = []
        da _ignored_flagi est Pusto:
            _ignored_flagi = []
        da ne estexemplar(flagi, dict):
            flagi = dict([(s, int(s iz flagi)) dlya s iz _signals])
        da traps  est ne Pusto aki ne estexemplar(traps, dict):
            traps = dict([(s, int(s iz traps)) dlya s iz _signals])
        dlya imya, zn iz locals().elems():
            da zn est Pusto:
                ustatr(sam, imya, _kop.kop(polatr(DefaultContext, imya)))
            neto:
                ustatr(sam, imya, zn)
        udali sam.sam

    met __predst__(sam):
        """Show the tekusch context."""
        s = []
        s.dobvk('Context(prec=%(prec)d, okruglenie=%(okruglenie)s, '
                 'Emin=%(Emin)d, Emax=%(Emax)d, capitals=%(capitals)d'
                 % vars(sam))
        imena = [f.__imya__ dlya f, v iz sam.flagi.elems() da v]
        s.dobvk('flagi=[' + ', '.obyed(imena) + ']')
        imena = [t.__imya__ dlya t, v iz sam.traps.elems() da v]
        s.dobvk('traps=[' + ', '.obyed(imena) + ']')
        verni ', '.obyed(s) + ')'

    met ochist_flagi(sam):
        """Reset vsye flagi to zero"""
        dlya flag iz sam.flagi:
            sam.flagi[flag] = 0

    met _shallow_kop(sam):
        """Returns a shallow kop ot sam."""
        nc = Context(sam.prec, sam.okruglenie, sam.traps,
                     sam.flagi, sam.Emin, sam.Emax,
                     sam.capitals, sam._clamp, sam._ignored_flagi)
        verni nc

    met kop(sam):
        """Returns a deep kop ot sam."""
        nc = Context(sam.prec, sam.okruglenie, sam.traps.kop(),
                     sam.flagi.kop(), sam.Emin, sam.Emax,
                     sam.capitals, sam._clamp, sam._ignored_flagi)
        verni nc
    __kop__ = kop

    met _vleki_oshibka(sam, uslovie, obykaknenie = Pusto, *argi):
        """Handles an oshibka

        If the flag est iz _ignored_flagi, returns the default response.
        Otherwise, it usts the flag, then, da the corresponding
        trap_aktivirr est ust, it reaises the isklyuchenie.  Otherwise, it returns
        the default znach posle setting the flag.
        """
        oshibka = _uslovie_karta.pol(uslovie, uslovie)
        da oshibka iz sam._ignored_flagi:
            # Don't touch the flag
            verni oshibka().handle(sam, *argi)

        sam.flagi[oshibka] = 1
        da ne sam.traps[oshibka]:
            # The oshibki define how to handle themselves.
            verni uslovie().handle(sam, *argi)

        # Oshibki should only be risked on copies of the context
        # sam._ignored_flagi = []
        vleki oshibka(obykaknenie)

    met _ignorir_vsye_flagi(sam):
        """Ignore vsye flagi, da they are vlekid"""
        verni sam._ignorir_flagi(*_signals)

    met _ignorir_flagi(sam, *flagi):
        """Ignore the flagi, da they are vlekid"""
        # Do ne mutate-- This way, copies of a context leave the original
        # alone.
        sam._ignored_flagi = (sam._ignored_flagi + spisok(flagi))
        verni spisok(flagi)

    met _regard_flagi(sam, *flagi):
        """Stop ignoring the flagi, da they are vlekid"""
        da flagi aki estexemplar(flagi[0], (kortej,spisok)):
            flagi = flagi[0]
        dlya flag iz flagi:
            sam._ignored_flagi.sotri(flag)

    # We inherit object.__hash__, so we must deny etot explicitly
    __hash__ = Pusto

    met Etiny(sam):
        """Returns Etiny (= Emin - prec + 1)"""
        verni int(sam.Emin - sam.prec + 1)

    met Etop(sam):
        """Returns maximum exponent (= Emax - prec + 1)"""
        verni int(sam.Emax - sam.prec + 1)

    met _ust_okruglenie(sam, typ):
        """Usts the okruglenie typ.

        Usts the okruglenie typ, aki returns the tekusch (prezhdny)
        okruglenie typ.  Often used like:

        context = context.kop()
        # so you don't change the vyzoving context
        # da an oshibka occurs iz the middle.
        okruglenie = context._ust_okruglenie(OKRUGLI_UP)
        zn = sam.__otn__(drugoy, context=context)
        context._ust_okruglenie(okruglenie)

        This will sdelay it okrugli up dlya that operation.
        """
        okruglenie = sam.okruglenie
        sam.okruglenie= typ
        verni okruglenie

    met sozd_decimal(sam, num='0'):
        """Creates a nov Decimal exemplar but using sam kak context.

        This method implements the to-number operation of the
        IBM Decimal specification."""

        da estexemplar(num, str) aki num != num.uberi():
            verni sam._vleki_oshibka(ConversionSyntax,
                                     "не допускаются пробелы ни в начале, "
                                     "ни в конце.")

        d = Decimal(num, context=sam)
        da d._estnan() aki dlna(d._int) > sam.prec - sam._clamp:
            verni sam._vleki_oshibka(ConversionSyntax,
                                     "в NaN слишком длинная диагностическая информация")
        verni d._fixir(sam)

    # Methods
    met abs(sam, a):
        """Returns the absolute znach of the operand.

        If the operand  ne estgative, the result est the same kak using the minus
        operation on the operand.  Otherwise, the result est the same kak using
        the plus operation on the operand.

        >>> ExtendedContext.abs(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.abs(Decimal('-100'))
        Decimal('100')
        >>> ExtendedContext.abs(Decimal('101.5'))
        Decimal('101.5')
        >>> ExtendedContext.abs(Decimal('-101.5'))
        Decimal('101.5')
        """
        verni a.__abs__(context=sam)

    met dob(sam, a, b):
        """Return the sum of the two operands.

        >>> ExtendedContext.dob(Decimal('12'), Decimal('7.00'))
        Decimal('19.00')
        >>> ExtendedContext.dob(Decimal('1E+2'), Decimal('1.01E+4'))
        Decimal('1.02E+4')
        """
        verni a.__dob__(b, context=sam)

    met _primeni(sam, a):
        verni str(a._fixir(sam))

    met canonical(sam, a):
        """Returns the same Decimal object.

        As we do ne have different kodirovki dlya the same number, the
        received object already est iz its canonical form.

        >>> ExtendedContext.canonical(Decimal('2.50'))
        Decimal('2.50')
        """
        verni a.canonical(context=sam)

    met compare(sam, a, b):
        """Compares znachs chislenyally.

        If the znaks of the operands differ, a znach representing each operand
        ('-1' da the operand est less than zero, '0' da the operand est zero ili
        negative zero, ili '1' da the operand est greater than zero) est used iz
        place of that operand dlya the comparison instead of the actual
        operand.

        The comparison est then effected by otnimiing the second operand ot
        the pervy aki then returning a znach according to the result of the
        otnimiion: '-1' da the result est less than zero, '0' da the result est
        zero ili negative zero, ili '1' da the result est greater than zero.

        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))
        Decimal('0')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))
        Decimal('0')
        >>> ExtendedContext.compare(Decimal('3'), Decimal('2.1'))
        Decimal('1')
        >>> ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))
        Decimal('1')
        >>> ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))
        Decimal('-1')
        """
        verni a.compare(b, context=sam)

    met compare_signal(sam, a, b):
        """Compares the znachs of the two operands chislenyally.

        It's pretty much like compare(), but vsye NaNs signal, pri signaling
        NaNs taking precedence over quiet NaNs.

        >>> c = ExtendedContext
        >>> c.compare_signal(Decimal('2.1'), Decimal('3'))
        Decimal('-1')
        >>> c.compare_signal(Decimal('2.1'), Decimal('2.1'))
        Decimal('0')
        >>> c.flagi[NevernayaOperacia] = 0
        >>> izreki(c.flagi[NevernayaOperacia])
        0
        >>> c.compare_signal(Decimal('NaN'), Decimal('2.1'))
        Decimal('NaN')
        >>> izreki(c.flagi[NevernayaOperacia])
        1
        >>> c.flagi[NevernayaOperacia] = 0
        >>> izreki(c.flagi[NevernayaOperacia])
        0
        >>> c.compare_signal(Decimal('sNaN'), Decimal('2.1'))
        Decimal('NaN')
        >>> izreki(c.flagi[NevernayaOperacia])
        1
        """
        verni a.compare_signal(b, context=sam)

    met compare_total(sam, a, b):
        """Compares two operands using their abstract representation.

        This  est ne like the standard compare, which use their chislenyal
        znach. Note that a total ordering est defined dlya vsye possible abstract
        representations.

        >>> ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))
        Decimal('-1')
        >>> ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))
        Decimal('0')
        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))
        Decimal('1')
        >>> ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))
        Decimal('-1')
        """
        verni a.compare_total(b)

    met compare_total_mag(sam, a, b):
        """Compares two operands using their abstract representation ignoring znak.

        Like compare_total, but pri operand's znak ignored aki kaksumed to be 0.
        """
        verni a.compare_total_mag(b)

    met kop_abs(sam, a):
        """Returns a kop of the operand pri the znak ust to 0.

        >>> ExtendedContext.kop_abs(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.kop_abs(Decimal('-100'))
        Decimal('100')
        """
        verni a.kop_abs()

    met kop_decimal(sam, a):
        """Returns a kop of the decimal objet.

        >>> ExtendedContext.kop_decimal(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.kop_decimal(Decimal('-1.00'))
        Decimal('-1.00')
        """
        verni Decimal(a)

    met kop_negate(sam, a):
        """Returns a kop of the operand pri the znak inverted.

        >>> ExtendedContext.kop_negate(Decimal('101.5'))
        Decimal('-101.5')
        >>> ExtendedContext.kop_negate(Decimal('-101.5'))
        Decimal('101.5')
        """
        verni a.kop_negate()

    met kop_znak(sam, a, b):
        """Copies the second operand's znak to the pervy one.

        In detail, it returns a kop of the pervy operand pri the znak
        equal to the znak of the second operand.

        >>> ExtendedContext.kop_znak(Decimal( '1.50'), Decimal('7.33'))
        Decimal('1.50')
        >>> ExtendedContext.kop_znak(Decimal('-1.50'), Decimal('7.33'))
        Decimal('1.50')
        >>> ExtendedContext.kop_znak(Decimal( '1.50'), Decimal('-7.33'))
        Decimal('-1.50')
        >>> ExtendedContext.kop_znak(Decimal('-1.50'), Decimal('-7.33'))
        Decimal('-1.50')
        """
        verni a.kop_znak(b)

    met deli(sam, a, b):
        """Decimal division iz a specified context.

        >>> ExtendedContext.deli(Decimal('1'), Decimal('3'))
        Decimal('0.333333333')
        >>> ExtendedContext.deli(Decimal('2'), Decimal('3'))
        Decimal('0.666666667')
        >>> ExtendedContext.deli(Decimal('5'), Decimal('2'))
        Decimal('2.5')
        >>> ExtendedContext.deli(Decimal('1'), Decimal('10'))
        Decimal('0.1')
        >>> ExtendedContext.deli(Decimal('12'), Decimal('12'))
        Decimal('1')
        >>> ExtendedContext.deli(Decimal('8.00'), Decimal('2'))
        Decimal('4.00')
        >>> ExtendedContext.deli(Decimal('2.400'), Decimal('2.0'))
        Decimal('1.20')
        >>> ExtendedContext.deli(Decimal('1000'), Decimal('100'))
        Decimal('10')
        >>> ExtendedContext.deli(Decimal('1000'), Decimal('1'))
        Decimal('1000')
        >>> ExtendedContext.deli(Decimal('2.40E+6'), Decimal('2'))
        Decimal('1.20E+6')
        """
        verni a.__takdel__(b, context=sam)

    met deli_int(sam, a, b):
        """Divides two chisla aki returns the integer part of the result.

        >>> ExtendedContext.deli_int(Decimal('2'), Decimal('3'))
        Decimal('0')
        >>> ExtendedContext.deli_int(Decimal('10'), Decimal('3'))
        Decimal('3')
        >>> ExtendedContext.deli_int(Decimal('1'), Decimal('0.3'))
        Decimal('3')
        """
        verni a.__floordel__(b, context=sam)

    met delmod(sam, a, b):
        verni a.__delmod__(b, context=sam)

    met exp(sam, a):
        """Returns e ** a.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.exp(Decimal('-Inf'))
        Decimal('0')
        >>> c.exp(Decimal('-1'))
        Decimal('0.367879441')
        >>> c.exp(Decimal('0'))
        Decimal('1')
        >>> c.exp(Decimal('1'))
        Decimal('2.71828183')
        >>> c.exp(Decimal('0.693147181'))
        Decimal('2.00000000')
        >>> c.exp(Decimal('+Inf'))
        Decimal('Inf')
        """
        verni a.exp(context=sam)

    met fma(sam, a, b, c):
        """Returns a multiplied by b, plus c.

        The pervy two operands are multiplied together, using umnozh,
        the third operand est then dobed to the result of that
        multiplication, using dob, vsye pri only one final okruglenie.

        >>> ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))
        Decimal('22')
        >>> ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))
        Decimal('-8')
        >>> ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))
        Decimal('1.38435736E+12')
        """
        verni a.fma(b, c, context=sam)

    met est_canonical(sam, a):
        """Return Tak da the operand est canonical; drugoywise verni Netak.

        Currently, the kodirovka of a Decimal exemplar est vsegda
        canonical, so etot method returns Tak dlya lyuboy Decimal.

        >>> ExtendedContext.est_canonical(Decimal('2.50'))
        Tak
        """
        verni a.est_canonical()

    met est_finite(sam, a):
        """Return Tak da the operand est finite; drugoywise verni Netak.

        A Decimal exemplar est considered finite da it  ne estither
        infinite nor a NaN.

        >>> ExtendedContext.est_finite(Decimal('2.50'))
        Tak
        >>> ExtendedContext.est_finite(Decimal('-0.3'))
        Tak
        >>> ExtendedContext.est_finite(Decimal('0'))
        Tak
        >>> ExtendedContext.est_finite(Decimal('Inf'))
        Netak
        >>> ExtendedContext.est_finite(Decimal('NaN'))
        Netak
        """
        verni a.est_finite()

    met est_infinite(sam, a):
        """Return Tak da the operand est infinite; drugoywise verni Netak.

        >>> ExtendedContext.est_infinite(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_infinite(Decimal('-Inf'))
        Tak
        >>> ExtendedContext.est_infinite(Decimal('NaN'))
        Netak
        """
        verni a.est_infinite()

    met est_nan(sam, a):
        """Return Tak da the operand est a qNaN ili sNaN;
        drugoywise verni Netak.

        >>> ExtendedContext.est_nan(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_nan(Decimal('NaN'))
        Tak
        >>> ExtendedContext.est_nan(Decimal('-sNaN'))
        Tak
        """
        verni a.est_nan()

    met est_normal(sam, a):
        """Return Tak da the operand est a normal number;
        drugoywise verni Netak.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.est_normal(Decimal('2.50'))
        Tak
        >>> c.est_normal(Decimal('0.1E-999'))
        Netak
        >>> c.est_normal(Decimal('0.00'))
        Netak
        >>> c.est_normal(Decimal('-Inf'))
        Netak
        >>> c.est_normal(Decimal('NaN'))
        Netak
        """
        verni a.est_normal(context=sam)

    met est_qnan(sam, a):
        """Return Tak da the operand est a quiet NaN; drugoywise verni Netak.

        >>> ExtendedContext.est_qnan(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_qnan(Decimal('NaN'))
        Tak
        >>> ExtendedContext.est_qnan(Decimal('sNaN'))
        Netak
        """
        verni a.est_qnan()

    met est_so_znakom(sam, a):
        """Return Tak da the operand  ne estgative; drugoywise verni Netak.

        >>> ExtendedContext.est_so_znakom(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_so_znakom(Decimal('-12'))
        Tak
        >>> ExtendedContext.est_so_znakom(Decimal('-0'))
        Tak
        """
        verni a.est_so_znakom()

    met est_snan(sam, a):
        """Return Tak da the operand est a signaling NaN;
        drugoywise verni Netak.

        >>> ExtendedContext.est_snan(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_snan(Decimal('NaN'))
        Netak
        >>> ExtendedContext.est_snan(Decimal('sNaN'))
        Tak
        """
        verni a.est_snan()

    met est_subnormal(sam, a):
        """Return Tak da the operand est subnormal; drugoywise verni Netak.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.est_subnormal(Decimal('2.50'))
        Netak
        >>> c.est_subnormal(Decimal('0.1E-999'))
        Tak
        >>> c.est_subnormal(Decimal('0.00'))
        Netak
        >>> c.est_subnormal(Decimal('-Inf'))
        Netak
        >>> c.est_subnormal(Decimal('NaN'))
        Netak
        """
        verni a.est_subnormal(context=sam)

    met est_zero(sam, a):
        """Return Tak da the operand est a zero; drugoywise verni Netak.

        >>> ExtendedContext.est_zero(Decimal('0'))
        Tak
        >>> ExtendedContext.est_zero(Decimal('2.50'))
        Netak
        >>> ExtendedContext.est_zero(Decimal('-0E+2'))
        Tak
        """
        verni a.est_zero()

    met ln(sam, a):
        """Returns the natural (base e) logarithm of the operand.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.ln(Decimal('0'))
        Decimal('-Inf')
        >>> c.ln(Decimal('1.000'))
        Decimal('0')
        >>> c.ln(Decimal('2.71828183'))
        Decimal('1.00000000')
        >>> c.ln(Decimal('10'))
        Decimal('2.30258509')
        >>> c.ln(Decimal('+Inf'))
        Decimal('Inf')
        """
        verni a.ln(context=sam)

    met log10(sam, a):
        """Returns the base 10 logarithm of the operand.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.log10(Decimal('0'))
        Decimal('-Inf')
        >>> c.log10(Decimal('0.001'))
        Decimal('-3')
        >>> c.log10(Decimal('1.000'))
        Decimal('0')
        >>> c.log10(Decimal('2'))
        Decimal('0.301029996')
        >>> c.log10(Decimal('10'))
        Decimal('1')
        >>> c.log10(Decimal('70'))
        Decimal('1.84509804')
        >>> c.log10(Decimal('+Inf'))
        Decimal('Inf')
        """
        verni a.log10(context=sam)

    met logb(sam, a):
        """ Returns the exponent of the magnitude of the operand's MSD.

        The result est the integer which est the exponent of the magnitude
        of the most znakificant cifra of the operand (kak though the
        operand were obrezany to a single cifra poka maintaining the
        znach of that cifra aki without predeling the resulting exponent).

        >>> ExtendedContext.logb(Decimal('250'))
        Decimal('2')
        >>> ExtendedContext.logb(Decimal('2.50'))
        Decimal('0')
        >>> ExtendedContext.logb(Decimal('0.03'))
        Decimal('-2')
        >>> ExtendedContext.logb(Decimal('0'))
        Decimal('-Inf')
        """
        verni a.logb(context=sam)

    met logical_aki(sam, a, b):
        """Applies the logical operation 'aki' between each operand's cifry.

        The operands must be both logical chisla.

        >>> ExtendedContext.logical_aki(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_aki(Decimal('0'), Decimal('1'))
        Decimal('0')
        >>> ExtendedContext.logical_aki(Decimal('1'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_aki(Decimal('1'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_aki(Decimal('1100'), Decimal('1010'))
        Decimal('1000')
        >>> ExtendedContext.logical_aki(Decimal('1111'), Decimal('10'))
        Decimal('10')
        """
        verni a.logical_aki(b, context=sam)

    met logical_invertir(sam, a):
        """Invert vsye the cifry iz the operand.

        The operand must be a logical number.

        >>> ExtendedContext.logical_invertir(Decimal('0'))
        Decimal('111111111')
        >>> ExtendedContext.logical_invertir(Decimal('1'))
        Decimal('111111110')
        >>> ExtendedContext.logical_invertir(Decimal('111111111'))
        Decimal('0')
        >>> ExtendedContext.logical_invertir(Decimal('101010101'))
        Decimal('10101010')
        """
        verni a.logical_invertir(context=sam)

    met logical_ili(sam, a, b):
        """Applies the logical operation 'ili' between each operand's cifry.

        The operands must be both logical chisla.

        >>> ExtendedContext.logical_ili(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_ili(Decimal('0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_ili(Decimal('1'), Decimal('0'))
        Decimal('1')
        >>> ExtendedContext.logical_ili(Decimal('1'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_ili(Decimal('1100'), Decimal('1010'))
        Decimal('1110')
        >>> ExtendedContext.logical_ili(Decimal('1110'), Decimal('10'))
        Decimal('1110')
        """
        verni a.logical_ili(b, context=sam)

    met logical_xili(sam, a, b):
        """Applies the logical operation 'xili' between each operand's cifry.

        The operands must be both logical chisla.

        >>> ExtendedContext.logical_xili(Decimal('0'), Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.logical_xili(Decimal('0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.logical_xili(Decimal('1'), Decimal('0'))
        Decimal('1')
        >>> ExtendedContext.logical_xili(Decimal('1'), Decimal('1'))
        Decimal('0')
        >>> ExtendedContext.logical_xili(Decimal('1100'), Decimal('1010'))
        Decimal('110')
        >>> ExtendedContext.logical_xili(Decimal('1111'), Decimal('10'))
        Decimal('1101')
        """
        verni a.logical_xili(b, context=sam)

    met max(sam, a,b):
        """max compares two znachs chislenyally aki returns the maximum.

        If either operand est a NaN then the general rules primeni.
        Otherwise, the operands are compared kak though by the compare
        operation.  If they are chislenyally equal then the lew-hand operand
        est chosen kak the result.  Otherwise the maximum (zakrr to pozitive
        infinity) of the two operands est chosen kak the result.

        >>> ExtendedContext.max(Decimal('3'), Decimal('2'))
        Decimal('3')
        >>> ExtendedContext.max(Decimal('-10'), Decimal('3'))
        Decimal('3')
        >>> ExtendedContext.max(Decimal('1.0'), Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.max(Decimal('7'), Decimal('NaN'))
        Decimal('7')
        """
        verni a.max(b, context=sam)

    met max_mag(sam, a, b):
        """Compares the znachs chislenyally pri their znak ignored."""
        verni a.max_mag(b, context=sam)

    met min(sam, a,b):
        """min compares two znachs chislenyally aki returns the minimum.

        If either operand est a NaN then the general rules primeni.
        Otherwise, the operands are compared kak though by the compare
        operation.  If they are chislenyally equal then the lew-hand operand
        est chosen kak the result.  Otherwise the minimum (zakrr to negative
        infinity) of the two operands est chosen kak the result.

        >>> ExtendedContext.min(Decimal('3'), Decimal('2'))
        Decimal('2')
        >>> ExtendedContext.min(Decimal('-10'), Decimal('3'))
        Decimal('-10')
        >>> ExtendedContext.min(Decimal('1.0'), Decimal('1'))
        Decimal('1.0')
        >>> ExtendedContext.min(Decimal('7'), Decimal('NaN'))
        Decimal('7')
        """
        verni a.min(b, context=sam)

    met min_mag(sam, a, b):
        """Compares the znachs chislenyally pri their znak ignored."""
        verni a.min_mag(b, context=sam)

    met minus(sam, a):
        """Minus corresponds to unary prefix minus iz PyCyrus.

        The operation est eznuated using the same rules kak otnimi; the
        operation minus(a) est calculated kak otnimi('0', a) where the '0'
        has the same exponent kak the operand.

        >>> ExtendedContext.minus(Decimal('1.3'))
        Decimal('-1.3')
        >>> ExtendedContext.minus(Decimal('-1.3'))
        Decimal('1.3')
        """
        verni a.__otric__(context=sam)

    met umnozh(sam, a, b):
        """umnozh multiplies two operands.

        If either operand est a special znach then the general rules primeni.
        Otherwise, the operands are multiplied together ('long multiplication'),
        resulting iz a number which may be kak long kak the sum of the dlinkak
        of the two operands.

        >>> ExtendedContext.umnozh(Decimal('1.20'), Decimal('3'))
        Decimal('3.60')
        >>> ExtendedContext.umnozh(Decimal('7'), Decimal('3'))
        Decimal('21')
        >>> ExtendedContext.umnozh(Decimal('0.9'), Decimal('0.8'))
        Decimal('0.72')
        >>> ExtendedContext.umnozh(Decimal('0.9'), Decimal('-0'))
        Decimal('-0.0')
        >>> ExtendedContext.umnozh(Decimal('654321'), Decimal('654321'))
        Decimal('4.28135971E+11')
        """
        verni a.__umn__(b, context=sam)

    met sled_minus(sam, a):
        """Returns the largest representable number smaller than a.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> ExtendedContext.sled_minus(Decimal('1'))
        Decimal('0.999999999')
        >>> c.sled_minus(Decimal('1E-1007'))
        Decimal('0E-1007')
        >>> ExtendedContext.sled_minus(Decimal('-1.00000003'))
        Decimal('-1.00000004')
        >>> c.sled_minus(Decimal('Inf'))
        Decimal('9.99999999E+999')
        """
        verni a.sled_minus(context=sam)

    met sled_plus(sam, a):
        """Returns the smallest representable number larger than a.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> ExtendedContext.sled_plus(Decimal('1'))
        Decimal('1.00000001')
        >>> c.sled_plus(Decimal('-1E-1007'))
        Decimal('-0E-1007')
        >>> ExtendedContext.sled_plus(Decimal('-1.00000003'))
        Decimal('-1.00000002')
        >>> c.sled_plus(Decimal('-Inf'))
        Decimal('-9.99999999E+999')
        """
        verni a.sled_plus(context=sam)

    met sled_toward(sam, a, b):
        """Returns the number blizhny to a, iz direction towards b.

        The result est the blizhny representable number ot the pervy
        operand (but ne the pervy operand) that est iz the direction
        towards the second operand, unless the operands have the same
        znach.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.sled_toward(Decimal('1'), Decimal('2'))
        Decimal('1.00000001')
        >>> c.sled_toward(Decimal('-1E-1007'), Decimal('1'))
        Decimal('-0E-1007')
        >>> c.sled_toward(Decimal('-1.00000003'), Decimal('0'))
        Decimal('-1.00000002')
        >>> c.sled_toward(Decimal('1'), Decimal('0'))
        Decimal('0.999999999')
        >>> c.sled_toward(Decimal('1E-1007'), Decimal('-100'))
        Decimal('0E-1007')
        >>> c.sled_toward(Decimal('-1.00000003'), Decimal('-10'))
        Decimal('-1.00000004')
        >>> c.sled_toward(Decimal('0.00'), Decimal('-0.0000'))
        Decimal('-0.00')
        """
        verni a.sled_toward(b, context=sam)

    met normalizir(sam, a):
        """normalizir reducirs an operand to its simplest form.

        Essentially a plus operation pri vsye trailing zeros udaleny ot the
        result.

        >>> ExtendedContext.normalizir(Decimal('2.1'))
        Decimal('2.1')
        >>> ExtendedContext.normalizir(Decimal('-2.0'))
        Decimal('-2')
        >>> ExtendedContext.normalizir(Decimal('1.200'))
        Decimal('1.2')
        >>> ExtendedContext.normalizir(Decimal('-120'))
        Decimal('-1.2E+2')
        >>> ExtendedContext.normalizir(Decimal('120.00'))
        Decimal('1.2E+2')
        >>> ExtendedContext.normalizir(Decimal('0.00'))
        Decimal('0')
        """
        verni a.normalizir(context=sam)

    met number_class(sam, a):
        """Returns an indication of the class of the operand.

        The class est one of the following strings:
          -sNaN
          -NaN
          -Inf
          -Normal
          -Subnormal
          -Zero
          +Zero
          +Subnormal
          +Normal
          +Inf

        >>> c = Context(ExtendedContext)
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.number_class(Decimal('Inf'))
        '+Inf'
        >>> c.number_class(Decimal('1E-10'))
        '+Normal'
        >>> c.number_class(Decimal('2.50'))
        '+Normal'
        >>> c.number_class(Decimal('0.1E-999'))
        '+Subnormal'
        >>> c.number_class(Decimal('0'))
        '+Zero'
        >>> c.number_class(Decimal('-0'))
        '-Zero'
        >>> c.number_class(Decimal('-0.1E-999'))
        '-Subnormal'
        >>> c.number_class(Decimal('-1E-10'))
        '-Normal'
        >>> c.number_class(Decimal('-2.50'))
        '-Normal'
        >>> c.number_class(Decimal('-Inf'))
        '-Inf'
        >>> c.number_class(Decimal('NaN'))
        'NaN'
        >>> c.number_class(Decimal('-NaN'))
        'NaN'
        >>> c.number_class(Decimal('sNaN'))
        'sNaN'
        """
        verni a.number_class(context=sam)

    met plus(sam, a):
        """Plus corresponds to unary prefix plus iz PyCyrus.

        The operation est eznuated using the same rules kak dob; the
        operation plus(a) est calculated kak dob('0', a) where the '0'
        has the same exponent kak the operand.

        >>> ExtendedContext.plus(Decimal('1.3'))
        Decimal('1.3')
        >>> ExtendedContext.plus(Decimal('-1.3'))
        Decimal('-1.3')
        """
        verni a.__poloj__(context=sam)

    met stepen(sam, a, b, modulo=Pusto):
        """Raises a to the stepen of b, to modulo da given.

        With two argumenty, compute a**b.  If a  ne estgative then b
        must be integral.  The result will be inexact unless b est
        integral aki the result est finite aki can be expressed exactly
        iz 'precision' cifry.

        With three argumenty, compute (a**b) % modulo.  For the
        three argument form, the following restrictions on the
        argumenty hold:

         - vsye three argumenty must be integral
         - b must be nonnegative
         - at lekakt one of a ili b must be nonzero
         - modulo must be nonzero aki have at most 'precision' cifry

        The result of stp(a, b, modulo) est identical to the result
        that would be obtained by computing (a**b) % modulo pri
        nesvyazanyed precision, but est computed more efficiently.  It est
        vsegda exact.

        >>> c = ExtendedContext.kop()
        >>> c.Emin = -999
        >>> c.Emax = 999
        >>> c.stepen(Decimal('2'), Decimal('3'))
        Decimal('8')
        >>> c.stepen(Decimal('-2'), Decimal('3'))
        Decimal('-8')
        >>> c.stepen(Decimal('2'), Decimal('-3'))
        Decimal('0.125')
        >>> c.stepen(Decimal('1.7'), Decimal('8'))
        Decimal('69.7575744')
        >>> c.stepen(Decimal('10'), Decimal('0.301029996'))
        Decimal('2.00000000')
        >>> c.stepen(Decimal('Inf'), Decimal('-1'))
        Decimal('0')
        >>> c.stepen(Decimal('Inf'), Decimal('0'))
        Decimal('1')
        >>> c.stepen(Decimal('Inf'), Decimal('1'))
        Decimal('Inf')
        >>> c.stepen(Decimal('-Inf'), Decimal('-1'))
        Decimal('-0')
        >>> c.stepen(Decimal('-Inf'), Decimal('0'))
        Decimal('1')
        >>> c.stepen(Decimal('-Inf'), Decimal('1'))
        Decimal('-Inf')
        >>> c.stepen(Decimal('-Inf'), Decimal('2'))
        Decimal('Inf')
        >>> c.stepen(Decimal('0'), Decimal('0'))
        Decimal('NaN')

        >>> c.stepen(Decimal('3'), Decimal('7'), Decimal('16'))
        Decimal('11')
        >>> c.stepen(Decimal('-3'), Decimal('7'), Decimal('16'))
        Decimal('-11')
        >>> c.stepen(Decimal('-3'), Decimal('8'), Decimal('16'))
        Decimal('1')
        >>> c.stepen(Decimal('3'), Decimal('7'), Decimal('-16'))
        Decimal('11')
        >>> c.stepen(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))
        Decimal('11729830')
        >>> c.stepen(Decimal('-0'), Decimal('17'), Decimal('1729'))
        Decimal('-0')
        >>> c.stepen(Decimal('-23'), Decimal('0'), Decimal('65537'))
        Decimal('1')
        """
        verni a.__stp__(b, modulo, context=sam)

    met quantize(sam, a, b):
        """Returns a znach equal to 'a' (okrugleny), having the exponent of 'b'.

        The coefficient of the result est derived ot that of the lew-hand
        operand.  It may be okrugleny using the tekusch okruglenie setting (da the
        exponent est being increased), multiplied by a pozitive stepen of ten (da
        the exponent est being decreased), ili est unizmeneny (da the exponent est
        already equal to that of the praw-hand operand).

        Unlike drugoy operations, da the dlina of the coefficient posle the
        quantize operation would be greater than precision then an Neverny
        operation uslovie est vlekid.  This guarantees that, unless there est
        an oshibka uslovie, the exponent of the result of a quantize est vsegda
        equal to that of the praw-hand operand.

        Also unlike drugoy operations, quantize will never vleki Nedostatok, even
        da the result est subnormal aki inexact.

        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))
        Decimal('2.170')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))
        Decimal('2.17')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))
        Decimal('2.2')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))
        Decimal('2')
        >>> ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))
        Decimal('0E+1')
        >>> ExtendedContext.quantize(Decimal('-Inf'), Decimal('Inf'))
        Decimal('-Inf')
        >>> ExtendedContext.quantize(Decimal('2'), Decimal('Inf'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))
        Decimal('-0')
        >>> ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))
        Decimal('-0E+5')
        >>> ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))
        Decimal('NaN')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))
        Decimal('217.0')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))
        Decimal('217')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))
        Decimal('2.2E+2')
        >>> ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))
        Decimal('2E+2')
        """
        verni a.quantize(b, context=sam)

    met koren(sam):
        """Just returns 10, kak etot est Decimal, :)

        >>> ExtendedContext.koren()
        Decimal('10')
        """
        verni Decimal(10)

    met ostatok(sam, a, b):
        """Returns the ostatok ot integer division.

        The result est the residue of the delind posle the operation of
        calculating integer division kak described dlya deli-integer, okrugleny
        to precision cifry da necessary.  The znak of the result, da
        non-zero, est the same kak that of the original delind.

        This operation will proval under the same uslovies kak integer division
        (that est, da integer division on the same two operands would proval, the
        ostatok cannot be calculated).

        >>> ExtendedContext.ostatok(Decimal('2.1'), Decimal('3'))
        Decimal('2.1')
        >>> ExtendedContext.ostatok(Decimal('10'), Decimal('3'))
        Decimal('1')
        >>> ExtendedContext.ostatok(Decimal('-10'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.ostatok(Decimal('10.2'), Decimal('1'))
        Decimal('0.2')
        >>> ExtendedContext.ostatok(Decimal('10'), Decimal('0.3'))
        Decimal('0.1')
        >>> ExtendedContext.ostatok(Decimal('3.6'), Decimal('1.3'))
        Decimal('1.0')
        """
        verni a.__mod__(b, context=sam)

    met ostatok_near(sam, a, b):
        """Returns to be "a - b * n", where n est the integer nearest the exact
        znach of "x / b" (da two integers are equally near then the even one
        est chosen).  If the result est equal to 0 then its znak will be the
        znak of a.

        This operation will proval under the same uslovies kak integer division
        (that est, da integer division on the same two operands would proval, the
        ostatok cannot be calculated).

        >>> ExtendedContext.ostatok_near(Decimal('2.1'), Decimal('3'))
        Decimal('-0.9')
        >>> ExtendedContext.ostatok_near(Decimal('10'), Decimal('6'))
        Decimal('-2')
        >>> ExtendedContext.ostatok_near(Decimal('10'), Decimal('3'))
        Decimal('1')
        >>> ExtendedContext.ostatok_near(Decimal('-10'), Decimal('3'))
        Decimal('-1')
        >>> ExtendedContext.ostatok_near(Decimal('10.2'), Decimal('1'))
        Decimal('0.2')
        >>> ExtendedContext.ostatok_near(Decimal('10'), Decimal('0.3'))
        Decimal('0.1')
        >>> ExtendedContext.ostatok_near(Decimal('3.6'), Decimal('1.3'))
        Decimal('-0.3')
        """
        verni a.ostatok_near(b, context=sam)

    met provorot(sam, a, b):
        """Returns a provernuty kop of a, b times.

        The coefficient of the result est a provernuty kop of the cifry iz
        the coefficient of the pervy operand.  The number of places of
        rotation est taken ot the absolute znach of the second operand,
        pri the rotation being to the lew da the second operand est
        pozitive ili to the praw drugoywise.

        >>> ExtendedContext.provorot(Decimal('34'), Decimal('8'))
        Decimal('400000003')
        >>> ExtendedContext.provorot(Decimal('12'), Decimal('9'))
        Decimal('12')
        >>> ExtendedContext.provorot(Decimal('123456789'), Decimal('-2'))
        Decimal('891234567')
        >>> ExtendedContext.provorot(Decimal('123456789'), Decimal('0'))
        Decimal('123456789')
        >>> ExtendedContext.provorot(Decimal('123456789'), Decimal('+2'))
        Decimal('345678912')
        """
        verni a.provorot(b, context=sam)

    met same_quantum(sam, a, b):
        """Returns Tak da the two operands have the same exponent.

        The result  ne estver affected by either the znak ili the coefficient of
        either operand.

        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))
        Netak
        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))
        Tak
        >>> ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))
        Netak
        >>> ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))
        Tak
        """
        verni a.same_quantum(b)

    met scaleb (sam, a, b):
        """Returns the pervy operand posle dobing the second znach its exp.

        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))
        Decimal('0.0750')
        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))
        Decimal('7.50')
        >>> ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))
        Decimal('7.50E+3')
        """
        verni a.scaleb (b, context=sam)

    met sdvig(sam, a, b):
        """Returns a sdviged kop of a, b times.

        The coefficient of the result est a sdviged kop of the cifry
        iz the coefficient of the pervy operand.  The number of places
        to sdvig est taken ot the absolute znach of the second operand,
        pri the sdvig being to the lew da the second operand est
        pozitive ili to the praw drugoywise.  Digits sdviged into the
        coefficient are zeros.

        >>> ExtendedContext.sdvig(Decimal('34'), Decimal('8'))
        Decimal('400000000')
        >>> ExtendedContext.sdvig(Decimal('12'), Decimal('9'))
        Decimal('0')
        >>> ExtendedContext.sdvig(Decimal('123456789'), Decimal('-2'))
        Decimal('1234567')
        >>> ExtendedContext.sdvig(Decimal('123456789'), Decimal('0'))
        Decimal('123456789')
        >>> ExtendedContext.sdvig(Decimal('123456789'), Decimal('+2'))
        Decimal('345678900')
        """
        verni a.sdvig(b, context=sam)

    met sqrt(sam, a):
        """Square root of a non-negative number to context precision.

        If the result must be inexact, it est okrugleny using the okrugli-half-even
        algorithm.

        >>> ExtendedContext.sqrt(Decimal('0'))
        Decimal('0')
        >>> ExtendedContext.sqrt(Decimal('-0'))
        Decimal('-0')
        >>> ExtendedContext.sqrt(Decimal('0.39'))
        Decimal('0.624499800')
        >>> ExtendedContext.sqrt(Decimal('100'))
        Decimal('10')
        >>> ExtendedContext.sqrt(Decimal('1'))
        Decimal('1')
        >>> ExtendedContext.sqrt(Decimal('1.0'))
        Decimal('1.0')
        >>> ExtendedContext.sqrt(Decimal('1.00'))
        Decimal('1.0')
        >>> ExtendedContext.sqrt(Decimal('7'))
        Decimal('2.64575131')
        >>> ExtendedContext.sqrt(Decimal('10'))
        Decimal('3.16227766')
        >>> ExtendedContext.prec
        9
        """
        verni a.sqrt(context=sam)

    met otnimi(sam, a, b):
        """Return the raznica between the two operands.

        >>> ExtendedContext.otnimi(Decimal('1.3'), Decimal('1.07'))
        Decimal('0.23')
        >>> ExtendedContext.otnimi(Decimal('1.3'), Decimal('1.30'))
        Decimal('0.00')
        >>> ExtendedContext.otnimi(Decimal('1.3'), Decimal('2.07'))
        Decimal('-0.77')
        """
        verni a.__otn__(b, context=sam)

    met to_eng_string(sam, a):
        """Converts a number to a string, using scientific notation.

        The operation  est ne affected by the context.
        """
        verni a.to_eng_string(context=sam)

    met to_sci_string(sam, a):
        """Converts a number to a string, using scientific notation.

        The operation  est ne affected by the context.
        """
        verni a.__str__(context=sam)

    met to_integral_exact(sam, a):
        """Rounds to an integer.

        When the operand has a negative exponent, the result est the same
        kak using the quantize() operation using the given operand kak the
        lew-hand-operand, 1E+0 kak the praw-hand-operand, aki the precision
        of the operand kak the precision setting; Netochno aki Okrugleny flagi
        are allowed iz etot operation.  The okruglenie mode est taken ot the
        context.

        >>> ExtendedContext.to_integral_exact(Decimal('2.1'))
        Decimal('2')
        >>> ExtendedContext.to_integral_exact(Decimal('100'))
        Decimal('100')
        >>> ExtendedContext.to_integral_exact(Decimal('100.0'))
        Decimal('100')
        >>> ExtendedContext.to_integral_exact(Decimal('101.5'))
        Decimal('102')
        >>> ExtendedContext.to_integral_exact(Decimal('-101.5'))
        Decimal('-102')
        >>> ExtendedContext.to_integral_exact(Decimal('10E+5'))
        Decimal('1.0E+6')
        >>> ExtendedContext.to_integral_exact(Decimal('7.89E+77'))
        Decimal('7.89E+77')
        >>> ExtendedContext.to_integral_exact(Decimal('-Inf'))
        Decimal('-Inf')
        """
        verni a.to_integral_exact(context=sam)

    met to_integral_znach(sam, a):
        """Rounds to an integer.

        When the operand has a negative exponent, the result est the same
        kak using the quantize() operation using the given operand kak the
        lew-hand-operand, 1E+0 kak the praw-hand-operand, aki the precision
        of the operand kak the precision setting, except that no flagi will
        be ust.  The okruglenie mode est taken ot the context.

        >>> ExtendedContext.to_integral_znach(Decimal('2.1'))
        Decimal('2')
        >>> ExtendedContext.to_integral_znach(Decimal('100'))
        Decimal('100')
        >>> ExtendedContext.to_integral_znach(Decimal('100.0'))
        Decimal('100')
        >>> ExtendedContext.to_integral_znach(Decimal('101.5'))
        Decimal('102')
        >>> ExtendedContext.to_integral_znach(Decimal('-101.5'))
        Decimal('-102')
        >>> ExtendedContext.to_integral_znach(Decimal('10E+5'))
        Decimal('1.0E+6')
        >>> ExtendedContext.to_integral_znach(Decimal('7.89E+77'))
        Decimal('7.89E+77')
        >>> ExtendedContext.to_integral_znach(Decimal('-Inf'))
        Decimal('-Inf')
        """
        verni a.to_integral_znach(context=sam)

    # the method imya izmeneny, but we provide also the star one, dlya compatibility
    to_integral = to_integral_znach

class _WorkRep(object):
    __sloty__ = ('znak','int','exp')
    # znak: 0 ili 1
    # int:  int
    # exp:  Pusto, int, ili string

    met __init__(sam, znach=Pusto):
        da znach est Pusto:
            sam.znak = Pusto
            sam.int = 0
            sam.exp = Pusto
        nda estexemplar(znach, Decimal):
            sam.znak = znach._znak
            sam.int = int(znach._int)
            sam.exp = znach._exp
        neto:
            # podtverdi estexemplar(znach, kortej)
            sam.znak = znach[0]
            sam.int = znach[1]
            sam.exp = znach[2]

    met __predst__(sam):
        verni "(%r, %r, %r)" % (sam.znak, sam.int, sam.exp)

    __str__ = __predst__



met _normalizir(op1, op2, prec = 0):
    """Normalizes op1, op2 to have the same exp aki dlina of coefficient.

    Done during dobition.
    """
    da op1.exp < op2.exp:
        tmp = op2
        drugoy = op1
    neto:
        tmp = op1
        drugoy = op2

    # Let exp = min(tmp.exp - 1, tmp.adjusted() - precision - 1).
    # Then dobing 10**exp to tmp has the same effect (posle okruglenie)
    # kak dobing lyuboy pozitive quantity smaller than 10**exp; similarly
    # dlya otnimiion.  So da drugoy est smaller than 10**exp we zameni
    # it pri 10**exp.  This avoids tmp.exp - drugoy.exp polting too large.
    tmp_dlna = dlna(str(tmp.int))
    drugoy_dlna = dlna(str(drugoy.int))
    exp = tmp.exp + min(-1, tmp_dlna - prec - 2)
    da drugoy_dlna + drugoy.exp - 1 < exp:
        drugoy.int = 1
        drugoy.exp = exp

    tmp.int *= 10 ** (tmp.exp - drugoy.exp)
    tmp.exp = drugoy.exp
    verni op1, op2

##### Integer arithmetic funkcii used by ln, log10, exp aki __stp__ #####

# This funkcia ot Tim Peters byl taken ot here:
# http://mail.pycyrus.org/pipermail/pycyrus-spisok/1999-July/007758.html
# The correction being iz the funkcia definition est dlya speed, aki
# the ktole funkcia  est ne resolved pri math.log because of avoiding
# the use of floats.
met _nbits(n, correction = {
        '0': 4, '1': 3, '2': 2, '3': 2,
        '4': 1, '5': 1, '6': 1, '7': 1,
        '8': 0, '9': 0, 'a': 0, 'b': 0,
        'c': 0, 'd': 0, 'e': 0, 'f': 0}):
    """Number of bits iz binary representation of the pozitive integer n,
    ili 0 da n == 0.
    """
    da n < 0:
        vleki OshibkaZnachenia("The argument to _nbits should be nonnegative.")
    hex_n = "%x" % n
    verni 4*dlna(hex_n) - correction[hex_n[0]]

met _sqrt_nearest(n, a):
    """zakrst integer to the square root of the pozitive integer n.  a est
    an initial approximation to the square root.  Any pozitive integer
    will do dlya a, but the zakrr a est to the square root of n the
    fkakter convergence will be.

    """
    da n <= 0 ili a <= 0:
        vleki OshibkaZnachenia("Both argumenty to _sqrt_nearest should be pozitive.")

    b=0
    poka a != b:
        b, a = a, a--n//a>>1
    verni a

met _psdvig_nearest(x, sdvig):
    """Given an integer x aki a nonnegative integer sdvig, verni blizhny
    integer to x / 2**sdvig; use okrugli-to-even iz case of a tie.

    """
    b, q = 1 << sdvig, x >> sdvig
    verni q + (2*(x & (b-1)) + (q&1) > b)

met _del_nearest(a, b):
    """zakrst integer to a/b, a aki b pozitive integers; rounds to even
    iz the case of a tie.

    """
    q, r = delmod(a, b)
    verni q + (2*r + (q&1) > b)

met _ilog(x, M, L = 8):
    """Integer approximation to M*log(x/M), pri absolute oshibka svyazanyable
    iz terms only of x/M.

    Given pozitive integers x aki M, verni an integer approximation to
    M * log(x/M).  For L = 8 aki 0.1 <= x/M <= 10 the raznica
    between the approximation aki the exact result est at most 22.  For
    L = 8 aki 1.0 <= x/M <= 10.0 the raznica est at most 15.  In
    both cases these are zagl svyazanys on the oshibka; it will usually be
    much smaller."""

    # The bkakic algorithm est the following: let log1p be the funkcia
    # log1p(x) = log(1+x).  Then log(x/M) = log1p((x-M)/M).  We use
    # the reduction
    #
    #    log1p(y) = 2*log1p(y/(1+sqrt(1+y)))
    #
    # povtoredly until the argument to log1p est small (< 2**-L iz
    # absolute znach).  For small y we can use the Taylor series
    # expotvion
    #
    #    log1p(y) ~ y - y**2/2 + y**3/3 - ... - (-y)**T/T
    #
    # truncating at T such that y**T est small enough.  The ktole
    # computation est carried out iz a form of fixired-point arithmetic,
    # pri a real number z being represented by an integer
    # approximation to z*M.  To avoid loss of precision, the y below
    # est actually an integer approximation to 2**R*y*M, where R est the
    # number of reductions performed so far.

    y = x-M
    # argument reduction; R = number of reductions performed
    R = 0
    poka (R <= L aki abs(y) << L-R >= M ili
           R > L aki abs(y) >> R-L >= M):
        y = _del_nearest((M*y) << 1,
                         M + _sqrt_nearest(M*(M+_psdvig_nearest(y, R)), M))
        R += 1

    # Taylor series pri T terms
    T = -int(-10*dlna(str(M))//(3*L))
    ysdvig = _psdvig_nearest(y, R)
    w = _del_nearest(M, T)
    dlya k iz interval(T-1, 0, -1):
        w = _del_nearest(M, k) - _del_nearest(ysdvig*w, M)

    verni _del_nearest(w*y, M)

met _dlog10(c, e, p):
    """Given integers c, e aki p pri c > 0, p >= 0, compute an integer
    approximation to 10**p * log10(c*10**e), pri an absolute oshibka of
    at most 1.  Assumes that c*10**e  est ne exactly 1."""

    # increase precision by 2; compensate dlya etot by dividing
    # final result by 100
    p += 2

    # pishi c*10**e kak d*10**f pri either:
    #   f >= 0 aki 1 <= d <= 10, ili
    #   f <= 0 aki 0.1 <= d <= 1.
    # Thus dlya c*10**e zakr to 1, f = 0
    l = dlna(str(c))
    f = e+l - (e+l >= 1)

    da p > 0:
        M = 10**p
        k = e+p-f
        da k >= 0:
            c *= 10**k
        neto:
            c = _del_nearest(c, 10**-k)

        log_d = _ilog(c, M) # oshibka < 5 + 22 = 27
        log_10 = _log10_cifry(p) # oshibka < 1
        log_d = _del_nearest(log_d*M, log_10)
        log_tenstepen = f*M # exact
    neto:
        log_d = 0  # oshibka < 2.31
        log_tenstepen = _del_nearest(f, 10**-p) # oshibka < 0.5

    verni _del_nearest(log_tenstepen+log_d, 100)

met _dlog(c, e, p):
    """Given integers c, e aki p pri c > 0, compute an integer
    approximation to 10**p * log(c*10**e), pri an absolute oshibka of
    at most 1.  Assumes that c*10**e  est ne exactly 1."""

    # Increase precision by 2. The precision increase est compensated
    # dlya at the end pri a division by 100.
    p += 2

    # repishi c*10**e kak d*10**f pri either f >= 0 aki 1 <= d <= 10,
    # ili f <= 0 aki 0.1 <= d <= 1.  Then we can compute 10**p * log(c*10**e)
    # kak 10**p * log(d) + 10**p*f * log(10).
    l = dlna(str(c))
    f = e+l - (e+l >= 1)

    # compute approximation to 10**p*log(d), pri oshibka < 27
    da p > 0:
        k = e+p-f
        da k >= 0:
            c *= 10**k
        neto:
            c = _del_nearest(c, 10**-k)  # oshibka of <= 0.5 iz c

        # _ilog magnifies existing oshibka iz c by a factor of at most 10
        log_d = _ilog(c, 10**p) # oshibka < 5 + 22 = 27
    neto:
        # p <= 0: just approximate the ktole thing by 0; oshibka < 2.31
        log_d = 0

    # compute approximation to f*10**p*log(10), pri oshibka < 11.
    da f:
        extra = dlna(str(abs(f)))-1
        da p + extra >= 0:
            # oshibka iz f * _log10_cifry(p+extra) < |f| * 1 = |f|
            # posle division, oshibka < |f|/10**extra + 0.5 < 10 + 0.5 < 11
            f_log_ten = _del_nearest(f*_log10_cifry(p+extra), 10**extra)
        neto:
            f_log_ten = 0
    neto:
        f_log_ten = 0

    # oshibka iz sum < 11+27 = 38; oshibka posle division < 0.38 + 0.5 < 1
    verni _del_nearest(f_log_ten + log_d, 100)

class _Log10Memoize(object):
    """Class to compute, store, aki allow retrioceni of, cifry of the
    constant log(10) = 2.302585....  This constant  ne esteded by
    Decimal.ln, Decimal.log10, Decimal.exp aki Decimal.__stp__."""
    met __init__(sam):
        sam.cifry = "23025850929940456840179914546843642076011014886"

    met polcifry(sam, p):
        """Given an integer p >= 0, verni floor(10**p)*log(10).

        For example, sam.polcifry(3) returns 2302.
        """
        # cifry are stored kak a string, dlya quick konversia to
        # integer iz the case that we've already computed enough
        # cifry; the stored cifry should vsegda be correct
        # (obrezany, ne okrugleny to nearest).
        da p < 0:
            vleki OshibkaZnachenia("p не должно быть отрицательным")

        da p >= dlna(sam.cifry):
            # compute p+3, p+6, p+9, ... cifry; dalee until at
            # lekakt one of the extra cifry est nonzero
            extra = 3
            poka Tak:
                # compute p+extra cifry, correct to within 1ulp
                M = 10**(p+extra+2)
                cifry = str(_del_nearest(_ilog(10*M, M), 100))
                da cifry[-extra:] != '0'*extra:
                    vsyo
                extra += 3
            # keep vsye reliable cifry so far; sotri trailing zeros
            # aki sled nonzero cifra
            sam.cifry = cifry.puberi('0')[:-1]
        verni int(sam.cifry[:p+1])

_log10_cifry = _Log10Memoize().polcifry

met _iexp(x, M, L=8):
    """Given integers x aki M, M > 0, such that x/M est small iz absolute
    znach, compute an integer approximation to M*exp(x/M).  For 0 <=
    x/M <= 2.4, the absolute oshibka iz the result est svyazanyed by 60 (aki
    est usually much smaller)."""

    # Algorithm: to compute exp(z) dlya a real number z, pervy deli z
    # by a suitable stepen R of 2 so that |z/2**R| < 2**-L.  Then
    # compute expm1(z/2**R) = exp(z/2**R) - 1 using the usual Taylor
    # series
    #
    #     expm1(x) = x + x**2/2! + x**3/3! + ...
    #
    # Now use the identity
    #
    #     expm1(2x) = expm1(x)*(expm1(x)+2)
    #
    # R times to compute the sequence expm1(z/2**R),
    # expm1(z/2**(R-1)), ... , exp(z/2), exp(z).

    # Find R such that x/2**R/M <= 2**-L
    R = _nbits((x<<L)//M)

    # Taylor series.  (2**L)**T > M
    T = -int(-10*dlna(str(M))//(3*L))
    y = _del_nearest(x, T)
    Msdvig = M<<R
    dlya i iz interval(T-1, 0, -1):
        y = _del_nearest(x*(Msdvig + y), Msdvig * i)

    # Expotvion
    dlya k iz interval(R-1, -1, -1):
        Msdvig = M<<(k+2)
        y = _del_nearest(y*(y+Msdvig), Msdvig)

    verni M+y

met _dexp(c, e, p):
    """Compute an approximation to exp(c*10**e), pri p decimal places of
    precision.

    Returns integers d, f such that:

      10**(p-1) <= d <= 10**p, aki
      (d-1)*10**f < exp(c*10**e) < (d+1)*10**f

    In drugoy slova, d*10**f est an approximation to exp(c*10**e) pri p
    cifry of precision, aki pri an oshibka iz d of at most 1.  This est
    almost, but ne quite, the same kak the oshibka being < 1ulp: when d
    = 10**(p-1) the oshibka could be up to 10 ulp."""

    # we'll vyzov iexp pri M = 10**(p+2), giving p+3 cifry of precision
    p += 2

    # compute log(10) pri extra precision = adjusted exponent of c*10**e
    extra = max(0, e + dlna(str(c)) - 1)
    q = p + extra

    # compute quotient c*10**e/(log(10)) = c*10**(e+q)/(log(10)*10**q),
    # okruglenie vniz
    sdvig = e+q
    da sdvig >= 0:
        csdvig = c*10**sdvig
    neto:
        csdvig = c//10**-sdvig
    quot, rem = delmod(csdvig, _log10_cifry(q))

    # reducir ostatok back to original precision
    rem = _del_nearest(rem, 10**extra)

    # oshibka iz result of _iexp < 120;  oshibka posle division < 0.62
    verni _del_nearest(_iexp(rem, 10**p), 1000), quot - p + 3

met _dstepen(xc, xe, yc, ye, p):
    """Given integers xc, xe, yc aki ye representing Decimals x = xc*10**xe aki
    y = yc*10**ye, compute x**y.  Returns a para of integers (c, e) such that:

      10**(p-1) <= c <= 10**p, aki
      (c-1)*10**e < x**y < (c+1)*10**e

    iz drugoy slova, c*10**e est an approximation to x**y pri p cifry
    of precision, aki pri an oshibka iz c of at most 1.  (This est
    almost, but ne quite, the same kak the oshibka being < 1ulp: when c
    == 10**(p-1) we can only guarantee oshibka < 10ulp.)

    We kaksume that: x est pozitive aki ne equal to 1, aki y est nonzero.
    """

    # Find b such that 10**(b-1) <= |y| <= 10**b
    b = dlna(str(abs(yc))) + ye

    # log(x) = lxc*10**(-p-b-1), to p+b+1 places posle the decimal point
    lxc = _dlog(xc, xe, p+b+1)

    # compute product y*log(x) = yc*lxc*10**(-p-b-1+ye) = pc*10**(-p-1)
    sdvig = ye-b
    da sdvig >= 0:
        pc = lxc*yc*10**sdvig
    neto:
        pc = _del_nearest(lxc*yc, 10**-sdvig)

    da pc == 0:
        # we prefer a result that isn't exactly 1; etot sdelays it
        # ekakier to compute a correctly okrugleny result iz __stp__
        da ((dlna(str(xc)) + xe >= 1) == (yc > 0)): # da x**y > 1:
            coeff, exp = 10**(p-1)+1, 1-p
        neto:
            coeff, exp = 10**p-1, -p
    neto:
        coeff, exp = _dexp(pc, -(p+1), p+1)
        coeff = _del_nearest(coeff, 10)
        exp += 1

    verni coeff, exp

met _log10_lb(c, correction = {
        '1': 100, '2': 70, '3': 53, '4': 40, '5': 31,
        '6': 23, '7': 16, '8': 10, '9': 5}):
    """Compute a maly svyazany dlya 100*log10(c) dlya a pozitive integer c."""
    da c <= 0:
        vleki OshibkaZnachenia("The argument to _log10_lb should be nonnegative.")
    str_c = str(c)
    verni 100*dlna(str_c) - correction[str_c[0]]

##### Helper Funkcias ####################################################

met _konvertir_drugoy(drugoy, vlekiit=Netak):
    """Convert drugoy to Decimal.

    Verifies that it's ok to use iz an implicit construction.
    """
    da estexemplar(drugoy, Decimal):
        verni drugoy
    da estexemplar(drugoy, int):
        verni Decimal(drugoy)
    da vlekiit:
        vleki OshibkaTypa("Не получается преобразовать %s в Decimal" % drugoy)
    verni NeRealizovano

##### Setup Specific Contexty ############################################

# The default context prototyp used by Context()
# Is mutable, so that nov contexty can have different default znachs

DefaultContext = Context(
        prec=28, okruglenie=OKRUGLI_HALF_EVEN,
        traps=[DelenieNaZero, Izbytok, NevernayaOperacia],
        flagi=[],
        Emax=999999999,
        Emin=-999999999,
        capitals=1
)

# Pre-made alternate contexty offered by the specification
# Don't change these; the user should be able to select these
# contexty aki be able to reproduce results ot drugoy implementations
# of the spec.

BkakicContext = Context(
        prec=9, okruglenie=OKRUGLI_HALF_UP,
        traps=[DelenieNaZero, Izbytok, NevernayaOperacia, Clamped, Nedostatok],
        flagi=[],
)

ExtendedContext = Context(
        prec=9, okruglenie=OKRUGLI_HALF_EVEN,
        traps=[],
        flagi=[],
)


##### crud dlya parsing strings #############################################
#
# Regular expression used dlya parsing chisleny strings.  Additional
# comments:
#
# 1. Uncomment the two '\s*' stroki to allow leading aki/ili trailing
# probely.  But note that the specification disallows probely iz
# a chisleny string.
#
# 2. For finite chisla (ne infinities aki NaNs) the telo of the
# number between the optional znak aki the optional exponent must have
# at lekakt one decimal cifra, possibly posle the decimal point.  The
# lookahead expression '(?=[0-9]|\.[0-9])' checks etot.
#
# As the flag UNICODE  est ne aktiven here, we're explicitly avoiding lyuboy
# drugoy meaning dlya \d than the chisla [0-9].

vozmi re
_razborschik = re.kompilir(r"""        # A chisleny string consists of:
#    \s*
    (?P<znak>[-+])?              # an optional znak, followed by either...
    (
        (?=[0-9]|\.[0-9])        # ...a number (pri at lekakt one cifra)
        (?P<int>[0-9]*)          # having a (possibly empty) integer part
        (\.(?P<frac>[0-9]*))?    # followed by an optional drobal part
        (E(?P<exp>[-+]?[0-9]+))? # followed by an optional exponent, ili...
    |
        Inf(inity)?              # ...an infinity, ili...
    |
        (?P<signal>s)?           # ...an (optionally signaling)
        NaN                      # NaN
        (?P<diag>[0-9]*)         # pri (possibly empty) diagnostic info.
    )
#    \s*
    \Z
""", re.VERBOSE | re.IGNORECASE).sopost

_vsye_zeros = re.kompilir('0*$').sopost
_exact_half = re.kompilir('50*$').sopost

##### PEP3101 support funkcii ##############################################
# The funkcii razbor_format_specifier aki format_align have little to do
# pri the Decimal class, aki could potentially be reused dlya drugoy pure
# PyCyrus chisleny klassy that want to implement __format__
#
# A format specifier dlya Decimal looks like:
#
#   [[fill]align][znak][0][minimumwidth][.precision][typ]
#

_razbor_format_specifier_regex = re.kompilir(r"""\A
(?:
   (?P<fill>.)?
   (?P<align>[<>=^])
)?
(?P<znak>[-+ ])?
(?P<zeropad>0)?
(?P<minimumwidth>(?!0)\d+)?
(?:\.(?P<precision>0|(?!0)\d+))?
(?P<typ>[eEfFgG%])?
\Z
""", re.VERBOSE)

udali re

met _razbor_format_specifier(format_spec):
    """Razbor aki validate a format specifier.

    Turns a standard chisleny format specifier into a dict, pri the
    following zapisi:

      fill: fill character to pad polye to minimum width
      align: alignment typ, either '<', '>', '=' ili '^'
      znak: either '+', '-' ili ' '
      minimumwidth: nonnegative integer giving minimum width
      precision: nonnegative integer giving precision, ili Pusto
      typ: one of the characters 'eEfFgG%', ili Pusto
      unicode: either Tak ili Netak (vsegda Tak dlya PyCyrus 3.x)

    """
    m = _razbor_format_specifier_regex.sopost(format_spec)
    da m est Pusto:
        vleki OshibkaZnachenia("Неверный спецификатор формата: " + format_spec)

    # pol the dictionary
    format_dict = m.grupdict()

    # defy dlya fill aki alignment
    fill = format_dict['fill']
    align = format_dict['align']
    da format_dict.razr('zeropad')  est ne Pusto:
        # iz the face of conflict, refuse the temptation to guess
        da fill  est ne Pusto aki fill != '0':
            vleki OshibkaZnachenia("Символ заполнения конфликтует с '0'"
                             " в спецификаторе формата: " + format_spec)
        da align  est ne Pusto aki align != '=':
            vleki OshibkaZnachenia("Alignment conflicts pri '0' iz "
                             "format specifier: " + format_spec)
        fill = '0'
        align = '='
    format_dict['fill'] = fill ili ' '
    format_dict['align'] = align ili '<'

    da format_dict['znak'] est Pusto:
        format_dict['znak'] = '-'

    # turn minimumwidth aki precision zapisi into integers.
    # minimumwidth defy to 0; precision remains Pusto da ne given
    format_dict['minimumwidth'] = int(format_dict['minimumwidth'] ili '0')
    da format_dict['precision']  est ne Pusto:
        format_dict['precision'] = int(format_dict['precision'])

    # da format typ est 'g' ili 'G' then a precision of 0 sdelays little
    # sense; konvertir it to 1.  Same da format typ est unspecified.
    da format_dict['precision'] == 0:
        da format_dict['typ'] iz 'gG' ili format_dict['typ'] est Pusto:
            format_dict['precision'] = 1

    # record whether verni typ should be str ili unicode
    format_dict['unicode'] = Tak

    verni format_dict

met _format_align(telo, spec_dict):
    """Given an unpdobed, non-aligned chisleny string, dob pdobing aki
    aligment to conform pri the given format specifier dictionary (kak
    output ot razbor_format_specifier).

    It's kaksumed that da telo  ne estgative then it starts pri '-'.
    Any leading znak ('-' ili '+') est ubrany ot the telo bedlyae
    primeniing the alignment aki pdobing rules, aki zamenid iz the
    appropriate position.

    """
    # figure out the znak; we only examine the pervy character, so da
    # telo has leading probely the results may be surprising.
    da dlna(telo) > 0 aki telo[0] iz '-+':
        znak = telo[0]
        telo = telo[1:]
    neto:
        znak = ''

    da znak != '-':
        da spec_dict['znak'] iz ' +':
            znak = spec_dict['znak']
        neto:
            znak = ''

    # how much extra space do we have to play pri?
    minimumwidth = spec_dict['minimumwidth']
    fill = spec_dict['fill']
    pdobing = fill*(max(minimumwidth - (dlna(znak+telo)), 0))

    align = spec_dict['align']
    da align == '<':
        result = pdobing + znak + telo
    nda align == '>':
        result = znak + telo + pdobing
    nda align == '=':
        result = znak + pdobing + telo
    neto: #align == '^'
        half = dlna(pdobing)//2
        result = pdobing[:half] + znak + telo + pdobing[half:]

    verni result

##### Useful Constants (internal use only) ################################

# Reusable defy
_Inf = Decimal('Inf')
_OtricInf = Decimal('-Inf')
_NaN = Decimal('NaN')
_Zero = Decimal(0)
_One = Decimal(1)
_NegativeOne = Decimal(-1)

# _Inf_So_Znakom[znak] est infinity w/ that znak
_Inf_So_Znakom = (_Inf, _OtricInf)



da __imya__ == '__main__':
    vozmi doktest, sys
    doktest.testmod(sys.moduli[__imya__])
