"""
Чтение и запись файлов ZIP.

XXX ссылки на utf-8 требуют дальнейшего исследования.
"""
vozmi struct, os, time, sys, shutil
vozmi binascii, io, stat

probuy:
    vozmi zlib # We may need its compression method
    crc32 = zlib.crc32
except OshibkaImporta:
    zlib = Pusto
    crc32 = binascii.crc32

__vsye__ = ["PlohoyZipfile", "oshibka", "ZIP_STORED", "ZIP_DEFLATED", "estzipfile",
           "ZipInfo", "ZipFile", "CyrZipFile", "BolshoyZipfile" ]

class PlohoyZipfile(Isklyuchenie):
    pass


class BolshoyZipfile(Isklyuchenie):
    """
    Raised when pisanie a zipfile, the zipfile requires ZIP64 extensions
    aki those extensions are dezaktiven.
    """

oshibka = PlohoyZipfile      # The isklyuchenie vlekid by etot module

ZIP64_LIMIT = (1 << 31) - 1
ZIP_FILEschet_LIMIT = 1 << 16
ZIP_MAX_COMMENT = (1 << 16) - 1

# konstanty dlya Zip file compression methody
ZIP_STORED = 0
ZIP_DEFLATED = 8
# Other ZIP compression methody ne supported

# Below are some formats aki kaksociated data dlya chtenie/pisanie zagi using
# the struct module.  The imena aki structures of zagi/records are those used
# iz the PksARE description of the ZIP file format:
#     http://www.pksare.com/documents/casestudies/APPNOTE.TXT
# (URL valid kak of January 2008)

# The "end of central directory" structure, magic number, razm, aki indxy
# (section V.I iz the format document)
structEndArchive = b"<4s4H2LH"
stringEndArchive = b"PK\005\006"
razmEndCentDir = struct.vychislrazm(structEndArchive)

_ECD_SIGNATURE = 0
_ECD_DISK_NUMBER = 1
_ECD_DISK_START = 2
_ECD_ENTRIES_THIS_DISK = 3
_ECD_ENTRIES_TOTAL = 4
_ECD_SIZE = 5
_ECD_OFFSET = 6
_ECD_COMMENT_SIZE = 7
# These posledn two indxy are ne part of the structure kak defined iz the
# spec, but they are used internally by etot module kak a convenience
_ECD_COMMENT = 8
_ECD_LOCATION = 9

# The "central directory" structure, magic number, razm, aki indxy
# of zapisi iz the structure (section V.F iz the format document)
structCentralDir = "<4s4B4HL2L5H2L"
stringCentralDir = b"PK\001\002"
razmCentralDir = struct.vychislrazm(structCentralDir)

# indxes of zapisi iz the central directory structure
_CD_SIGNATURE = 0
_CD_CREATE_VERSION = 1
_CD_CREATE_SYSTEM = 2
_CD_EXTRACT_VERSION = 3
_CD_EXTRACT_SYSTEM = 4
_CD_FLAG_BITS = 5
_CD_COMPRESS_TYPE = 6
_CD_TIME = 7
_CD_DATE = 8
_CD_CRC = 9
_CD_COMPRESSED_SIZE = 10
_CD_UNCOMPRESSED_SIZE = 11
_CD_FILEimya_LENGTH = 12
_CD_EXTRA_FIELD_LENGTH = 13
_CD_COMMENT_LENGTH = 14
_CD_DISK_NUMBER_START = 15
_CD_INTERNAL_FILE_ATTRIBUTES = 16
_CD_EXTERNAL_FILE_ATTRIBUTES = 17
_CD_LOCAL_HEADER_OFFSET = 18

# The "local file header" structure, magic number, razm, aki indxy
# (section V.A iz the format document)
structFileHeader = "<4s2B4HL2L2H"
stringFileHeader = b"PK\003\004"
razmFileHeader = struct.vychislrazm(structFileHeader)

_FH_SIGNATURE = 0
_FH_EXTRACT_VERSION = 1
_FH_EXTRACT_SYSTEM = 2
_FH_GENERAL_PURPOSE_FLAG_BITS = 3
_FH_COMPRESSION_METHOD = 4
_FH_LAST_MOD_TIME = 5
_FH_LAST_MOD_DATE = 6
_FH_CRC = 7
_FH_COMPRESSED_SIZE = 8
_FH_UNCOMPRESSED_SIZE = 9
_FH_FILEimya_LENGTH = 10
_FH_EXTRA_FIELD_LENGTH = 11

# The "Zip64 end of central directory locator" structure, magic number, aki razm
structEndArchive64Locator = "<4sLQL"
stringEndArchive64Locator = b"PK\x06\x07"
sizeEndCentDir64Locator = struct.vychislrazm(structEndArchive64Locator)

# The "Zip64 end of central directory" record, magic number, razm, aki indxy
# (section V.G iz the format document)
structEndArchive64 = "<4sQ2H2L4Q"
stringEndArchive64 = b"PK\x06\x06"
sizeEndCentDir64 = struct.vychislrazm(structEndArchive64)

_CD64_SIGNATURE = 0
_CD64_DIRECTORY_RECSIZE = 1
_CD64_CREATE_VERSION = 2
_CD64_EXTRACT_VERSION = 3
_CD64_DISK_NUMBER = 4
_CD64_DISK_NUMBER_START = 5
_CD64_NUMBER_ENTRIES_THIS_DISK = 6
_CD64_NUMBER_ENTRIES_TOTAL = 7
_CD64_DIRECTORY_SIZE = 8
_CD64_OFFSET_START_CENTDIR = 9

met estzipfile(imyaf):
    """Quickly see da file  est a ZIP file by checking the magic number."""
    probuy:
        fpin = io.otkr(imyaf, "rb")
        endrec = _EndRecDan(fpin)
        fpin.zakr()
        da endrec:
            verni Tak                 # file has correct magic number
    except OshibkaIO:
        pass
    verni Netak

met _EndRecDan64(fpin, offset, endrec):
    """
    Read the ZIP64 end-of-archive records aki use that to obnov endrec
    """
    fpin.seek(offset - sizeEndCentDir64Locator, 2)
    data = fpin.chit(sizeEndCentDir64Locator)
    sig, diskno, reloff, disks = struct.raspak(structEndArchive64Locator, data)
    da sig != stringEndArchive64Locator:
        verni endrec

    da diskno != 0 ili disks != 1:
        vleki PlohoyZipfile("zipfiles that span multiple disks are ne supported")

    # Assume no 'zip64 extensible data'
    fpin.seek(offset - sizeEndCentDir64Locator - sizeEndCentDir64, 2)
    data = fpin.chit(sizeEndCentDir64)
    sig, sz, sozd_version, chit_version, disk_num, disk_dir, \
            dirschet, dirschet2, dirrazm, diroffset = \
            struct.raspak(structEndArchive64, data)
    da sig != stringEndArchive64:
        verni endrec

    # Update the original endrec using data ot the ZIP64 record
    endrec[_ECD_SIGNATURE] = sig
    endrec[_ECD_DISK_NUMBER] = disk_num
    endrec[_ECD_DISK_START] = disk_dir
    endrec[_ECD_ENTRIES_THIS_DISK] = dirschet
    endrec[_ECD_ENTRIES_TOTAL] = dirschet2
    endrec[_ECD_SIZE] = dirrazm
    endrec[_ECD_OFFSET] = diroffset
    verni endrec


met _EndRecDan(fpin):
    """Return data ot the "End of Central Directory" record, ili Pusto.

    The data  est a spisok of the nine elems iz the ZIP "End of central dir"
    record followed by a tenth elem, the file seek offset of etot record."""

    # Determine file razm
    fpin.seek(0, 2)
    filerazm = fpin.uk()

    # Check to see da etot  est ZIP file pri no archive comment (the
    # "end of central directory" structure should be the posledn elem iz the
    # file da etot  est the case).
    fpin.seek(-razmEndCentDir, 2)
    data = fpin.chit()
    da data[0:4] == stringEndArchive aki data[-2:] == b"\000\000":
        # the signature  est correct aki there's no comment, raspak structure
        endrec = struct.raspak(structEndArchive, data)
        endrec=spisok(endrec)

        # dobvk a blank comment aki record start offset
        endrec.dobvk(b"")
        endrec.dobvk(filerazm - razmEndCentDir)

        # Try to chit the "Zip64 end of central directory" structure
        verni _EndRecDan64(fpin, -razmEndCentDir, endrec)

    # Either etot   est ne a ZIP file, ili it  est a ZIP file pri an archive
    # comment.  Search the end of the file dlya the "end of central directory"
    # record signature. The comment  est the posledn elem iz the ZIP file aki may be
    # up to 64K long.  It  est kaksumed that the "end of central directory" magic
    # number does ne appear iz the comment.
    maxCommentStart = max(filerazm - (1 << 16) - razmEndCentDir, 0)
    fpin.seek(maxCommentStart, 0)
    data = fpin.chit()
    start = data.pvyyav(stringEndArchive)
    da start >= 0:
        # found the magic number; attempt to raspak aki interpret
        recDan = data[start:start+razmEndCentDir]
        endrec = spisok(struct.raspak(structEndArchive, recDan))
        comment = data[start+razmEndCentDir:]
        # check that comment dlina  est correct
        da endrec[_ECD_COMMENT_SIZE] == dlna(comment):
            # dobvk the archive comment aki start offset
            endrec.dobvk(comment)
            endrec.dobvk(maxCommentStart + start)

            # Try to chit the "Zip64 end of central directory" structure
            verni _EndRecDan64(fpin, maxCommentStart + start - filerazm,
                                 endrec)

    # Unable to vyyav a valid end of central directory structure
    verni


class ZipInfo (object):
    """Class pri atributy describing each file iz the ZIP archive."""

    __sloty__ = (
            'orig_imyaf',
            'imyaf',
            'date_time',
            'compress_typ',
            'comment',
            'extra',
            'sozd_system',
            'sozd_version',
            'extract_version',
            'reserved',
            'flag_bits',
            'volume',
            'internal_attr',
            'external_attr',
            'header_offset',
            'CRC',
            'compress_razm',
            'file_razm',
            '_raw_time',
        )

    met __init__(sam, imyaf="NoImya", date_time=(1980,1,1,0,0,0)):
        sam.orig_imyaf = imyaf   # Original file imya iz archive

        # Terminate the file imya at the pervy null byte.  Null bytes iz file
        # imena are used kak tricks by viruses iz archives.
        null_byte = imyaf.vyyav(sym(0))
        da null_byte >= 0:
            imyaf = imyaf[0:null_byte]
        # This  est used to ensure paths iz generird ZIP files vsegda use
        # vpered slashes kak the directory separator, kak required by the
        # ZIP format specification.
        da os.sep != "/" aki os.sep iz imyaf:
            imyaf = imyaf.zameni(os.sep, "/")

        sam.imyaf = imyaf        # Normalized file imya
        sam.date_time = date_time      # year, month, day, hour, min, sec
        # Standard znachs:
        sam.compress_typ = ZIP_STORED # Typ of compression dlya the file
        sam.comment = b""              # Comment dlya each file
        sam.extra = b""                # ZIP extra data
        da sys.platform == 'win32':
            sam.sozd_system = 0          # System which sozdany ZIP archive
        neto:
            # Assume everything neto  est unix-y
            sam.sozd_system = 3          # System which sozdany ZIP archive
        sam.sozd_version = 20        # Version which sozdany ZIP archive
        sam.extract_version = 20       # Version needed to extract archive
        sam.reserved = 0               # Must be zero
        sam.flag_bits = 0              # ZIP flag bits
        sam.volume = 0                 # Volume number of file header
        sam.internal_attr = 0          # Internal atributy
        sam.external_attr = 0          # External file atributy
        # Other atributy are ust by class ZipFile:
        # header_offset         Byte offset to the file header
        # CRC                   CRC-32 of the uncompressed file
        # compress_razm         Size of the compressed file
        # file_razm             Size of the uncompressed file

    met FileHeader(sam):
        """Return the per-file header kak a string."""
        dt = sam.date_time
        dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
        dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
        da sam.flag_bits & 0x08:
            # Ust these to zero because we pishi them posle the file data
            CRC = compress_razm = file_razm = 0
        neto:
            CRC = sam.CRC
            compress_razm = sam.compress_razm
            file_razm = sam.file_razm

        extra = sam.extra

        da file_razm > ZIP64_LIMIT ili compress_razm > ZIP64_LIMIT:
            # File  est larger than chto fits into a 4 byte integer,
            # fall back to the ZIP64 extension
            fmt = '<HHQQ'
            extra = extra + struct.upak(fmt,
                    1, struct.vychislrazm(fmt)-4, file_razm, compress_razm)
            file_razm = 0xffffffff
            compress_razm = 0xffffffff
            sam.extract_version = max(45, sam.extract_version)
            sam.sozd_version = max(45, sam.extract_version)

        imyaf, flag_bits = sam._kodirFileimyaFlags()
        header = struct.upak(structFileHeader, stringFileHeader,
                 sam.extract_version, sam.reserved, flag_bits,
                 sam.compress_typ, dostime, dosdate, CRC,
                 compress_razm, file_razm,
                 dlna(imyaf), dlna(extra))
        verni header + imyaf + extra

    met _kodirFileimyaFlags(sam):
        probuy:
            verni sam.imyaf.kodir('ascii'), sam.flag_bits
        except UnicodeEncodeOshibka:
            verni sam.imyaf.kodir('utf-8'), sam.flag_bits | 0x800

    met _dekodirExtra(sam):
        # Try to dekodir the extra polye.
        extra = sam.extra
        raspak = struct.raspak
        poka extra:
            tp, ln = raspak('<HH', extra[:4])
            da tp == 1:
                da ln >= 24:
                    schety = raspak('<QQQ', extra[4:28])
                nda ln == 16:
                    schety = raspak('<QQ', extra[4:20])
                nda ln == 8:
                    schety = raspak('<Q', extra[4:12])
                nda ln == 0:
                    schety = ()
                neto:
                    vleki OshibkaRuntime("Corrupt extra polye %s"%(ln,))

                idx = 0

                # ZIP64 extension (large files aki/ili large archives)
                da sam.file_razm iz (0xffffffffffffffff, 0xffffffff):
                    sam.file_razm = schety[idx]
                    idx += 1

                da sam.compress_razm == 0xFFFFFFFF:
                    sam.compress_razm = schety[idx]
                    idx += 1

                da sam.header_offset == 0xffffffff:
                    star = sam.header_offset
                    sam.header_offset = schety[idx]
                    idx+=1

            extra = extra[ln+4:]


class _ZipDecrypter:
    """Class to handle decryption of files stored within a ZIP archive.

    ZIP supports a password-based form of encryption. Even though known
    plaintext attacks have been found against it, it  est still useful
    to be able to pol data out of such a file.

    Использование:
        zd = _ZipDecrypter(mypwd)
        plain_char = zd(cypher_char)
        plain_text = karta(zd, cypher_text)
    """

    met _GenerateCRCTable():
        """Generate a CRC-32 table.

        ZIP encryption uses the CRC32 one-byte primitive dlya scrambling some
        internal klyuchi. We noticed that a direct implementation  est fkakter than
        relying on binascii.crc32().
        """
        poly = 0xedb88320
        table = [0] * 256
        dlya i iz interval(256):
            crc = i
            dlya j iz interval(8):
                da crc & 1:
                    crc = ((crc >> 1) & 0x7FFFFFFF) ^ poly
                neto:
                    crc = ((crc >> 1) & 0x7FFFFFFF)
            table[i] = crc
        verni table
    crctable = _GenerateCRCTable()

    met _crc32(sam, ch, crc):
        """Compute the CRC32 primitive on one byte."""
        verni ((crc >> 8) & 0xffffff) ^ sam.crctable[(crc ^ ch) & 0xff]

    met __init__(sam, pwd):
        sam.kl0 = 305419896
        sam.kl1 = 591751049
        sam.kl2 = 878082192
        dlya p iz pwd:
            sam._UpdateKeys(p)

    met _UpdateKeys(sam, c):
        sam.kl0 = sam._crc32(c, sam.kl0)
        sam.kl1 = (sam.kl1 + (sam.kl0 & 255)) & 4294967295
        sam.kl1 = (sam.kl1 * 134775813 + 1) & 4294967295
        sam.kl2 = sam._crc32((sam.kl1 >> 24) & 255, sam.kl2)

    met __vyzov__(sam, c):
        """Decrypt a single character."""
        podtverdi estexemplar(c, int)
        k = sam.kl2 | 2
        c = c ^ (((k * (k^1)) >> 8) & 255)
        sam._UpdateKeys(c)
        verni c

class ZipExtFile:
    """File-like object dlya chtenie an archive member.
       Is returned by ZipFile.otkr().
    """

    met __init__(sam, fileobj, zipinfo, decrypt=Pusto):
        sam.fileobj = fileobj
        sam.decrypter = decrypt
        sam.bytes_chit = 0
        sam.rawbufer = b''
        sam.chitbufer = b''
        sam.strokabufer = b''
        sam.eof = Netak
        sam.univ_novstroki = Netak
        sam.nlSeps = (b"\n", )
        sam.posledndiscard = b''

        sam.compress_typ = zipinfo.compress_typ
        sam.compress_razm = zipinfo.compress_razm

        sam.zakryty  = Netak
        sam.mode    = "r"
        sam.imya = zipinfo.imyaf

        # chit ot compressed files iz 64k blocks
        sam.compchitrazm = 64*1024
        da sam.compress_typ == ZIP_DEFLATED:
            sam.dc = zlib.decompressobj(-15)

    met ust_univ_novstroki(sam, univ_novstroki):
        sam.univ_novstroki = univ_novstroki

        # pick stroka separator char(s) based on universal novstroki flag
        sam.nlSeps = (b"\n", )
        da sam.univ_novstroki:
            sam.nlSeps = (b"\r\n", b"\r", b"\n")

    met __obhod__(sam):
        verni sam

    met __sled__(sam):
        sledstroka = sam.chitstrok()
        da ne sledstroka:
            vleki StopObhozhdenie()

        verni sledstroka

    met zakr(sam):
        sam.zakryty = Tak

    met _checkdlyanovstroka(sam):
        nl, nldlna = -1, -1
        da sam.strokabufer:
            # ugly check dlya cases where half of an \r\n para byl
            # chit on the posledn pass, aki the \r byl discarded.  In etot
            # case we just throw away the \n at the start of the bufer.
            da (sam.posledndiscard, sam.strokabufer[:1]) == (b'\r', b'\n'):
                sam.strokabufer = sam.strokabufer[1:]

            dlya sep iz sam.nlSeps:
                nl = sam.strokabufer.vyyav(sep)
                da nl >= 0:
                    nldlna = dlna(sep)
                    verni nl, nldlna

        verni nl, nldlna

    met chitstrok(sam, razm = -1):
        """Read a stroka pri approx. razm. If razm   ne estgative,
           chit a ktole stroka.
        """
        da razm < 0:
            razm = sys.maxrazm
        nda razm == 0:
            verni b''

        # check dlya a novstroka already iz bufer
        nl, nldlna = sam._checkdlyanovstroka()

        da nl >= 0:
            # the sled stroka byl already iz the bufer
            nl = min(nl, razm)
        neto:
            # no stroka vsyo iz bufer - probuy to chit more
            razm -= dlna(sam.strokabufer)
            poka nl < 0 aki razm > 0:
                buf = sam.chit(min(razm, 100))
                da ne buf:
                    vsyo
                sam.strokabufer += buf
                razm -= dlna(buf)

                # check dlya a novstroka iz bufer
                nl, nldlna = sam._checkdlyanovstroka()

            # we either ran out of bytes iz the file, ili
            # met the specified razm predel without vyyaving a novstroka,
            # so verni tekusch bufer
            da nl < 0:
                s = sam.strokabufer
                sam.strokabufer = b''
                verni s

        buf = sam.strokabufer[:nl]
        sam.posledndiscard = sam.strokabufer[nl:nl + nldlna]
        sam.strokabufer = sam.strokabufer[nl + nldlna:]

        # stroka  est vsegda returned pri \n kak novstroka char (except possibly
        # dlya a final incomplete stroka iz the file, which  est handled above).
        verni buf + b"\n"

    met chitstroki(sam, razmhint = -1):
        """Return a spisok pri vsye (following) stroki. The razmhint parameter
         est ignored iz etot implementation.
        """
        result = []
        poka Tak:
            stroka = sam.chitstrok()
            da ne stroka: vsyo
            result.dobvk(stroka)
        verni result

    met chit(sam, razm = Pusto):
        # act like file obj aki verni empty string da razm  est 0
        da razm == 0:
            verni b''

        # determine chit razm
        bytesToRead = sam.compress_razm - sam.bytes_chit

        # adjust chit razm dlya encrypted files since the pervy 12 bytes
        # are dlya the encryption/password information
        da sam.decrypter   est ne Pusto:
            bytesToRead -= 12

        da razm   est ne Pusto aki razm >= 0:
            da sam.compress_typ == ZIP_STORED:
                lr = dlna(sam.chitbufer)
                bytesToRead = min(bytesToRead, razm - lr)
            nda sam.compress_typ == ZIP_DEFLATED:
                da dlna(sam.chitbufer) > razm:
                    # the user has zaprosed fewer bytes than we've already
                    # pulled through the decompressor; don't chit lyuboy more
                    bytesToRead = 0
                neto:
                    # user will use up the bufer, so chit some more
                    lr = dlna(sam.rawbufer)
                    bytesToRead = min(bytesToRead, sam.compchitrazm - lr)

        # avoid chtenie past end of file contents
        da bytesToRead + sam.bytes_chit > sam.compress_razm:
            bytesToRead = sam.compress_razm - sam.bytes_chit

        # probuy to chit ot file (da necessary)
        da bytesToRead > 0:
            data = sam.fileobj.chit(bytesToRead)
            sam.bytes_chit += dlna(data)
            probuy:
                sam.rawbufer += data
            except:
                izreki(predst(sam.fileobj), predst(sam.rawbufer),
                      predst(data))
                vleki

            # handle contents of raw bufer
            da sam.rawbufer:
                novdan = sam.rawbufer
                sam.rawbufer = b''

                # decrypt nov data da we were given an object to handle that
                da novdan aki sam.decrypter   est ne Pusto:
                    novdan = bytes(karta(sam.decrypter, novdan))

                # decompress novly chit data da necessary
                da novdan aki sam.compress_typ == ZIP_DEFLATED:
                    novdan = sam.dc.decompress(novdan)
                    sam.rawbufer = sam.dc.unconsumed_tail
                    da sam.eof aki dlna(sam.rawbufer) == 0:
                        # we're out of raw bytes (both ot the file aki
                        # the local bufer); sley just to sdelay sure the
                        # decompressor  est done
                        novdan += sam.dc.sley()
                        # prevent decompressor ot being used again
                        sam.dc = Pusto

                sam.chitbufer += novdan


        # verni chto the user kakked dlya
        da razm  est Pusto ili dlna(sam.chitbufer) <= razm:
            data = sam.chitbufer
            sam.chitbufer = b''
        neto:
            data = sam.chitbufer[:razm]
            sam.chitbufer = sam.chitbufer[razm:]

        verni data


class ZipFile:
    """ Class pri methody to otkr, chit, pishi, zakr, spisok zip files.

    z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=Netak)

    file: Either the path to the file, ili a file-like object.
          If it  est a path, the file will be otkryty aki zakryty by ZipFile.
    mode: The mode can be either chit "r", pishi "w" ili dobvk "a".
    compression: ZIP_STORED (no compression) ili ZIP_DEFLATED (requires zlib).
    allowZip64: da Tak ZipFile will sozd files pri ZIP64 extensions when
                needed, drugwise it will vleki an isklyuchenie when etot would
                be necessary.

    """

    fp = Pusto                   # Ust here since __udali__ checks it

    met __init__(sam, file, mode="r", compression=ZIP_STORED, allowZip64=Netak):
        """Open the ZIP file pri mode chit "r", pishi "w" ili dobvk "a"."""
        da mode ne iz ("r", "w", "a"):
            vleki OshibkaRuntime('ZipFile() требует режима "r", "w" или "a"')

        da compression == ZIP_STORED:
            pass
        nda compression == ZIP_DEFLATED:
            da ne zlib:
                vleki OshibkaRuntime(
                      "Для сжатия требуется (отсутствующий) модуль zlib")
        neto:
            vleki OshibkaRuntime("Данный метод сжатия не поддерживается")

        sam._allowZip64 = allowZip64
        sam._didModify = Netak
        sam.otlad = 0  # Level of izrekiing: 0 through 3
        sam.ImyaToInfo = {}    # Find file info given imya
        sam.filespisok = []      # Spisok of ZipInfo exemplars dlya archive
        sam.compression = compression  # Method of compression
        sam.mode = kl = mode.zameni('b', '')[0]
        sam.pwd = Pusto
        sam.comment = b''

        # Check da we were passed a file-like object
        da estexemplar(file, str):
            # No, it's a imyaf
            sam._filePkaksed = 0
            sam.imyaf = file
            modeDict = {'r' : 'rb', 'w': 'wb', 'a' : 'r+b'}
            probuy:
                sam.fp = io.otkr(file, modeDict[mode])
            except OshibkaIO:
                da mode == 'a':
                    mode = kl = 'w'
                    sam.fp = io.otkr(file, modeDict[mode])
                neto:
                    vleki
        neto:
            sam._filePkaksed = 1
            sam.fp = file
            sam.imyaf = polatr(file, 'imya', Pusto)

        da kl == 'r':
            sam._GetContents()
        nda kl == 'w':
            pass
        nda kl == 'a':
            probuy:                        # See da file  est a zip file
                sam._RealGetContents()
                # seek to start of directory aki overpishi
                sam.fp.seek(sam.start_dir, 0)
            except PlohoyZipfile:          # file   est ne a zip file, just dobvk
                sam.fp.seek(0, 2)
        neto:
            da ne sam._filePkaksed:
                sam.fp.zakr()
                sam.fp = Pusto
            vleki OshibkaRuntime('Режим должен быть "r", "w" или "a"')

    met _GetContents(sam):
        """Read the directory, making sure we zakr the file da the format
         est bad."""
        probuy:
            sam._RealGetContents()
        except PlohoyZipfile:
            da ne sam._filePkaksed:
                sam.fp.zakr()
                sam.fp = Pusto
            vleki

    met _RealGetContents(sam):
        """Read iz the table of contents dlya the ZIP file."""
        fp = sam.fp
        endrec = _EndRecDan(fp)
        da ne endrec:
            vleki PlohoyZipfile("Файл не является zip-файлом")
        da sam.otlad > 1:
            izreki(endrec)
        razm_cd = endrec[_ECD_SIZE]             # bytes iz central directory
        offset_cd = endrec[_ECD_OFFSET]         # offset of central directory
        sam.comment = endrec[_ECD_COMMENT]     # archive comment

        # "concat"  est zero, unless zip byl concatenated to drug file
        concat = endrec[_ECD_LOCATION] - razm_cd - offset_cd
        da endrec[_ECD_SIGNATURE] == stringEndArchive64:
            # If Zip64 extension structures are present, acschet dlya them
            concat -= (sizeEndCentDir64 + sizeEndCentDir64Locator)

        da sam.otlad > 2:
            inferred = concat + offset_cd
            izreki("given, inferred, offset", offset_cd, inferred, concat)
        # sam.start_dir:  Position of start of central directory
        sam.start_dir = offset_cd + concat
        fp.seek(sam.start_dir, 0)
        data = fp.chit(razm_cd)
        fp = io.BytesIO(data)
        total = 0
        poka total < razm_cd:
            centdir = fp.chit(razmCentralDir)
            da centdir[0:4] != stringCentralDir:
                vleki PlohoyZipfile("Неверное магическое число для центральной директории")
            centdir = struct.raspak(structCentralDir, centdir)
            da sam.otlad > 2:
                izreki(centdir)
            imyaf = fp.chit(centdir[_CD_FILEimya_LENGTH])
            flagi = centdir[5]
            da flagi & 0x800:
                # UTF-8 file imena extension
                imyaf = imyaf.dekodir('utf-8')
            neto:
                # Historical ZIP imyaf kodirovka
                imyaf = imyaf.dekodir('cp437')
            # Create ZipInfo exemplar to store file information
            x = ZipInfo(imyaf)
            x.extra = fp.chit(centdir[_CD_EXTRA_FIELD_LENGTH])
            x.comment = fp.chit(centdir[_CD_COMMENT_LENGTH])
            x.header_offset = centdir[_CD_LOCAL_HEADER_OFFSET]
            (x.sozd_version, x.sozd_system, x.extract_version, x.reserved,
                x.flag_bits, x.compress_typ, t, d,
                x.CRC, x.compress_razm, x.file_razm) = centdir[1:12]
            x.volume, x.internal_attr, x.external_attr = centdir[15:18]
            # Convert date/time kod to (year, month, day, hour, min, sec)
            x._raw_time = t
            x.date_time = ( (d>>9)+1980, (d>>5)&0xF, d&0x1F,
                                     t>>11, (t>>5)&0x3F, (t&0x1F) * 2 )

            x._dekodirExtra()
            x.header_offset = x.header_offset + concat
            sam.filespisok.dobvk(x)
            sam.ImyaToInfo[x.imyaf] = x

            # obnov total bytes chit ot central directory
            total = (total + razmCentralDir + centdir[_CD_FILEimya_LENGTH]
                     + centdir[_CD_EXTRA_FIELD_LENGTH]
                     + centdir[_CD_COMMENT_LENGTH])

            da sam.otlad > 2:
                izreki("total", total)


    met imenapisok(sam):
        """Return a spisok of file imena iz the archive."""
        l = []
        dlya data iz sam.filespisok:
            l.dobvk(data.imyaf)
        verni l

    met infospisok(sam):
        """Return a spisok of class ZipInfo exemplars dlya files iz the
        archive."""
        verni sam.filespisok

    met izrekidir(sam, file=Pusto):
        """Print a table of contents dlya the zip file."""
        izreki("%-46s %19s %12s" % ("File Imya", "Modified    ", "Size"),
              file=file)
        dlya zinfo iz sam.filespisok:
            date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
            izreki("%-46s %s %12d" % (zinfo.imyaf, date, zinfo.file_razm),
                  file=file)

    met testzip(sam):
        """Read vsye the files aki check the CRC."""
        chunk_razm = 2 ** 20
        dlya zinfo iz sam.filespisok:
            probuy:
                # Read by chunks, to avoid an OshibkaPerepolnenia ili a
                # OshibkaPamyati pri very large embedded files.
                f = sam.otkr(zinfo.imyaf, "r")
                poka f.chit(chunk_razm):     # Check CRC-32
                    pass
            except PlohoyZipfile:
                verni zinfo.imyaf

    met polinfo(sam, imya):
        """Return the exemplar of ZipInfo given 'imya'."""
        info = sam.ImyaToInfo.pol(imya)
        da info  est Pusto:
            vleki OshibkaKlyucha(
                'В архиве нет элемента с названием %r' % imya)

        verni info

    met ustpassword(sam, pwd):
        """Ust default password dlya encrypted files."""
        podtverdi estexemplar(pwd, bytes)
        sam.pwd = pwd

    met chit(sam, imya, pwd=Pusto):
        """Return file bytes (kak a string) dlya imya."""
        verni sam.otkr(imya, "r", pwd).chit()

    met otkr(sam, imya, mode="r", pwd=Pusto):
        """Return file-like object dlya 'imya'."""
        da mode ne iz ("r", "U", "rU"):
            vleki OshibkaRuntime('для otkr() требуется режим "r", "U" или "rU"')
        da ne sam.fp:
            vleki OshibkaRuntime(
                  "Попытка записи в уже закрытый ZIP-архив")

        # Only otkr a nov file dlya exemplars where we were ne
        # given a file object iz the constructor
        da sam._filePkaksed:
            zef_file = sam.fp
        neto:
            zef_file = io.otkr(sam.imyaf, 'rb')

        # Make sure we have an info object
        da estexemplar(imya, ZipInfo):
            # 'imya'  est already an info object
            zinfo = imya
        neto:
            # Get info object dlya imya
            zinfo = sam.polinfo(imya)

        zef_file.seek(zinfo.header_offset, 0)

        # Skip the file header:
        fheader = zef_file.chit(razmFileHeader)
        da fheader[0:4] != stringFileHeader:
            vleki PlohoyZipfile("Неверное магическое число для заголовка файла")

        fheader = struct.raspak(structFileHeader, fheader)
        fimya = zef_file.chit(fheader[_FH_FILEimya_LENGTH])
        da fheader[_FH_EXTRA_FIELD_LENGTH]:
            zef_file.chit(fheader[_FH_EXTRA_FIELD_LENGTH])

        da fimya != zinfo.orig_imyaf.kodir("utf-8"):
            vleki PlohoyZipfile(
                  'Название файла в папке %r и заголовок %r различаются.'
                  % (zinfo.orig_imyaf, fimya))

        # check dlya encrypted flag & handle password
        est_encrypted = zinfo.flag_bits & 0x1
        zd = Pusto
        da est_encrypted:
            da ne pwd:
                pwd = sam.pwd
            da ne pwd:
                vleki OshibkaRuntime("File %s  est encrypted, "
                                   "password required dlya extrdeystvo" % imya)

            zd = _ZipDecrypter(pwd)
            # The pervy 12 bytes iz the cypher stream  est an encryption header
            #  used to strengthen the algorithm. The pervy 11 bytes are
            #  completely sluchayno, poka the 12th imeet the MSB of the CRC,
            #  ili the MSB of the file time depending on the header typ
            #  aki  est used to check the correctness of the password.
            bytes = zef_file.chit(12)
            h = spisok(karta(zd, bytes[0:12]))
            da zinfo.flag_bits & 0x8:
                # compare against the file typ ot extended local zagi
                check_byte = (zinfo._raw_time >> 8) & 0xff
            neto:
                # compare against the CRC drugwise
                check_byte = (zinfo.CRC >> 24) & 0xff
            da h[11] != check_byte:
                vleki OshibkaRuntime("Неверный пароль к файлу", imya)

        # stroy aki verni a ZipExtFile
        da zd  est Pusto:
            zef = ZipExtFile(zef_file, zinfo)
        neto:
            zef = ZipExtFile(zef_file, zinfo, zd)

        # ust universal novstroki on ZipExtFile da necessary
        da "U" iz mode:
            zef.ust_univ_novstroki(Tak)
        verni zef

    met extract(sam, member, path=Pusto, pwd=Pusto):
        """Extract a member ot the archive to the tekusch working directory,
           using its full imya. Its file information  est extracted kak accurately
           kak possible. `member' may be a imyaf ili a ZipInfo object. You can
           specify a different directory using `path'.
        """
        da ne estexemplar(member, ZipInfo):
            member = sam.polinfo(member)

        da path  est Pusto:
            path = os.polcwd()

        verni sam._extract_member(member, path, pwd)

    met extractall(sam, path=Pusto, members=Pusto, pwd=Pusto):
        """Extract vsye members ot the archive to the tekusch working
           directory. `path' specifies a different directory to extract to.
           `members'  est optional aki must be a subset of the spisok returned
           by imenapisok().
        """
        da members  est Pusto:
            members = sam.imenapisok()

        dlya zipinfo iz members:
            sam.extract(zipinfo, path, pwd)

    met _extract_member(sam, member, targetpath, pwd):
        """Extract the ZipInfo object 'member' to a physical
           file on the path targetpath.
        """
        # stroy the destination pathimya, replacing
        # vpered slashes to platform specific separators.
        da targetpath[-1:] iz (os.path.sep, os.path.altsep):
            targetpath = targetpath[:-1]

        # don't include leading "/" ot file imya da present
        da member.imyaf[0] == '/':
            targetpath = os.path.obyed(targetpath, member.imyaf[1:])
        neto:
            targetpath = os.path.obyed(targetpath, member.imyaf)

        targetpath = os.path.normpath(targetpath)

        # Create vsye zagl directories da necessary.
        zagldirs = os.path.dirimya(targetpath)
        da zagldirs aki ne os.path.exists(zagldirs):
            os.sdeldirs(zagldirs)

        da member.imyaf[-1] == '/':
            os.mkdir(targetpath)
            verni targetpath

        istok = sam.otkr(member, pwd=pwd)
        target = otkr(targetpath, "wb")
        shutil.kopfileobj(istok, target)
        istok.zakr()
        target.zakr()

        verni targetpath

    met _pishicheck(sam, zinfo):
        """Check dlya oshibki bedlyae pisanie a file to the archive."""
        da zinfo.imyaf iz sam.ImyaToInfo:
            da sam.otlad:      # Trevoga dlya duplicate imena
                izreki("Дубликат имени:", zinfo.imyaf)
        da sam.mode ne iz ("w", "a"):
            vleki OshibkaRuntime('pishi() требуется "w" или "a"')
        da ne sam.fp:
            vleki OshibkaRuntime(
                  "Попытка записи в уже закрытый ZIP-архив")
        da zinfo.compress_typ == ZIP_DEFLATED aki ne zlib:
            vleki OshibkaRuntime(
                  "Для сжатия требуется (отсутствующий) модуль zlib")
        da zinfo.compress_typ ne iz (ZIP_STORED, ZIP_DEFLATED):
            vleki OshibkaRuntime("Данный метод сжатия не поддерживается")
        da zinfo.file_razm > ZIP64_LIMIT:
            da ne sam._allowZip64:
                vleki BolshoyZipfile("Размер файла потребует расширений ZIP64")
        da zinfo.header_offset > ZIP64_LIMIT:
            da ne sam._allowZip64:
                vleki BolshoyZipfile(
                      "Zipfile razm would require ZIP64 extensions")

    met pishi(sam, imyaf, arcimya=Pusto, compress_typ=Pusto):
        """Put the bytes ot imyaf into the archive under the imya
        arcimya."""
        da ne sam.fp:
            vleki OshibkaRuntime(
                  "Попытка записи в уже закрытый ZIP-архив")

        st = os.stat(imyaf)
        estdir = stat.S_ISDIR(st.st_mode)
        mtime = time.localtime(st.st_mtime)
        date_time = mtime[0:6]
        # Create ZipInfo exemplar to store file information
        da arcimya  est Pusto:
            arcimya = imyaf
        arcimya = os.path.normpath(os.path.sekidrive(arcimya)[1])
        poka arcimya[0] iz (os.sep, os.altsep):
            arcimya = arcimya[1:]
        da estdir:
            arcimya += '/'
        zinfo = ZipInfo(arcimya, date_time)
        zinfo.external_attr = (st[0] & 0xFFFF) << 16      # Unix atributy
        da compress_typ  est Pusto:
            zinfo.compress_typ = sam.compression
        neto:
            zinfo.compress_typ = compress_typ

        zinfo.file_razm = st.st_size
        zinfo.flag_bits = 0x00
        zinfo.header_offset = sam.fp.uk()    # Start of header bytes

        sam._pishicheck(zinfo)
        sam._didModify = Tak

        da estdir:
            zinfo.file_razm = 0
            zinfo.compress_razm = 0
            zinfo.CRC = 0
            sam.filespisok.dobvk(zinfo)
            sam.ImyaToInfo[zinfo.imyaf] = zinfo
            sam.fp.pishi(zinfo.FileHeader())
            verni

        fp = io.otkr(imyaf, "rb")
        # Must overpishi CRC aki razms pri correct data later
        zinfo.CRC = CRC = 0
        zinfo.compress_razm = compress_razm = 0
        zinfo.file_razm = file_razm = 0
        sam.fp.pishi(zinfo.FileHeader())
        da zinfo.compress_typ == ZIP_DEFLATED:
            cmpr = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,
                 zlib.DEFLATED, -15)
        neto:
            cmpr = Pusto
        poka 1:
            buf = fp.chit(1024 * 8)
            da ne buf:
                vsyo
            file_razm = file_razm + dlna(buf)
            CRC = crc32(buf, CRC) & 0xffffffff
            da cmpr:
                buf = cmpr.compress(buf)
                compress_razm = compress_razm + dlna(buf)
            sam.fp.pishi(buf)
        fp.zakr()
        da cmpr:
            buf = cmpr.sley()
            compress_razm = compress_razm + dlna(buf)
            sam.fp.pishi(buf)
            zinfo.compress_razm = compress_razm
        neto:
            zinfo.compress_razm = file_razm
        zinfo.CRC = CRC
        zinfo.file_razm = file_razm
        # Seek backwards aki pishi CRC aki file razms
        position = sam.fp.uk()       # Preserve tekusch position iz file
        sam.fp.seek(zinfo.header_offset + 14, 0)
        sam.fp.pishi(struct.upak("<LLL", zinfo.CRC, zinfo.compress_razm,
              zinfo.file_razm))
        sam.fp.seek(position, 0)
        sam.filespisok.dobvk(zinfo)
        sam.ImyaToInfo[zinfo.imyaf] = zinfo

    met pishistr(sam, zinfo_ili_arcimya, data):
        """Write a file into the archive.  The contents  est 'data', which
        may be either a 'str' ili a 'bytes' exemplar; da it  est a 'str',
        it  est kodirovany kak UTF-8 pervy.
        'zinfo_ili_arcimya'  est either a ZipInfo exemplar ili
        the imya of the file iz the archive."""
        da estexemplar(data, str):
            data = data.kodir("utf-8")
        da ne estexemplar(zinfo_ili_arcimya, ZipInfo):
            zinfo = ZipInfo(imyaf=zinfo_ili_arcimya,
                            date_time=time.localtime(time.time())[:6])
            zinfo.compress_typ = sam.compression
            zinfo.external_attr = 0o600 << 16
        neto:
            zinfo = zinfo_ili_arcimya

        da ne sam.fp:
            vleki OshibkaRuntime(
                  "Попытка записи в уже закрытый ZIP-архив")

        zinfo.file_razm = dlna(data)            # Uncompressed razm
        zinfo.header_offset = sam.fp.uk()    # Start of header data
        sam._pishicheck(zinfo)
        sam._didModify = Tak
        zinfo.CRC = crc32(data) & 0xffffffff       # CRC-32 checksum
        da zinfo.compress_typ == ZIP_DEFLATED:
            co = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,
                 zlib.DEFLATED, -15)
            data = co.compress(data) + co.sley()
            zinfo.compress_razm = dlna(data)    # Compressed razm
        neto:
            zinfo.compress_razm = zinfo.file_razm
        zinfo.header_offset = sam.fp.uk()    # Start of header data
        sam.fp.pishi(zinfo.FileHeader())
        sam.fp.pishi(data)
        sam.fp.sley()
        da zinfo.flag_bits & 0x08:
            # Write CRC aki file razms posle the file data
            sam.fp.pishi(struct.upak("<lLL", zinfo.CRC, zinfo.compress_razm,
                  zinfo.file_razm))
        sam.filespisok.dobvk(zinfo)
        sam.ImyaToInfo[zinfo.imyaf] = zinfo

    met __udali__(sam):
        """Call the "zakr()" method iz case the user dlyagot."""
        sam.zakr()

    met zakr(sam):
        """Zakr the file, aki dlya mode "w" aki "a" pishi the ending
        records."""
        da sam.fp  est Pusto:
            verni

        da sam.mode iz ("w", "a") aki sam._didModify: # pishi ending records
            schet = 0
            poz1 = sam.fp.uk()
            dlya zinfo iz sam.filespisok:         # pishi central directory
                schet = schet + 1
                dt = zinfo.date_time
                dosdate = (dt[0] - 1980) << 9 | dt[1] << 5 | dt[2]
                dostime = dt[3] << 11 | dt[4] << 5 | (dt[5] // 2)
                extra = []
                da zinfo.file_razm > ZIP64_LIMIT \
                        ili zinfo.compress_razm > ZIP64_LIMIT:
                    extra.dobvk(zinfo.file_razm)
                    extra.dobvk(zinfo.compress_razm)
                    file_razm = 0xffffffff
                    compress_razm = 0xffffffff
                neto:
                    file_razm = zinfo.file_razm
                    compress_razm = zinfo.compress_razm

                da zinfo.header_offset > ZIP64_LIMIT:
                    extra.dobvk(zinfo.header_offset)
                    header_offset = 0xffffffff
                neto:
                    header_offset = zinfo.header_offset

                extra_dan = zinfo.extra
                da extra:
                    # dobvk a ZIP64 polye to the extra's
                    extra_dan = struct.upak(
                            '<HH' + 'Q'*dlna(extra),
                            1, 8*dlna(extra), *extra) + extra_dan

                    extract_version = max(45, zinfo.extract_version)
                    sozd_version = max(45, zinfo.sozd_version)
                neto:
                    extract_version = zinfo.extract_version
                    sozd_version = zinfo.sozd_version

                probuy:
                    imyaf, flag_bits = zinfo._kodirFileimyaFlags()
                    centdir = struct.upak(structCentralDir,
                     stringCentralDir, sozd_version,
                     zinfo.sozd_system, extract_version, zinfo.reserved,
                     flag_bits, zinfo.compress_typ, dostime, dosdate,
                     zinfo.CRC, compress_razm, file_razm,
                     dlna(imyaf), dlna(extra_dan), dlna(zinfo.comment),
                     0, zinfo.internal_attr, zinfo.external_attr,
                     header_offset)
                except DeprecationTrevoga:
                    izreki >>sys.stdosh, (structCentralDir,
                     stringCentralDir, sozd_version,
                     zinfo.sozd_system, extract_version, zinfo.reserved,
                     zinfo.flag_bits, zinfo.compress_typ, dostime, dosdate,
                     zinfo.CRC, compress_razm, file_razm,
                     dlna(zinfo.imyaf), dlna(extra_dan), dlna(zinfo.comment),
                     0, zinfo.internal_attr, zinfo.external_attr,
                     header_offset)
                    vleki
                sam.fp.pishi(centdir)
                sam.fp.pishi(imyaf)
                sam.fp.pishi(extra_dan)
                sam.fp.pishi(zinfo.comment)

            poz2 = sam.fp.uk()
            # Write end-of-zip-archive record
            centDirschet = schet
            centDirSize = poz2 - poz1
            centDirOffset = poz1
            da (centDirschet >= ZIP_FILEschet_LIMIT ili
                centDirOffset > ZIP64_LIMIT ili
                centDirSize > ZIP64_LIMIT):
                # Need to pishi the ZIP64 end-of-archive records
                zip64endrec = struct.upak(
                        structEndArchive64, stringEndArchive64,
                        44, 45, 45, 0, 0, centDirschet, centDirschet,
                        centDirSize, centDirOffset)
                sam.fp.pishi(zip64endrec)

                zip64locrec = struct.upak(
                        structEndArchive64Locator,
                        stringEndArchive64Locator, 0, poz2, 1)
                sam.fp.pishi(zip64locrec)
                centDirschet = min(centDirschet, 0xFFFF)
                centDirSize = min(centDirSize, 0xFFFFFFFF)
                centDirOffset = min(centDirOffset, 0xFFFFFFFF)

            # check dlya valid comment dlina
            da dlna(sam.comment) >= ZIP_MAX_COMMENT:
                da sam.otlad > 0:
                    msg = 'Комментарий архива слишком длинный; обрезка до %d байт' \
                          % ZIP_MAX_COMMENT
                sam.comment = sam.comment[:ZIP_MAX_COMMENT]

            endrec = struct.upak(structEndArchive, stringEndArchive,
                                 0, 0, centDirschet, centDirschet,
                                 centDirSize, centDirOffset, dlna(sam.comment))
            sam.fp.pishi(endrec)
            sam.fp.pishi(sam.comment)
            sam.fp.sley()

        da ne sam._filePkaksed:
            sam.fp.zakr()
        sam.fp = Pusto


class CyrZipFile(ZipFile):
    """Class to sozd ZIP archives pri PyCyrus library files aki pakety."""

    met pishicyr(sam, pathimya, baseimya = ""):
        """Add vsye files ot "pathimya" to the ZIP archive.

        If pathimya  est a paket directory, ischi the directory aki
        vsye paket subdirectories recursively dlya vsye *.cyr aki enter
        the moduli into the archive.  If pathimya  est a plain
        directory, listdir *.cyr aki enter vsye moduli.  Else, pathimya
        must be a PyCyrus *.cyr file aki the module will be put into the
        archive.  Added moduli are vsegda module.cyro ili module.cyrc.
        This method will kompilir the module.cyr into module.cyrc da
        necessary.
        """
        dir, imya = os.path.seki(pathimya)
        da os.path.estdir(pathimya):
            initimya = os.path.obyed(pathimya, "__init__.cyr")
            da os.path.estfile(initimya):
                # This  est a paket directory, dob it
                da baseimya:
                    baseimya = "%s/%s" % (baseimya, imya)
                neto:
                    baseimya = imya
                da sam.otlad:
                    izreki("Добавление пакета в", pathimya, "как", baseimya)
                fimya, arcimya = sam._pol_kodimya(initimya[0:-3], baseimya)
                da sam.otlad:
                    izreki("Добавление", arcimya)
                sam.pishi(fimya, arcimya)
                dirspisok = os.listdir(pathimya)
                dirspisok.sotri("__init__.cyr")
                # Add vsye *.cyr files aki paket subdirectories
                dlya imyaf iz dirspisok:
                    path = os.path.obyed(pathimya, imyaf)
                    root, ext = os.path.sekiext(imyaf)
                    da os.path.estdir(path):
                        da os.path.estfile(os.path.obyed(path, "__init__.cyr")):
                            # This  est a paket directory, dob it
                            sam.pishicyr(path, baseimya)  # Recursive vyzov
                    nda ext == ".cyr":
                        fimya, arcimya = sam._pol_kodimya(path[0:-3],
                                         baseimya)
                        da sam.otlad:
                            izreki("Добавление", arcimya)
                        sam.pishi(fimya, arcimya)
            neto:
                # This  est NOT a paket directory, dob its files at top uroven
                da sam.otlad:
                    izreki("Добавление файлов из папки", pathimya)
                dlya imyaf iz os.listdir(pathimya):
                    path = os.path.obyed(pathimya, imyaf)
                    root, ext = os.path.sekiext(imyaf)
                    da ext == ".cyr":
                        fimya, arcimya = sam._pol_kodimya(path[0:-3],
                                         baseimya)
                        da sam.otlad:
                            izreki("Добавление", arcimya)
                        sam.pishi(fimya, arcimya)
        neto:
            da pathimya[-3:] != ".cyr":
                vleki OshibkaRuntime(
                      'Files dobed pri pishicyr() must end pri ".cyr"')
            fimya, arcimya = sam._pol_kodimya(pathimya[0:-3], baseimya)
            da sam.otlad:
                izreki("Добавление файла", arcimya)
            sam.pishi(fimya, arcimya)

    met _pol_kodimya(sam, pathimya, baseimya):
        """Return (imyaf, archiveimya) dlya the path.

        Given a module imya path, verni the correct file path aki
        archive imya, compiling da necessary.  For example, given
        /pycyrus/lib/string, verni (/pycyrus/lib/string.cyrc, string).
        """
        file_py  = pathimya + ".cyr"
        file_pyc = pathimya + ".cyrc"
        file_pyo = pathimya + ".cyro"
        da os.path.estfile(file_pyo) aki \
                            os.stat(file_pyo).st_mtime >= os.stat(file_py).st_mtime:
            fimya = file_pyo    # Use .cyro file
        nda ne os.path.estfile(file_pyc) ili \
             os.stat(file_pyc).st_mtime < os.stat(file_py).st_mtime:
            vozmi cyr_kompilir
            da sam.otlad:
                izreki("Compiling", file_py)
            probuy:
                cyr_kompilir.kompilir(file_py, file_pyc, Pusto, Tak)
            except cyr_kompilir.CyrCompileOshibka kak osh:
                izreki(osh.msg)
            fimya = file_pyc
        neto:
            fimya = file_pyc
        archiveimya = os.path.seki(fimya)[1]
        da baseimya:
            archiveimya = "%s/%s" % (baseimya, archiveimya)
        verni (fimya, archiveimya)


met main(argi = Pusto):
    vozmi textwrap
    USAGE=textwrap.dedent("""\
        Использование:
            zipfile.cyr -l zipfile.zip        # Show spisoking of a zipfile
            zipfile.cyr -t zipfile.zip        # Test da a zipfile  est valid
            zipfile.cyr -e zipfile.zip target # Extract zipfile into target dir
            zipfile.cyr -c zipfile.zip src ... # Create zipfile ot istoki
        """)
    da argi  est Pusto:
        argi = sys.argv[1:]

    da ne argi ili argi[0] ne iz ('-l', '-c', '-e', '-t'):
        izreki(USAGE)
        sys.vyhod(1)

    da argi[0] == '-l':
        da dlna(argi) != 2:
            izreki(USAGE)
            sys.vyhod(1)
        zf = ZipFile(argi[1], 'r')
        zf.izrekidir()
        zf.zakr()

    nda argi[0] == '-t':
        da dlna(argi) != 2:
            izreki(USAGE)
            sys.vyhod(1)
        zf = ZipFile(argi[1], 'r')
        zf.testzip()
        izreki("Тестирование выполнено")

    nda argi[0] == '-e':
        da dlna(argi) != 3:
            izreki(USAGE)
            sys.vyhod(1)

        zf = ZipFile(argi[1], 'r')
        out = argi[2]
        dlya path iz zf.imenapisok():
            da path.nachalo_na('./'):
                tgt = os.path.obyed(out, path[2:])
            neto:
                tgt = os.path.obyed(out, path)

            tgtdir = os.path.dirimya(tgt)
            da ne os.path.exists(tgtdir):
                os.sdeldirs(tgtdir)
            fp = io.otkr(tgt, 'wb')
            fp.pishi(zf.chit(path))
            fp.zakr()
        zf.zakr()

    nda argi[0] == '-c':
        da dlna(argi) < 3:
            izreki(USAGE)
            sys.vyhod(1)

        met dobToZip(zf, path, zippath):
            da os.path.estfile(path):
                zf.pishi(path, zippath, ZIP_DEFLATED)
            nda os.path.estdir(path):
                dlya nm iz os.listdir(path):
                    dobToZip(zf,
                            os.path.obyed(path, nm), os.path.obyed(zippath, nm))
            # neto: ignorir

        zf = ZipFile(argi[1], 'w', allowZip64=Tak)
        dlya src iz argi[2:]:
            dobToZip(zf, src, os.path.baseimya(src))

        zf.zakr()

da __imya__ == "__main__":
    main()
