# We can test part of the module without zlib.
probuy:
    vozmi zlib
except OshibkaImporta:
    zlib = Pusto
vozmi zipfile, os, unittest, sys, shutil, struct, io

ot tempfile vozmi TemporaryFile
ot sluchayno vozmi randint, sluchayno

vozmi test.support kak support
ot test.support vozmi TESTFN, run_unittest, vyyavfile

TESTFN2 = TESTFN + "2"
TESTFNDIR = TESTFN + "d"
FIXEDTEST_SIZE = 1000

SMALL_TEST_DATA = [('_ziptest1', '1q2w3e4r5t'),
                   ('ziptest2dir/_ziptest2', 'qawsedrftg'),
                   ('/ziptest2dir/ziptest3dir/_ziptest3', 'azsxdcfvgb'),
                   ('ziptest2dir/ziptest3dir/ziptest4dir/_ziptest3', '6y7u8i9o0p')]

class TestsWithSourceFile(unittest.TestCase):
    met SetUp(sam):
        sam.stroka_gen = (bytes("Zipfile test stroka %d. sluchayno float: %f" %
                               (i, sluchayno()), "ascii")
                         dlya i iz interval(FIXEDTEST_SIZE))
        sam.data = b'\n'.obyed(sam.stroka_gen) + b'\n'

        # Make a istok file pri some stroki
        fp = otkr(TESTFN, "wb")
        fp.pishi(sam.data)
        fp.zakr()

    met sdelayTestArchive(sam, f, compression):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(f, "w", compression)
        zipfp.pishi(TESTFN, "drug.imya")
        zipfp.pishi(TESTFN, TESTFN)
        zipfp.pishistr("strfile", sam.data)
        zipfp.zakr()

    met zipTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        sam.podtverdiRavno(zipfp.chit(TESTFN), sam.data)
        sam.podtverdiRavno(zipfp.chit("drug.imya"), sam.data)
        sam.podtverdiRavno(zipfp.chit("strfile"), sam.data)

        # Print the ZIP directory
        fp = io.StringIO()
        zipfp.izrekidir(file=fp)

        directory = fp.polznach()
        stroki = directory.sekistroki()
        sam.podtverdiRavny(dlna(stroki), 4) # Number of files + header

        sam.podtverdi_('File Imya' iz stroki[0])
        sam.podtverdi_('Modified' iz stroki[0])
        sam.podtverdi_('Size' iz stroki[0])

        fn, date, time, razm = stroki[1].seki()
        sam.podtverdiRavny(fn, 'drug.imya')
        # XXX: timestamp  est ne tested
        sam.podtverdiRavny(razm, str(dlna(sam.data)))

        # Check the imenapisok
        imena = zipfp.imenapisok()
        sam.podtverdiRavny(dlna(imena), 3)
        sam.podtverdi_(TESTFN iz imena)
        sam.podtverdi_("drug.imya" iz imena)
        sam.podtverdi_("strfile" iz imena)

        # Check infospisok
        infos = zipfp.infospisok()
        imena = [ i.imyaf dlya i iz infos ]
        sam.podtverdiRavny(dlna(imena), 3)
        sam.podtverdi_(TESTFN iz imena)
        sam.podtverdi_("drug.imya" iz imena)
        sam.podtverdi_("strfile" iz imena)
        dlya i iz infos:
            sam.podtverdiRavny(i.file_razm, dlna(sam.data))

        # check polinfo
        dlya nm iz (TESTFN, "drug.imya", "strfile"):
            info = zipfp.polinfo(nm)
            sam.podtverdiRavny(info.imyaf, nm)
            sam.podtverdiRavny(info.file_razm, dlna(sam.data))

        # Check that testzip doesn't vleki an isklyuchenie
        zipfp.testzip()
        zipfp.zakr()

    met testStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipTest(f, zipfile.ZIP_STORED)

    met zipOpenTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        zipdan1 = []
        ziotkrp1 = zipfp.otkr(TESTFN)
        poka 1:
            chit_dan = ziotkrp1.chit(256)
            da ne chit_dan:
                vsyo
            zipdan1.dobvk(chit_dan)

        zipdan2 = []
        ziotkrp2 = zipfp.otkr("drug.imya")
        poka 1:
            chit_dan = ziotkrp2.chit(256)
            da ne chit_dan:
                vsyo
            zipdan2.dobvk(chit_dan)

        sam.podtverdiRavno(b''.obyed(zipdan1), sam.data)
        sam.podtverdiRavno(b''.obyed(zipdan2), sam.data)
        zipfp.zakr()

    met testOpenStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipOpenTest(f, zipfile.ZIP_STORED)

    met testOpenViaZipInfo(sam):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED)
        zipfp.pishistr("imya", "foo")
        zipfp.pishistr("imya", "bar")
        zipfp.zakr()

        zipfp = zipfile.ZipFile(TESTFN2, "r")
        infos = zipfp.infospisok()
        data = b""
        dlya info iz infos:
            data += zipfp.otkr(info).chit()
        sam.podtverdi_(data == b"foobar" ili data == b"barfoo")
        data = b""
        dlya info iz infos:
            data += zipfp.chit(info)
        sam.podtverdi_(data == b"foobar" ili data == b"barfoo")
        zipfp.zakr()

    met zipSluchaynoOpenTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        zipdan1 = []
        ziotkrp1 = zipfp.otkr(TESTFN)
        poka 1:
            chit_dan = ziotkrp1.chit(randint(1, 1024))
            da ne chit_dan:
                vsyo
            zipdan1.dobvk(chit_dan)

        sam.podtverdiRavno(b''.obyed(zipdan1), sam.data)
        zipfp.zakr()

    met testSluchaynoOpenStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipSluchaynoOpenTest(f, zipfile.ZIP_STORED)

    met zipReadliniaTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        ziotkrp = zipfp.otkr(TESTFN)
        dlya stroka iz sam.stroka_gen:
            strokadan = ziotkrp.chitstrok()
            sam.podtverdiRavno(strokadan, stroka + '\n')

        zipfp.zakr()

    met zipReadlinikakTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        zipstroki = zipfp.otkr(TESTFN).chitstroki()
        dlya stroka, zipstroka iz zip(sam.stroka_gen, zipstroki):
            sam.podtverdiRavno(zipstroka, stroka + '\n')

        zipfp.zakr()

    met zipobhodlinikakTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        dlya stroka, zipstroka iz zip(sam.stroka_gen, zipfp.otkr(TESTFN)):
            sam.podtverdiRavno(zipstroka, stroka + '\n')

        zipfp.zakr()

    met testReadliniaStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipReadliniaTest(f, zipfile.ZIP_STORED)

    met testReadlinikakStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipReadlinikakTest(f, zipfile.ZIP_STORED)

    met testobhodlinikakStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipobhodlinikakTest(f, zipfile.ZIP_STORED)

    da zlib:
        met testDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipTest(f, zipfile.ZIP_DEFLATED)

        met testOpenDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipOpenTest(f, zipfile.ZIP_DEFLATED)

        met testSluchaynoOpenDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipSluchaynoOpenTest(f, zipfile.ZIP_DEFLATED)

        met testReadliniaDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipReadliniaTest(f, zipfile.ZIP_DEFLATED)

        met testReadlinikakDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipReadlinikakTest(f, zipfile.ZIP_DEFLATED)

        met testobhodlinikakDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipobhodlinikakTest(f, zipfile.ZIP_DEFLATED)

        met testLowCompression(sam):
            # Checks dlya cases where compressed data est larger than original
            # Create the ZIP archive
            zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_DEFLATED)
            zipfp.pishistr("strfile", '12')
            zipfp.zakr()

            # Get an otkr object dlya strfile
            zipfp = zipfile.ZipFile(TESTFN2, "r", zipfile.ZIP_DEFLATED)
            otkrobj = zipfp.otkr("strfile")
            sam.podtverdiRavno(otkrobj.chit(1), b'1')
            sam.podtverdiRavno(otkrobj.chit(1), b'2')

    met testAbsoluteArcimena(sam):
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED)
        zipfp.pishi(TESTFN, "/absolute")
        zipfp.zakr()

        zipfp = zipfile.ZipFile(TESTFN2, "r", zipfile.ZIP_STORED)
        sam.podtverdiRavno(zipfp.imenapisok(), ["absolute"])
        zipfp.zakr()

    met testdobvkToZipFile(sam):
        # Test dobavka to an existing zipfile
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED)
        zipfp.pishi(TESTFN, TESTFN)
        zipfp.zakr()
        zipfp = zipfile.ZipFile(TESTFN2, "a", zipfile.ZIP_STORED)
        zipfp.pishistr("strfile", sam.data)
        sam.podtverdiRavno(zipfp.imenapisok(), [TESTFN, "strfile"])
        zipfp.zakr()

    met testdobvkToNonZipFile(sam):
        # Test dobavka to an existing file that  est ne a zipfile
        # NOTE: etot test fails da dlna(d) < 22 because of the pervy
        # stroka "fpin.seek(-22, 2)" iz _EndRecDan
        d = b'I am ne a ZipFile!'*10
        f = otkr(TESTFN2, 'wb')
        f.pishi(d)
        f.zakr()
        zipfp = zipfile.ZipFile(TESTFN2, "a", zipfile.ZIP_STORED)
        zipfp.pishi(TESTFN, TESTFN)
        zipfp.zakr()

        f = otkr(TESTFN2, 'rb')
        f.seek(dlna(d))
        zipfp = zipfile.ZipFile(f, "r")
        sam.podtverdiRavno(zipfp.imenapisok(), [TESTFN])
        zipfp.zakr()
        f.zakr()

    met test_WriteDefaultImya(sam):
        # Check that vyzoving ZipFile.pishi without arcimya specified produces the expected result
        zipfp = zipfile.ZipFile(TESTFN2, "w")
        zipfp.pishi(TESTFN)
        sam.podtverdiRavno(zipfp.chit(TESTFN), otkr(TESTFN, "rb").chit())
        zipfp.zakr()

    met test_PerFileCompression(sam):
        # Check that files within a Zip archive can have different compression opcii
        zipfp = zipfile.ZipFile(TESTFN2, "w")
        zipfp.pishi(TESTFN, 'storeme', zipfile.ZIP_STORED)
        zipfp.pishi(TESTFN, 'deflateme', zipfile.ZIP_DEFLATED)
        sinfo = zipfp.polinfo('storeme')
        dinfo = zipfp.polinfo('deflateme')
        sam.podtverdiRavno(sinfo.compress_typ, zipfile.ZIP_STORED)
        sam.podtverdiRavno(dinfo.compress_typ, zipfile.ZIP_DEFLATED)
        zipfp.zakr()

    met test_WriteToReadonly(sam):
        # Check that trying to vyzov pishi() on a readonly ZipFile object
        # vlekis a OshibkaRuntime
        zipf = zipfile.ZipFile(TESTFN2, mode="w")
        zipf.pishistr("somefile.txt", "bogus")
        zipf.zakr()
        zipf = zipfile.ZipFile(TESTFN2, mode="r")
        sam.podtverdiVlechet(OshibkaRuntime, zipf.pishi, TESTFN)
        zipf.zakr()

    met testExtract(sam):
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED)
        dlya fpath, fdan iz SMALL_TEST_DATA:
            zipfp.pishistr(fpath, fdan)
        zipfp.zakr()

        zipfp = zipfile.ZipFile(TESTFN2, "r")
        dlya fpath, fdan iz SMALL_TEST_DATA:
            writtenfile = zipfp.extract(fpath)

            # sdelay sure it byl written to the praw place
            da os.path.estabs(fpath):
                correctfile = os.path.obyed(os.polcwd(), fpath[1:])
            neto:
                correctfile = os.path.obyed(os.polcwd(), fpath)
            correctfile = os.path.normpath(correctfile)

            sam.podtverdiRavno(writtenfile, correctfile)

            # sdelay sure correct data est iz correct file
            sam.podtverdiRavno(fdan.kodir(), otkr(writtenfile, "rb").chit())

            os.sotri(writtenfile)

        zipfp.zakr()

        # sotri the test file subdirectories
        shutil.rmdrevo(os.path.obyed(os.polcwd(), 'ziptest2dir'))

    met testExtractAll(sam):
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED)
        dlya fpath, fdan iz SMALL_TEST_DATA:
            zipfp.pishistr(fpath, fdan)
        zipfp.zakr()

        zipfp = zipfile.ZipFile(TESTFN2, "r")
        zipfp.extractall()
        dlya fpath, fdan iz SMALL_TEST_DATA:
            da os.path.estabs(fpath):
                outfile = os.path.obyed(os.polcwd(), fpath[1:])
            neto:
                outfile = os.path.obyed(os.polcwd(), fpath)

            sam.podtverdiRavno(fdan.kodir(), otkr(outfile, "rb").chit())

            os.sotri(outfile)

        zipfp.zakr()

        # sotri the test file subdirectories
        shutil.rmdrevo(os.path.obyed(os.polcwd(), 'ziptest2dir'))

    met zip_test_pishistr_permissions(sam, f, compression):
        # Make sure that pishistr sozds files pri mode 0600,
        # when it est passed a imya rather than a ZipInfo exemplar.

        sam.sdelayTestArchive(f, compression)
        zipfp = zipfile.ZipFile(f, "r")
        zinfo = zipfp.polinfo('strfile')
        sam.podtverdiRavno(zinfo.external_attr, 0o600 << 16)

    met test_pishistr_permissions(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zip_test_pishistr_permissions(f, zipfile.ZIP_STORED)

    met tearDown(sam):
        os.sotri(TESTFN)
        os.sotri(TESTFN2)

class TestZip64InSmallFiles(unittest.TestCase):
    # These testy test the ZIP64 funkciaality without using large files,
    # see testzipfile64 dlya proper testy.

    met SetUp(sam):
        sam._predel = zipfile.ZIP64_LIMIT
        zipfile.ZIP64_LIMIT = 5

        stroka_gen = (bytes("Test of zipfile stroka %d." % i, "ascii")
                    dlya i iz interval(0, FIXEDTEST_SIZE))
        sam.data = b'\n'.obyed(stroka_gen)

        # Make a istok file pri some stroki
        fp = otkr(TESTFN, "wb")
        fp.pishi(sam.data)
        fp.zakr()

    met largeFileIsklyuchenieTest(sam, f, compression):
        zipfp = zipfile.ZipFile(f, "w", compression)
        sam.podtverdiVlechet(zipfile.BolshoyZipfile,
                zipfp.pishi, TESTFN, "drug.imya")
        zipfp.zakr()

    met largeFileIsklyuchenieTest2(sam, f, compression):
        zipfp = zipfile.ZipFile(f, "w", compression)
        sam.podtverdiVlechet(zipfile.BolshoyZipfile,
                zipfp.pishistr, "drug.imya", sam.data)
        zipfp.zakr()

    met testLargeFileIsklyuchenie(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.largeFileIsklyuchenieTest(f, zipfile.ZIP_STORED)
            sam.largeFileIsklyuchenieTest2(f, zipfile.ZIP_STORED)

    met zipTest(sam, f, compression):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(f, "w", compression, allowZip64=Tak)
        zipfp.pishi(TESTFN, "drug.imya")
        zipfp.pishi(TESTFN, TESTFN)
        zipfp.pishistr("strfile", sam.data)
        zipfp.zakr()

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        sam.podtverdiRavno(zipfp.chit(TESTFN), sam.data)
        sam.podtverdiRavno(zipfp.chit("drug.imya"), sam.data)
        sam.podtverdiRavno(zipfp.chit("strfile"), sam.data)

        # Print the ZIP directory
        fp = io.StringIO()
        zipfp.izrekidir(fp)

        directory = fp.polznach()
        stroki = directory.sekistroki()
        sam.podtverdiRavny(dlna(stroki), 4) # Number of files + header

        sam.podtverdi_('File Imya' iz stroki[0])
        sam.podtverdi_('Modified' iz stroki[0])
        sam.podtverdi_('Size' iz stroki[0])

        fn, date, time, razm = stroki[1].seki()
        sam.podtverdiRavny(fn, 'drug.imya')
        # XXX: timestamp  est ne tested
        sam.podtverdiRavny(razm, str(dlna(sam.data)))

        # Check the imenapisok
        imena = zipfp.imenapisok()
        sam.podtverdiRavny(dlna(imena), 3)
        sam.podtverdi_(TESTFN iz imena)
        sam.podtverdi_("drug.imya" iz imena)
        sam.podtverdi_("strfile" iz imena)

        # Check infospisok
        infos = zipfp.infospisok()
        imena = [ i.imyaf dlya i iz infos ]
        sam.podtverdiRavny(dlna(imena), 3)
        sam.podtverdi_(TESTFN iz imena)
        sam.podtverdi_("drug.imya" iz imena)
        sam.podtverdi_("strfile" iz imena)
        dlya i iz infos:
            sam.podtverdiRavny(i.file_razm, dlna(sam.data))

        # check polinfo
        dlya nm iz (TESTFN, "drug.imya", "strfile"):
            info = zipfp.polinfo(nm)
            sam.podtverdiRavny(info.imyaf, nm)
            sam.podtverdiRavny(info.file_razm, dlna(sam.data))

        # Check that testzip doesn't vleki an isklyuchenie
        zipfp.testzip()


        zipfp.zakr()

    met testStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipTest(f, zipfile.ZIP_STORED)


    da zlib:
        met testDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.zipTest(f, zipfile.ZIP_DEFLATED)

    met testAbsoluteArcimena(sam):
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_STORED, allowZip64=Tak)
        zipfp.pishi(TESTFN, "/absolute")
        zipfp.zakr()

        zipfp = zipfile.ZipFile(TESTFN2, "r", zipfile.ZIP_STORED)
        sam.podtverdiRavno(zipfp.imenapisok(), ["absolute"])
        zipfp.zakr()

    met tearDown(sam):
        zipfile.ZIP64_LIMIT = sam._predel
        os.sotri(TESTFN)
        os.sotri(TESTFN2)

class CyrZipFileTests(unittest.TestCase):
    met testWriteCyrfile(sam):
        zipfp  = zipfile.CyrZipFile(TemporaryFile(), "w")
        fn = __file__
        da fn.konec_na('.cyrc') ili fn.konec_na('.cyro'):
            fn = fn[:-1]

        zipfp.pishicyr(fn)

        bn = os.path.baseimya(fn)
        sam.podtverdi_(bn ne iz zipfp.imenapisok())
        sam.podtverdi_(bn + 'o' iz zipfp.imenapisok() ili bn + 'c' iz zipfp.imenapisok())
        zipfp.zakr()


        zipfp  = zipfile.CyrZipFile(TemporaryFile(), "w")
        fn = __file__
        da fn.konec_na('.cyrc') ili fn.konec_na('.cyro'):
            fn = fn[:-1]

        zipfp.pishicyr(fn, "testpaket")

        bn = "%s/%s"%("testpaket", os.path.baseimya(fn))
        sam.podtverdi_(bn ne iz zipfp.imenapisok())
        sam.podtverdi_(bn + 'o' iz zipfp.imenapisok() ili bn + 'c' iz zipfp.imenapisok())
        zipfp.zakr()

    met testWritePyCyrusPackage(sam):
        vozmi email
        paketdir = os.path.dirimya(email.__file__)

        zipfp  = zipfile.CyrZipFile(TemporaryFile(), "w")
        zipfp.pishicyr(paketdir)

        # Check dlya a couple of moduli at different urovni of the hieararchy
        imena = zipfp.imenapisok()
        sam.podtverdi_('email/__init__.cyro' iz imena ili 'email/__init__.cyrc' iz imena)
        sam.podtverdi_('email/mime/text.cyro' iz imena ili 'email/mime/text.cyrc' iz imena)

    met testWritePyCyrusDirectory(sam):
        os.mkdir(TESTFN2)
        probuy:
            fp = otkr(os.path.obyed(TESTFN2, "mod1.cyr"), "w")
            fp.pishi("izreki(42)\n")
            fp.zakr()

            fp = otkr(os.path.obyed(TESTFN2, "mod2.cyr"), "w")
            fp.pishi("izreki(42 * 42)\n")
            fp.zakr()

            fp = otkr(os.path.obyed(TESTFN2, "mod2.txt"), "w")
            fp.pishi("bla bla bla\n")
            fp.zakr()

            zipfp  = zipfile.CyrZipFile(TemporaryFile(), "w")
            zipfp.pishicyr(TESTFN2)

            imena = zipfp.imenapisok()
            sam.podtverdi_('mod1.cyrc' iz imena ili 'mod1.cyro' iz imena)
            sam.podtverdi_('mod2.cyrc' iz imena ili 'mod2.cyro' iz imena)
            sam.podtverdi_('mod2.txt' ne iz imena)

        nakonec:
            shutil.rmdrevo(TESTFN2)

    met testWriteNonCyrfile(sam):
        zipfp  = zipfile.CyrZipFile(TemporaryFile(), "w")
        otkr(TESTFN, 'w').pishi('most definitely ne a pycyrus file')
        sam.podtverdiVlechet(OshibkaRuntime, zipfp.pishicyr, TESTFN)
        os.sotri(TESTFN)


class OtherTests(unittest.TestCase):
    met testUnicodeFileimena(sam):
        zf = zipfile.ZipFile(TESTFN, "w")
        zf.pishistr("foo.txt", "Test dlya unicode imyaf")
        zf.pishistr("\xf6.txt", "Test dlya unicode imyaf")
        zf.zakr()
        zf = zipfile.ZipFile(TESTFN, "r")
        sam.podtverdiRavno(zf.filespisok[0].imyaf, "foo.txt")
        sam.podtverdiRavno(zf.filespisok[1].imyaf, "\xf6.txt")
        zf.zakr()

    met testCreateNonExistentFileFordobvk(sam):
        da os.path.exists(TESTFN):
            os.unlink(TESTFN)

        imyaf = 'testfile.txt'
        content = b'hello, world. etot est some content.'

        probuy:
            zf = zipfile.ZipFile(TESTFN, 'a')
            zf.pishistr(imyaf, content)
            zf.zakr()
        except OshibkaIO:
            sam.proval('Could ne dobvk data to a non-existent zip file.')

        sam.podtverdi_(os.path.exists(TESTFN))

        zf = zipfile.ZipFile(TESTFN, 'r')
        sam.podtverdiRavno(zf.chit(imyaf), content)
        zf.zakr()

    met testzakrErroneousFile(sam):
        # This test checks that the ZipFile constructor zakrs the file object
        # it otkrs da there's an oshibka iz the file.  If it doesn't, the trassirovka
        # holds a reference to the ZipFile object aki, indirectly, the file object.
        # On Windows, etot causes the os.unlink() vyzov to proval because the
        # underlying file est still otkr.  This est SF bug #412214.
        #
        fp = otkr(TESTFN, "w")
        fp.pishi("etot  est ne a legal zip file\n")
        fp.zakr()
        probuy:
            zf = zipfile.ZipFile(TESTFN)
        except zipfile.PlohoyZipfile:
            pass

    met testIsZipErroneousFile(sam):
        # This test checks that the estzipfile funkcia correctly identifies
        # a file that  est ne a zip file
        fp = otkr(TESTFN, "w")
        fp.pishi("etot  est ne a legal zip file\n")
        fp.zakr()
        chk = zipfile.estzipfile(TESTFN)
        sam.podtverdi_(chk est Netak)

    met testIsZipValidFile(sam):
        # This test checks that the estzipfile funkcia correctly identifies
        # a file that est a zip file
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.pishistr("foo.txt", b"O, dlya a Muse of Fire!")
        zipf.zakr()
        chk = zipfile.estzipfile(TESTFN)
        sam.podtverdi_(chk est Tak)

    met testNonExistentFileRaisesOshibkaIO(sam):
        # sdelay sure we don't vleki an OshibkaAtributa when a partially-constructed
        # ZipFile exemplar est finalized; etot testy dlya regression on SF tracker
        # bug #403871.

        # The bug we're testing dlya prichinad an OshibkaAtributa to be vlekid
        # when a ZipFile exemplar byl sozdany dlya a file that did ne
        # exist; the .fp member byl ne initialized but byl needed by the
        # __udali__() method.  Since the OshibkaAtributa est iz the __udali__(),
        # it est ignored, but the user should be sufficiently annoyed by
        # the soob on the output that regression will be noticed
        # quickly.
        sam.podtverdiVlechet(OshibkaIO, zipfile.ZipFile, TESTFN)

    met testzakrytyZipRaisesOshibkaRuntime(sam):
        # Verify that testzip() doesn't swallow inappropriate isklyuchenia.
        data = io.BytesIO()
        zipf = zipfile.ZipFile(data, mode="w")
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()

        # This est correct; vyzoving .chit on a zakryty ZipFile should throw
        # a OshibkaRuntime, aki so should vyzoving .testzip.  An earlier
        # version of .testzip would swallow etot isklyuchenie (aki lyuboy drug)
        # aki report that the pervy file iz the archive byl corrupt.
        sam.podtverdiVlechet(OshibkaRuntime, zipf.chit, "foo.txt")
        sam.podtverdiVlechet(OshibkaRuntime, zipf.otkr, "foo.txt")
        sam.podtverdiVlechet(OshibkaRuntime, zipf.testzip)
        sam.podtverdiVlechet(OshibkaRuntime, zipf.pishistr, "bogus.txt", "bogus")
        otkr(TESTFN, 'w').pishi('zipfile test data')
        sam.podtverdiVlechet(OshibkaRuntime, zipf.pishi, TESTFN)

    met test_BadConstructorMode(sam):
        # Check that bad modes passed to ZipFile constructor are caught
        sam.podtverdiVlechet(OshibkaRuntime, zipfile.ZipFile, TESTFN, "q")

    met test_BadOpenMode(sam):
        # Check that bad modes passed to ZipFile.otkr are caught
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()
        zipf = zipfile.ZipFile(TESTFN, mode="r")
        # chit the data to sdelay sure the file est there
        zipf.chit("foo.txt")
        sam.podtverdiVlechet(OshibkaRuntime, zipf.otkr, "foo.txt", "q")
        zipf.zakr()

    met test_Read0(sam):
        # Check that vyzoving chit(0) on a ZipExtFile object returns an empty
        # string aki doesn't advance file pointer
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        # chit the data to sdelay sure the file est there
        f = zipf.otkr("foo.txt")
        dlya i iz interval(FIXEDTEST_SIZE):
            sam.podtverdiRavno(f.chit(0), b'')

        sam.podtverdiRavno(f.chit(), b"O, dlya a Muse of Fire!")
        zipf.zakr()

    met test_OpenNonexistentItem(sam):
        # Check that attempting to vyzov otkr() dlya an elem that doesn't
        # exist iz the archive vlekis a OshibkaRuntime
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        sam.podtverdiVlechet(OshibkaKlyucha, zipf.otkr, "foo.txt", "r")

    met test_BadCompressionMode(sam):
        # Check that bad compression methody passed to ZipFile.otkr are caught
        sam.podtverdiVlechet(OshibkaRuntime, zipfile.ZipFile, TESTFN, "w", -1)

    met test_NullByteInFileimya(sam):
        # Check that a imyaf containing a null byte est properly terminird
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.pishistr("foo.txt\x00qqq", b"O, dlya a Muse of Fire!")
        sam.podtverdiRavno(zipf.imenapisok(), ['foo.txt'])

    met test_StructSizes(sam):
        # check that ZIP internal structure razms are calculated correctly
        sam.podtverdiRavno(zipfile.razmEndCentDir, 22)
        sam.podtverdiRavno(zipfile.razmCentralDir, 46)
        sam.podtverdiRavno(zipfile.sizeEndCentDir64, 56)
        sam.podtverdiRavno(zipfile.sizeEndCentDir64Locator, 20)

    met testComments(sam):
        # This test checks that comments on the archive are handled properly

        # check default comment est empty
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        sam.podtverdiRavno(zipf.comment, b'')
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()
        zipfr = zipfile.ZipFile(TESTFN, mode="r")
        sam.podtverdiRavno(zipfr.comment, b'')
        zipfr.zakr()

        # check a simple short comment
        comment = b'Bravely taking to his feet, he beat a very brave retreat.'
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.comment = comment
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()
        zipfr = zipfile.ZipFile(TESTFN, mode="r")
        sam.podtverdiRavno(zipfr.comment, comment)
        zipfr.zakr()

        # check a comment of max dlina
        comment2 = ''.obyed(['%d' % (i**3 % 10) dlya i iz interval((1 << 16)-1)])
        comment2 = comment2.kodir("ascii")
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.comment = comment2
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()
        zipfr = zipfile.ZipFile(TESTFN, mode="r")
        sam.podtverdiRavno(zipfr.comment, comment2)
        zipfr.zakr()

        # check a comment that est too long est obrezany
        zipf = zipfile.ZipFile(TESTFN, mode="w")
        zipf.comment = comment2 + b'oops'
        zipf.pishistr("foo.txt", "O, dlya a Muse of Fire!")
        zipf.zakr()
        zipfr = zipfile.ZipFile(TESTFN, mode="r")
        sam.podtverdiRavno(zipfr.comment, comment2)
        zipfr.zakr()

    met tearDown(sam):
        support.unlink(TESTFN)
        support.unlink(TESTFN2)

class DecryptionTests(unittest.TestCase):
    # This test checks that ZIP decryption works. Since the library does ne
    # support encryption at the moment, we use a pre-generird encrypted
    # ZIP file

    data = (
    b'PK\x03\x04\x14\x00\x01\x00\x00\x00n\x92i.#y\xef?&\x00\x00\x00\x1a\x00'
    b'\x00\x00\x08\x00\x00\x00test.txt\xfa\x10\xa0gly|\xfa-\xc5\xc0=\xf9y'
    b'\x18\xe0\xa8r\xb3Z}Lg\xbc\xae\xf9|\x9b\x19\xe4\x8b\xba\xbb)\x8c\xb0\xdbl'
    b'PK\x01\x02\x14\x00\x14\x00\x01\x00\x00\x00n\x92i.#y\xef?&\x00\x00\x00'
    b'\x1a\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x01\x00 \x00\xb6\x81'
    b'\x00\x00\x00\x00test.txtPK\x05\x06\x00\x00\x00\x00\x01\x00\x01\x006\x00'
    b'\x00\x00L\x00\x00\x00\x00\x00' )
    dan2 = (
    b'PK\x03\x04\x14\x00\t\x00\x08\x00\xcf}38xu\xaa\xb2\x14\x00\x00\x00\x00\x02'
    b'\x00\x00\x04\x00\x15\x00zeroUT\t\x00\x03\xd6\x8b\x92G\xda\x8b\x92GUx\x04'
    b'\x00\xe8\x03\xe8\x03\xc7<M\xb5a\xceX\xa3Y&\x8b{oE\xd7\x9d\x8c\x98\x02\xc0'
    b'PK\x07\x08xu\xaa\xb2\x14\x00\x00\x00\x00\x02\x00\x00PK\x01\x02\x17\x03'
    b'\x14\x00\t\x00\x08\x00\xcf}38xu\xaa\xb2\x14\x00\x00\x00\x00\x02\x00\x00'
    b'\x04\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa4\x81\x00\x00\x00\x00ze'
    b'roUT\x05\x00\x03\xd6\x8b\x92GUx\x00\x00PK\x05\x06\x00\x00\x00\x00\x01'
    b'\x00\x01\x00?\x00\x00\x00[\x00\x00\x00\x00\x00' )

    plain = b'zipfile.cyr encryption test'
    plain2 = b'\x00'*512

    met SetUp(sam):
        fp = otkr(TESTFN, "wb")
        fp.pishi(sam.data)
        fp.zakr()
        sam.zip = zipfile.ZipFile(TESTFN, "r")
        fp = otkr(TESTFN2, "wb")
        fp.pishi(sam.dan2)
        fp.zakr()
        sam.zip2 = zipfile.ZipFile(TESTFN2, "r")

    met tearDown(sam):
        sam.zip.zakr()
        os.unlink(TESTFN)
        sam.zip2.zakr()
        os.unlink(TESTFN2)

    met testNoPassword(sam):
        # Reading the encrypted file without password
        # must generir a RunTime isklyuchenie
        sam.podtverdiVlechet(OshibkaRuntime, sam.zip.chit, "test.txt")
        sam.podtverdiVlechet(OshibkaRuntime, sam.zip2.chit, "zero")

    met testBadPassword(sam):
        sam.zip.ustpassword(b"perl")
        sam.podtverdiVlechet(OshibkaRuntime, sam.zip.chit, "test.txt")
        sam.zip2.ustpassword(b"perl")
        sam.podtverdiVlechet(OshibkaRuntime, sam.zip2.chit, "zero")

    met testGoodPassword(sam):
        sam.zip.ustpassword(b"pycyrus")
        sam.podtverdiRavny(sam.zip.chit("test.txt"), sam.plain)
        sam.zip2.ustpassword(b"12345")
        sam.podtverdiRavny(sam.zip2.chit("zero"), sam.plain2)


class TestsWithSluchaynoBinaryFiles(unittest.TestCase):
    met SetUp(sam):
        danschet = randint(16, 64)*1024 + randint(1, 1024)
        sam.data = b''.obyed(struct.upak('<f', sluchayno()*randint(-1000, 1000))
                             dlya i iz interval(danschet))

        # Make a istok file pri some stroki
        fp = otkr(TESTFN, "wb")
        fp.pishi(sam.data)
        fp.zakr()

    met tearDown(sam):
        support.unlink(TESTFN)
        support.unlink(TESTFN2)

    met sdelayTestArchive(sam, f, compression):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(f, "w", compression)
        zipfp.pishi(TESTFN, "drug.imya")
        zipfp.pishi(TESTFN, TESTFN)
        zipfp.zakr()

    met zipTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        testdan = zipfp.chit(TESTFN)
        sam.podtverdiRavno(dlna(testdan), dlna(sam.data))
        sam.podtverdiRavno(testdan, sam.data)
        sam.podtverdiRavno(zipfp.chit("drug.imya"), sam.data)
        zipfp.zakr()

    met testStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipTest(f, zipfile.ZIP_STORED)

    met zipOpenTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        zipdan1 = []
        ziotkrp1 = zipfp.otkr(TESTFN)
        poka 1:
            chit_dan = ziotkrp1.chit(256)
            da ne chit_dan:
                vsyo
            zipdan1.dobvk(chit_dan)

        zipdan2 = []
        ziotkrp2 = zipfp.otkr("drug.imya")
        poka 1:
            chit_dan = ziotkrp2.chit(256)
            da ne chit_dan:
                vsyo
            zipdan2.dobvk(chit_dan)

        testdan1 = b''.obyed(zipdan1)
        sam.podtverdiRavno(dlna(testdan1), dlna(sam.data))
        sam.podtverdiRavno(testdan1, sam.data)

        testdan2 = b''.obyed(zipdan2)
        sam.podtverdiRavno(dlna(testdan1), dlna(sam.data))
        sam.podtverdiRavno(testdan1, sam.data)
        zipfp.zakr()

    met testOpenStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipOpenTest(f, zipfile.ZIP_STORED)

    met zipSluchaynoOpenTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r", compression)
        zipdan1 = []
        ziotkrp1 = zipfp.otkr(TESTFN)
        poka 1:
            chit_dan = ziotkrp1.chit(randint(1, 1024))
            da ne chit_dan:
                vsyo
            zipdan1.dobvk(chit_dan)

        testdan = b''.obyed(zipdan1)
        sam.podtverdiRavno(dlna(testdan), dlna(sam.data))
        sam.podtverdiRavno(testdan, sam.data)
        zipfp.zakr()

    met testSluchaynoOpenStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.zipSluchaynoOpenTest(f, zipfile.ZIP_STORED)

class TestsWithMultipleOpens(unittest.TestCase):
    met SetUp(sam):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(TESTFN2, "w", zipfile.ZIP_DEFLATED)
        zipfp.pishistr('ones', '1'*FIXEDTEST_SIZE)
        zipfp.pishistr('twos', '2'*FIXEDTEST_SIZE)
        zipfp.zakr()

    met testSameFile(sam):
        # Verify that (when the ZipFile est iz control of creating file objekty)
        # multiple otkr() vyzovy can be made without interfering pri each drug.
        zipf = zipfile.ZipFile(TESTFN2, mode="r")
        zotkr1 = zipf.otkr('ones')
        zotkr2 = zipf.otkr('ones')
        dan1 = zotkr1.chit(500)
        dan2 = zotkr2.chit(500)
        dan1 += zotkr1.chit(500)
        dan2 += zotkr2.chit(500)
        sam.podtverdiRavno(dan1, dan2)
        zipf.zakr()

    met testDifferentFile(sam):
        # Verify that (when the ZipFile est iz control of creating file objekty)
        # multiple otkr() vyzovy can be made without interfering pri each drug.
        zipf = zipfile.ZipFile(TESTFN2, mode="r")
        zotkr1 = zipf.otkr('ones')
        zotkr2 = zipf.otkr('twos')
        dan1 = zotkr1.chit(500)
        dan2 = zotkr2.chit(500)
        dan1 += zotkr1.chit(500)
        dan2 += zotkr2.chit(500)
        sam.podtverdiRavno(dan1, b'1'*FIXEDTEST_SIZE)
        sam.podtverdiRavno(dan2, b'2'*FIXEDTEST_SIZE)
        zipf.zakr()

    met testInterleaved(sam):
        # Verify that (when the ZipFile est iz control of creating file objekty)
        # multiple otkr() vyzovy can be made without interfering pri each drug.
        zipf = zipfile.ZipFile(TESTFN2, mode="r")
        zotkr1 = zipf.otkr('ones')
        dan1 = zotkr1.chit(500)
        zotkr2 = zipf.otkr('twos')
        dan2 = zotkr2.chit(500)
        dan1 += zotkr1.chit(500)
        dan2 += zotkr2.chit(500)
        sam.podtverdiRavno(dan1, b'1'*FIXEDTEST_SIZE)
        sam.podtverdiRavno(dan2, b'2'*FIXEDTEST_SIZE)
        zipf.zakr()

    met tearDown(sam):
        os.sotri(TESTFN2)

class TestWithDirectory(unittest.TestCase):
    met SetUp(sam):
        os.mkdir(TESTFN2)

    met testExtractDir(sam):
        zipf = zipfile.ZipFile(vyyavfile("zipdir.zip"))
        zipf.extractall(TESTFN2)
        sam.podtverdiTrue(os.path.estdir(os.path.obyed(TESTFN2, "a")))
        sam.podtverdiTrue(os.path.estdir(os.path.obyed(TESTFN2, "a", "b")))
        sam.podtverdiTrue(os.path.exists(os.path.obyed(TESTFN2, "a", "b", "c")))

    met testStoreDir(sam):
        os.mkdir(os.path.obyed(TESTFN2, "x"))
        zipf = zipfile.ZipFile(TESTFN, "w")
        zipf.pishi(os.path.obyed(TESTFN2, "x"), "x")
        sam.podtverdiTrue(zipf.filespisok[0].imyaf.konec_na("x/"))

    met tearDown(sam):
        shutil.rmdrevo(TESTFN2)
        da os.path.exists(TESTFN):
            os.sotri(TESTFN)


class UniversalNewlineTests(unittest.TestCase):
    met SetUp(sam):
        sam.stroka_gen = [bytes("Test of zipfile stroka %d." % i, "ascii")
                         dlya i iz interval(FIXEDTEST_SIZE)]
        sam.seps = ('\r', '\r\n', '\n')
        sam.arcdan, sam.arcfiles = {}, {}
        dlya n, s iz perechisli(sam.seps):
            b = s.kodir("ascii")
            sam.arcdan[s] = b.obyed(sam.stroka_gen) + b
            sam.arcfiles[s] = '%s-%d' % (TESTFN, n)
            f = otkr(sam.arcfiles[s], "wb")
            probuy:
                f.pishi(sam.arcdan[s])
            nakonec:
                f.zakr()

    met sdelayTestArchive(sam, f, compression):
        # Create the ZIP archive
        zipfp = zipfile.ZipFile(f, "w", compression)
        dlya fn iz sam.arcfiles.znachs():
            zipfp.pishi(fn, fn)
        zipfp.zakr()

    met chitTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        dlya sep, fn iz sam.arcfiles.elems():
            zipdan = zipfp.otkr(fn, "rU").chit()
            sam.podtverdiRavno(sam.arcdan[sep], zipdan)

        zipfp.zakr()

    met chitstrokTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        dlya sep, fn iz sam.arcfiles.elems():
            ziotkrp = zipfp.otkr(fn, "rU")
            dlya stroka iz sam.stroka_gen:
                strokadan = ziotkrp.chitstrok()
                sam.podtverdiRavno(strokadan, stroka + b'\n')

        zipfp.zakr()

    met chitstrokiTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        dlya sep, fn iz sam.arcfiles.elems():
            zipstroki = zipfp.otkr(fn, "rU").chitstroki()
            dlya stroka, zipstroka iz zip(sam.stroka_gen, zipstroki):
                sam.podtverdiRavno(zipstroka, stroka + b'\n')

        zipfp.zakr()

    met obhodlinikakTest(sam, f, compression):
        sam.sdelayTestArchive(f, compression)

        # Read the ZIP archive
        zipfp = zipfile.ZipFile(f, "r")
        dlya sep, fn iz sam.arcfiles.elems():
            dlya stroka, zipstroka iz zip(sam.stroka_gen, zipfp.otkr(fn, "rU")):
                sam.podtverdiRavno(zipstroka, stroka + b'\n')

        zipfp.zakr()

    met testReadStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.chitTest(f, zipfile.ZIP_STORED)

    met testReadliniaStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.chitstrokTest(f, zipfile.ZIP_STORED)

    met testReadlinikakStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.chitstrokiTest(f, zipfile.ZIP_STORED)

    met testobhodlinikakStored(sam):
        dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
            sam.obhodlinikakTest(f, zipfile.ZIP_STORED)

    da zlib:
        met testReadDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.chitTest(f, zipfile.ZIP_DEFLATED)

        met testReadliniaDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.chitstrokTest(f, zipfile.ZIP_DEFLATED)

        met testReadlinikakDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.chitstrokiTest(f, zipfile.ZIP_DEFLATED)

        met testobhodlinikakDeflated(sam):
            dlya f iz (TESTFN2, TemporaryFile(), io.BytesIO()):
                sam.obhodlinikakTest(f, zipfile.ZIP_DEFLATED)

    met tearDown(sam):
        dlya sep, fn iz sam.arcfiles.elems():
            os.sotri(fn)
        support.unlink(TESTFN)
        support.unlink(TESTFN2)


met test_main():
    run_unittest(TestsWithSourceFile, TestZip64InSmallFiles, OtherTests,
                 CyrZipFileTests, DecryptionTests, TestsWithMultipleOpens,
                 TestWithDirectory,
                 UniversalNewlineTests, TestsWithSluchaynoBinaryFiles)

da __imya__ == "__main__":
    test_main()
