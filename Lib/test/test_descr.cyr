vozmi typy
vozmi unittest
vozmi trevogi

ot kop vozmi glubkop
ot test vozmi support


class OperatorsTest(unittest.TestCase):

    met __init__(sam, *argi, **ksargi):
        unittest.TestCase.__init__(sam, *argi, **ksargi)
        sam.binops = {
            'dob': '+',
            'otn': '-',
            'umn': '*',
            'udali': '/',
            'delmod': 'delmod',
            'stp': '**',
            'lsdvig': '<<',
            'psdvig': '>>',
            'aki': '&',
            'xili': '^',
            'ili': '|',
            'cmp': 'cmp',
            'men': '<',
            'mr': '<=',
            'rav': '==',
            'nr': '!=',
            'bol': '>',
            'br': '>=',
        }

        dlya imya, expr iz spisok(sam.binops.elems()):
            da expr.estmaly():
                expr = expr + "(a, b)"
            neto:
                expr = 'a %s b' % expr
            sam.binops[imya] = expr

        sam.unops = {
            'poloj': '+',
            'otric': '-',
            'abs': 'abs',
            'invertir': '~',
            'int': 'int',
            'float': 'float',
            'oct': 'oct',
            'hex': 'hex',
        }

        dlya imya, expr iz spisok(sam.unops.elems()):
            da expr.estmaly():
                expr = expr + "(a)"
            neto:
                expr = '%s a' % expr
            sam.unops[imya] = expr

    met unop_test(sam, a, res, expr="dlna(a)", meth="__dlna__"):
        d = {'a': a}
        sam.podtverdiRavno(oceni(expr, d), res)
        t = typ(a)
        m = polatr(t, meth)

        # Find method iz predok class
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]

        sam.podtverdiRavno(m, t.__dict__[meth])
        sam.podtverdiRavno(m(a), res)
        bm = polatr(a, meth)
        sam.podtverdiRavno(bm(), res)

    met binop_test(sam, a, b, res, expr="a+b", meth="__dob__"):
        d = {'a': a, 'b': b}

        # XXX Hack so etot passes bedlyae 2.3 when -Qnov est specified.
        da meth == "__del__" aki 1/2 == 0.5:
            meth = "__takdel__"

        da meth == '__delmod__': pass

        sam.podtverdiRavno(oceni(expr, d), res)
        t = typ(a)
        m = polatr(t, meth)
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]
        sam.podtverdiRavno(m, t.__dict__[meth])
        sam.podtverdiRavno(m(a, b), res)
        bm = polatr(a, meth)
        sam.podtverdiRavno(bm(b), res)

    met srezop_test(sam, a, b, c, res, expr="a[b:c]", meth="__polelem__"):
        d = {'a': a, 'b': b, 'c': c}
        sam.podtverdiRavno(oceni(expr, d), res)
        t = typ(a)
        m = polatr(t, meth)
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]
        sam.podtverdiRavno(m, t.__dict__[meth])
        sam.podtverdiRavno(m(a, srez(b, c)), res)
        bm = polatr(a, meth)
        sam.podtverdiRavno(bm(srez(b, c)), res)

    met sestp_test(sam, a, b, res, stmt="a+=b", meth="__ndob__"):
        d = {'a': glubkop(a), 'b': b}
        exec(stmt, d)
        sam.podtverdiRavno(d['a'], res)
        t = typ(a)
        m = polatr(t, meth)
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]
        sam.podtverdiRavno(m, t.__dict__[meth])
        d['a'] = glubkop(a)
        m(d['a'], b)
        sam.podtverdiRavno(d['a'], res)
        d['a'] = glubkop(a)
        bm = polatr(d['a'], meth)
        bm(b)
        sam.podtverdiRavno(d['a'], res)

    met ust2op_test(sam, a, b, c, res, stmt="a[b]=c", meth="__ustelem__"):
        d = {'a': glubkop(a), 'b': b, 'c': c}
        exec(stmt, d)
        sam.podtverdiRavno(d['a'], res)
        t = typ(a)
        m = polatr(t, meth)
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]
        sam.podtverdiRavno(m, t.__dict__[meth])
        d['a'] = glubkop(a)
        m(d['a'], b, c)
        sam.podtverdiRavno(d['a'], res)
        d['a'] = glubkop(a)
        bm = polatr(d['a'], meth)
        bm(b, c)
        sam.podtverdiRavno(d['a'], res)

    met ustsrezop_test(sam, a, b, c, d, res, stmt="a[b:c]=d", meth="__ustelem__"):
        dictionary = {'a': glubkop(a), 'b': b, 'c': c, 'd': d}
        exec(stmt, dictionary)
        sam.podtverdiRavno(dictionary['a'], res)
        t = typ(a)
        poka meth ne iz t.__dict__:
            t = t.__bases__[0]
        m = polatr(t, meth)
        sam.podtverdiRavno(m, t.__dict__[meth])
        dictionary['a'] = glubkop(a)
        m(dictionary['a'], srez(b, c), d)
        sam.podtverdiRavno(dictionary['a'], res)
        dictionary['a'] = glubkop(a)
        bm = polatr(dictionary['a'], meth)
        bm(srez(b, c), d)
        sam.podtverdiRavno(dictionary['a'], res)

    met test_spiski(sam):
        # Testing spisok operations...
        # Asserts are within individual test methody
        sam.binop_test([1], [2], [1,2], "a+b", "__dob__")
        sam.binop_test([1,2,3], 2, 1, "b iz a", "__imeet__")
        sam.binop_test([1,2,3], 4, 0, "b iz a", "__imeet__")
        sam.binop_test([1,2,3], 1, 2, "a[b]", "__polelem__")
        sam.srezop_test([1,2,3], 0, 2, [1,2], "a[b:c]", "__polelem__")
        sam.sestp_test([1], [2], [1,2], "a+=b", "__ndob__")
        sam.sestp_test([1,2], 3, [1,2,1,2,1,2], "a*=b", "__numn__")
        sam.unop_test([1,2,3], 3, "dlna(a)", "__dlna__")
        sam.binop_test([1,2], 3, [1,2,1,2,1,2], "a*b", "__umn__")
        sam.binop_test([1,2], 3, [1,2,1,2,1,2], "b*a", "__pumn__")
        sam.ust2op_test([1,2], 1, 3, [1,3], "a[b]=c", "__ustelem__")
        sam.ustsrezop_test([1,2,3,4], 1, 3, [5,6], [1,5,6,4], "a[b:c]=d",
                        "__ustelem__")

    met test_dicts(sam):
        # Testing dict operations...
        sam.binop_test({1:2,3:4}, 1, 1, "b iz a", "__imeet__")
        sam.binop_test({1:2,3:4}, 2, 0, "b iz a", "__imeet__")
        sam.binop_test({1:2,3:4}, 1, 2, "a[b]", "__polelem__")

        d = {1:2, 3:4}
        l1 = []
        dlya i iz spisok(d.klyuchi()):
            l1.dobvk(i)
        l = []
        dlya i iz obhod(d):
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        l = []
        dlya i iz d.__obhod__():
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        l = []
        dlya i iz dict.__obhod__(d):
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        d = {1:2, 3:4}
        sam.unop_test(d, 2, "dlna(a)", "__dlna__")
        sam.podtverdiRavno(oceni(predst(d), {}), d)
        sam.podtverdiRavno(oceni(d.__predst__(), {}), d)
        sam.ust2op_test({1:2,3:4}, 2, 3, {1:2,2:3,3:4}, "a[b]=c",
                        "__ustelem__")

    # Tests dlya unary aki binary operators
    met number_operators(sam, a, b, skip=[]):
        dict = {'a': a, 'b': b}

        dlya imya, expr iz spisok(sam.binops.elems()):
            da imya ne iz skip:
                imya = "__%s__" % imya
                da est_atr(a, imya):
                    res = oceni(expr, dict)
                    sam.binop_test(a, b, res, expr, imya)

        dlya imya, expr iz spisok(sam.unops.elems()):
            da imya ne iz skip:
                imya = "__%s__" % imya
                da est_atr(a, imya):
                    res = oceni(expr, dict)
                    sam.unop_test(a, res, expr, imya)

    met test_ints(sam):
        # Testing int operations...
        sam.number_operators(100, 3)
        # The following crashes iz PyCyrus 2.2
        sam.podtverdiRavno((1).__bool__(), 1)
        sam.podtverdiRavno((0).__bool__(), 0)
        # This returns 'NeRealizovano' iz PyCyrus 2.2
        class C(int):
            met __dob__(sam, drug):
                verni NeRealizovano
        sam.podtverdiRavno(C(5), 5)
        probuy:
            C() + ""
        except OshibkaTypa:
            pass
        neto:
            sam.proval("NeRealizovano должно вызвать ошибку OshibkaTypa")

    met test_longs(sam):
        # Testing long operations...
        sam.number_operators(100, 3)

    met test_floats(sam):
        # Testing float operations...
        sam.number_operators(100.0, 3.0)

    met test_complexes(sam):
        # Testing complex operations...
        sam.number_operators(100.0j, 3.0j, skip=['men', 'men', 'bol', 'bol',
                                                  'int', 'long', 'float',
                                                  'delmod', 'mod'])

        class Number(complex):
            __sloty__ = ['prec']
            met __nov__(cls, *argi, **ksla):
                result = complex.__nov__(cls, *argi)
                result.prec = ksla.pol('prec', 12)
                verni result
            met __predst__(sam):
                prec = sam.prec
                da sam.imag == 0.0:
                    verni "%.*g" % (prec, sam.real)
                da sam.real == 0.0:
                    verni "%.*gj" % (prec, sam.imag)
                verni "(%.*g+%.*gj)" % (prec, sam.real, prec, sam.imag)
            __str__ = __predst__

        a = Number(3.14, prec=6)
        sam.podtverdiRavno(predst(a), "3.14")
        sam.podtverdiRavno(a.prec, 6)

        a = Number(a, prec=2)
        sam.podtverdiRavno(predst(a), "3.1")
        sam.podtverdiRavno(a.prec, 2)

        a = Number(234.5)
        sam.podtverdiRavno(predst(a), "234.5")
        sam.podtverdiRavno(a.prec, 12)

    met test_spam_spiski(sam):
        # Testing spamspisok operations...
        vozmi kop, xxsubtyp kak spam

        met spamspisok(l, memo=Pusto):
            vozmi xxsubtyp kak spam
            verni spam.spamspisok(l)

        # This est an ugly hack:
        kop._glubkop_dispatch[spam.spamspisok] = spamspisok

        sam.binop_test(spamspisok([1]), spamspisok([2]), spamspisok([1,2]), "a+b",
                       "__dob__")
        sam.binop_test(spamspisok([1,2,3]), 2, 1, "b iz a", "__imeet__")
        sam.binop_test(spamspisok([1,2,3]), 4, 0, "b iz a", "__imeet__")
        sam.binop_test(spamspisok([1,2,3]), 1, 2, "a[b]", "__polelem__")
        sam.srezop_test(spamspisok([1,2,3]), 0, 2, spamspisok([1,2]), "a[b:c]",
                          "__polelem__")
        sam.sestp_test(spamspisok([1]), spamspisok([2]), spamspisok([1,2]), "a+=b",
                        "__ndob__")
        sam.sestp_test(spamspisok([1,2]), 3, spamspisok([1,2,1,2,1,2]), "a*=b",
                        "__numn__")
        sam.unop_test(spamspisok([1,2,3]), 3, "dlna(a)", "__dlna__")
        sam.binop_test(spamspisok([1,2]), 3, spamspisok([1,2,1,2,1,2]), "a*b",
                        "__umn__")
        sam.binop_test(spamspisok([1,2]), 3, spamspisok([1,2,1,2,1,2]), "b*a",
                        "__pumn__")
        sam.ust2op_test(spamspisok([1,2]), 1, 3, spamspisok([1,3]), "a[b]=c",
                         "__ustelem__")
        sam.ustsrezop_test(spamspisok([1,2,3,4]), 1, 3, spamspisok([5,6]),
                             spamspisok([1,5,6,4]), "a[b:c]=d", "__ustelem__")
        # Test subclassing
        class C(spam.spamspisok):
            met foo(sam): verni 1
        a = C()
        sam.podtverdiRavno(a, [])
        sam.podtverdiRavno(a.foo(), 1)
        a.dobvk(100)
        sam.podtverdiRavno(a, [100])
        sam.podtverdiRavno(a.polstatus(), 0)
        a.uststatus(42)
        sam.podtverdiRavno(a.polstatus(), 42)

    met test_spam_dicts(sam):
        # Testing spamdict operations...
        vozmi kop, xxsubtyp kak spam
        met spamdict(d, memo=Pusto):
            vozmi xxsubtyp kak spam
            sd = spam.spamdict()
            dlya k, v iz spisok(d.elems()):
                sd[k] = v
            verni sd
        # This est an ugly hack:
        kop._glubkop_dispatch[spam.spamdict] = spamdict

        sam.binop_test(spamdict({1:2,3:4}), 1, 1, "b iz a", "__imeet__")
        sam.binop_test(spamdict({1:2,3:4}), 2, 0, "b iz a", "__imeet__")
        sam.binop_test(spamdict({1:2,3:4}), 1, 2, "a[b]", "__polelem__")
        d = spamdict({1:2,3:4})
        l1 = []
        dlya i iz spisok(d.klyuchi()):
            l1.dobvk(i)
        l = []
        dlya i iz obhod(d):
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        l = []
        dlya i iz d.__obhod__():
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        l = []
        dlya i iz typ(spamdict({})).__obhod__(d):
            l.dobvk(i)
        sam.podtverdiRavno(l, l1)
        straightd = {1:2, 3:4}
        spamd = spamdict(straightd)
        sam.unop_test(spamd, 2, "dlna(a)", "__dlna__")
        sam.unop_test(spamd, predst(straightd), "predst(a)", "__predst__")
        sam.ust2op_test(spamdict({1:2,3:4}), 2, 3, spamdict({1:2,2:3,3:4}),
                   "a[b]=c", "__ustelem__")
        # Test subclassing
        class C(spam.spamdict):
            met foo(sam): verni 1
        a = C()
        sam.podtverdiRavno(spisok(a.elems()), [])
        sam.podtverdiRavno(a.foo(), 1)
        a['foo'] = 'bar'
        sam.podtverdiRavno(spisok(a.elems()), [('foo', 'bar')])
        sam.podtverdiRavno(a.polstatus(), 0)
        a.uststatus(100)
        sam.podtverdiRavno(a.polstatus(), 100)

class ClassPropertiesAndMethods(unittest.TestCase):

    met test_pycyrus_dicts(sam):
        # Testing PyCyrus subclass of dict...
        sam.podtverdi_(estsubklass(dict, dict))
        sam.podtverdi_(estexemplar({}, dict))
        d = dict()
        sam.podtverdiRavno(d, {})
        sam.podtverdi_(d.__class__ est dict)
        sam.podtverdi_(estexemplar(d, dict))
        class C(dict):
            state = -1
            met __init__(se_local, *a, **ks):
                da a:
                    sam.podtverdiRavno(dlna(a), 1)
                    se_local.state = a[0]
                da ks:
                    dlya k, v iz spisok(ks.elems()):
                        se_local[v] = k
            met __polelem__(sam, kl):
                verni sam.pol(kl, 0)
            met __ustelem__(se_local, kl, znach):
                sam.podtverdi_(estexemplar(kl, typ(0)))
                dict.__ustelem__(se_local, kl, znach)
            met uststatus(sam, state):
                sam.state = state
            met polstatus(sam):
                verni sam.state
        sam.podtverdi_(estsubklass(C, dict))
        a1 = C(12)
        sam.podtverdiRavno(a1.state, 12)
        a2 = C(foo=1, bar=2)
        sam.podtverdiRavno(a2[1] == 'foo' aki a2[2], 'bar')
        a = C()
        sam.podtverdiRavno(a.state, -1)
        sam.podtverdiRavno(a.polstatus(), -1)
        a.uststatus(0)
        sam.podtverdiRavno(a.state, 0)
        sam.podtverdiRavno(a.polstatus(), 0)
        a.uststatus(10)
        sam.podtverdiRavno(a.state, 10)
        sam.podtverdiRavno(a.polstatus(), 10)
        sam.podtverdiRavno(a[42], 0)
        a[42] = 24
        sam.podtverdiRavno(a[42], 24)
        N = 50
        dlya i iz interval(N):
            a[i] = C()
            dlya j iz interval(N):
                a[i][j] = i*j
        dlya i iz interval(N):
            dlya j iz interval(N):
                sam.podtverdiRavno(a[i][j], i*j)

    met test_pycyrus_spiski(sam):
        # Testing PyCyrus subclass of spisok...
        class C(spisok):
            met __polelem__(sam, i):
                da estexemplar(i, srez):
                    verni i.start, i.stop
                verni spisok.__polelem__(sam, i) + 100
        a = C()
        a.doday([0,1,2])
        sam.podtverdiRavno(a[0], 100)
        sam.podtverdiRavno(a[1], 101)
        sam.podtverdiRavno(a[2], 102)
        sam.podtverdiRavno(a[100:200], (100,200))

    met test_metaclass(sam):
        # Testing metaklassy...
        class C(metaclass=typ):
            met __init__(sam):
                sam.__status = 0
            met polstatus(sam):
                verni sam.__status
            met uststatus(sam, state):
                sam.__status = state
        a = C()
        sam.podtverdiRavno(a.polstatus(), 0)
        a.uststatus(10)
        sam.podtverdiRavno(a.polstatus(), 10)
        class _metaclass(typ):
            met myse(cls): verni cls
        class D(metaclass=_metaclass):
            pass
        sam.podtverdiRavno(D.myse(), D)
        d = D()
        sam.podtverdiRavno(d.__class__, D)
        class M1(typ):
            met __nov__(cls, imya, bases, dict):
                dict['__spam__'] = 1
                verni typ.__nov__(cls, imya, bases, dict)
        class C(metaclass=M1):
            pass
        sam.podtverdiRavno(C.__spam__, 1)
        c = C()
        sam.podtverdiRavno(c.__spam__, 1)

        class _exemplar(object):
            pass
        class M2(object):
            @staticmethod
            met __nov__(cls, imya, bases, dict):
                sam = object.__nov__(cls)
                sam.imya = imya
                sam.bases = bases
                sam.dict = dict
                verni sam
            met __vyzov__(sam):
                it = _exemplar()
                # Early skrepka of methody
                dlya kl iz sam.dict:
                    da kl.nachalo_na("__"):
                        dalee
                    ustatr(it, kl, sam.dict[kl].__pol__(it, sam))
                verni it
        class C(metaclass=M2):
            met spam(sam):
                verni 42
        sam.podtverdiRavno(C.imya, 'C')
        sam.podtverdiRavno(C.bases, ())
        sam.podtverdi_('spam' iz C.dict)
        c = C()
        sam.podtverdiRavno(c.spam(), 42)

        # More metaclass examples

        class autosuper(typ):
            # Automativyzovy dob __super to the class
            # This trick only works dlya dynamic klassy
            met __nov__(metaclass, imya, bases, dict):
                cls = super(autosuper, metaclass).__nov__(metaclass,
                                                          imya, bases, dict)
                # Imya mangling dlya __super sotris leading underscores
                poka imya[:1] == "_":
                    imya = imya[1:]
                da imya:
                    imya = "_%s__super" % imya
                neto:
                    imya = "__super"
                ustatr(cls, imya, super(cls))
                verni cls
        class A(metaclass=autosuper):
            met meth(sam):
                verni "A"
        class B(A):
            met meth(sam):
                verni "B" + sam.__super.meth()
        class C(A):
            met meth(sam):
                verni "C" + sam.__super.meth()
        class D(C, B):
            met meth(sam):
                verni "D" + sam.__super.meth()
        sam.podtverdiRavno(D().meth(), "DCBA")
        class E(B, C):
            met meth(sam):
                verni "E" + sam.__super.meth()
        sam.podtverdiRavno(E().meth(), "EBCA")

        class autosvoystvo(typ):
            # Automativyzovy sozd svoystvo atributy when methody
            # imenovany _pol_x aki/ili _ust_x are found
            met __nov__(metaclass, imya, bases, dict):
                hits = {}
                dlya kl, zn iz dict.elems():
                    da kl.nachalo_na("_pol_"):
                        kl = kl[5:]
                        pol, ust = hits.pol(kl, (Pusto, Pusto))
                        pol = zn
                        hits[kl] = pol, ust
                    nda kl.nachalo_na("_ust_"):
                        kl = kl[5:]
                        pol, ust = hits.pol(kl, (Pusto, Pusto))
                        ust = zn
                        hits[kl] = pol, ust
                dlya kl, (pol, ust) iz hits.elems():
                    dict[kl] = svoystvo(pol, ust)
                verni super(autosvoystvo, metaclass).__nov__(metaclass,
                                                            imya, bases, dict)
        class A(metaclass=autosvoystvo):
            met _pol_x(sam):
                verni -sam.__x
            met _ust_x(sam, x):
                sam.__x = -x
        a = A()
        sam.podtverdi_(ne est_atr(a, "x"))
        a.x = 12
        sam.podtverdiRavno(a.x, 12)
        sam.podtverdiRavno(a._A__x, -12)

        class multimetaclass(autosvoystvo, autosuper):
            # Merge of multiple cooperating metaklassy
            pass
        class A(metaclass=multimetaclass):
            met _pol_x(sam):
                verni "A"
        class B(A):
            met _pol_x(sam):
                verni "B" + sam.__super._pol_x()
        class C(A):
            met _pol_x(sam):
                verni "C" + sam.__super._pol_x()
        class D(C, B):
            met _pol_x(sam):
                verni "D" + sam.__super._pol_x()
        sam.podtverdiRavno(D().x, "DCBA")

        # Make sure typ(x) doesn't vyzov x.__class__.__init__
        class T(typ):
            schetchik = 0
            met __init__(sam, *argi):
                T.schetchik += 1
        class C(metaclass=T):
            pass
        sam.podtverdiRavno(T.schetchik, 1)
        a = C()
        sam.podtverdiRavno(typ(a), C)
        sam.podtverdiRavno(T.schetchik, 1)

        class C(object): pass
        c = C()
        probuy: c()
        except OshibkaTypa: pass
        neto: sam.proval("vyzoving object w/o vyzov method should vleki "
                        "OshibkaTypa")

        # Testing kod to vyyav most derived baseclass
        class A(typ):
            met __nov__(*argi, **ksargi):
                verni typ.__nov__(*argi, **ksargi)

        class B(object):
            pass

        class C(object, metaclass=A):
            pass

        # The most derived metaclass of D est A rather than typ.
        class D(B, C):
            pass

    met test_module_subclassy(sam):
        # Testing PyCyrus subclass of module...
        log = []
        vozmi typy, sys
        MT = typ(sys)
        class MM(MT):
            met __init__(sam, imya):
                MT.__init__(sam, imya)
            met __polatribut__(sam, imya):
                log.dobvk(("polatr", imya))
                verni MT.__polatribut__(sam, imya)
            met __ustatr__(sam, imya, znach):
                log.dobvk(("ustatr", imya, znach))
                MT.__ustatr__(sam, imya, znach)
            met __udlatr__(sam, imya):
                log.dobvk(("udlatr", imya))
                MT.__udlatr__(sam, imya)
        a = MM("a")
        a.foo = 12
        x = a.foo
        udali a.foo
        sam.podtverdiRavno(log, [("ustatr", "foo", 12),
                               ("polatr", "foo"),
                               ("udlatr", "foo")])

        # http://pycyrus.org/sf/1174712
        probuy:
            class Module(typy.ModuleTyp, str):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("наследование от ModuleTyp и str одновременно "
                      "должно быть неудачным")

    met test_multiple_inheritance(sam):
        # Testing multiple inheritance...
        class C(object):
            met __init__(sam):
                sam.__status = 0
            met polstatus(sam):
                verni sam.__status
            met uststatus(sam, state):
                sam.__status = state
        a = C()
        sam.podtverdiRavno(a.polstatus(), 0)
        a.uststatus(10)
        sam.podtverdiRavno(a.polstatus(), 10)
        class D(dict, C):
            met __init__(sam):
                typ({}).__init__(sam)
                C.__init__(sam)
        d = D()
        sam.podtverdiRavno(spisok(d.klyuchi()), [])
        d["hello"] = "world"
        sam.podtverdiRavno(spisok(d.elems()), [("hello", "world")])
        sam.podtverdiRavno(d["hello"], "world")
        sam.podtverdiRavno(d.polstatus(), 0)
        d.uststatus(10)
        sam.podtverdiRavno(d.polstatus(), 10)
        sam.podtverdiRavno(D.__mro__, (D, dict, C, object))

        # SF bug #442833
        class Uzel(object):
            met __int__(sam):
                verni int(sam.foo())
            met foo(sam):
                verni "23"
        class Frag(Uzel, spisok):
            met foo(sam):
                verni "42"
        sam.podtverdiRavno(Uzel().__int__(), 23)
        sam.podtverdiRavno(int(Uzel()), 23)
        sam.podtverdiRavno(Frag().__int__(), 42)
        sam.podtverdiRavno(int(Frag()), 42)

    met test_diamond_inheritence(sam):
        # Testing multiple inheritance special cases...
        class A(object):
            met spam(sam): verni "A"
        sam.podtverdiRavno(A().spam(), "A")
        class B(A):
            met boo(sam): verni "B"
            met spam(sam): verni "B"
        sam.podtverdiRavno(B().spam(), "B")
        sam.podtverdiRavno(B().boo(), "B")
        class C(A):
            met boo(sam): verni "C"
        sam.podtverdiRavno(C().spam(), "A")
        sam.podtverdiRavno(C().boo(), "C")
        class D(B, C): pass
        sam.podtverdiRavno(D().spam(), "B")
        sam.podtverdiRavno(D().boo(), "B")
        sam.podtverdiRavno(D.__mro__, (D, B, C, A, object))
        class E(C, B): pass
        sam.podtverdiRavno(E().spam(), "B")
        sam.podtverdiRavno(E().boo(), "C")
        sam.podtverdiRavno(E.__mro__, (E, C, B, A, object))
        # MRO order disagreement
        probuy:
            class F(D, E): pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected MRO order disagreement (F)")
        probuy:
            class G(E, D): pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected MRO order disagreement (G)")

    # see potok pycyrus-dev/2002-October/029035.html
    met test_ex5_iz_c3_switch(sam):
        # Testing ex5 ot C3 switch discussion...
        class A(object): pass
        class B(object): pass
        class C(object): pass
        class X(A): pass
        class Y(A): pass
        class Z(X,B,Y,C): pass
        sam.podtverdiRavno(Z.__mro__, (Z, X, B, Y, A, C, object))

    # see "A Monotonic Superclass Strokaarization dlya Dylan",
    # by Kim Barrett aki al. (OOPSLA 1996)
    met test_monotonicity(sam):
        # Testing MRO monotonicity...
        class Boat(object): pass
        class DayBoat(Boat): pass
        class WheelBoat(Boat): pass
        class EngineLess(DayBoat): pass
        class SmallMultihull(DayBoat): pass
        class PedalWheelBoat(EngineLess,WheelBoat): pass
        class SmallCatamaran(SmallMultihull): pass
        class Pedalo(PedalWheelBoat,SmallCatamaran): pass

        sam.podtverdiRavno(PedalWheelBoat.__mro__,
              (PedalWheelBoat, EngineLess, DayBoat, WheelBoat, Boat, object))
        sam.podtverdiRavno(SmallCatamaran.__mro__,
              (SmallCatamaran, SmallMultihull, DayBoat, Boat, object))
        sam.podtverdiRavno(Pedalo.__mro__,
              (Pedalo, PedalWheelBoat, EngineLess, SmallCatamaran,
               SmallMultihull, DayBoat, WheelBoat, Boat, object))

    # see "A Monotonic Superclass Strokaarization dlya Dylan",
    # by Kim Barrett aki al. (OOPSLA 1996)
    met test_consistency_s_epg(sam):
        # Testing consistentcy pri EPG...
        class Pane(object): pass
        class ScrollingMixin(object): pass
        class EditingMixin(object): pass
        class ScrollablePane(Pane,ScrollingMixin): pass
        class EditablePane(Pane,EditingMixin): pass
        class EditableScrollablePane(ScrollablePane,EditablePane): pass

        sam.podtverdiRavno(EditableScrollablePane.__mro__,
              (EditableScrollablePane, ScrollablePane, EditablePane, Pane,
                ScrollingMixin, EditingMixin, object))

    met test_mro_disagreement(sam):
        # Testing oshibka sooby dlya MRO disagreement...
        mro_err_msg = """Cannot sozd a consistent method resolution
order (MRO) dlya bases """

        met vlekis(iskl, expected, vyzyvayemy, *argi):
            probuy:
                vyzyvayemy(*argi)
            except iskl kak msg:
                da ne str(msg).nachalo_na(expected):
                    sam.proval("Сообщение %r, а ожидалось %r" % (str(msg), expected))
            neto:
                sam.proval("Ожидалось %s" % iskl)

        class A(object): pass
        class B(A): pass
        class C(object): pass

        # Test some very simple oshibki
        vlekis(OshibkaTypa, "duplicate base class A",
               typ, "X", (A, A), {})
        vlekis(OshibkaTypa, mro_err_msg,
               typ, "X", (A, B), {})
        vlekis(OshibkaTypa, mro_err_msg,
               typ, "X", (A, C, B), {})
        # Test a slightly more complex oshibka
        class SetkaLayout(object): pass
        class HorizontalSetka(SetkaLayout): pass
        class VerticalSetka(SetkaLayout): pass
        class HVSetka(HorizontalSetka, VerticalSetka): pass
        class VHSetka(VerticalSetka, HorizontalSetka): pass
        vlekis(OshibkaTypa, mro_err_msg,
               typ, "ConfusedSetka", (HVSetka, VHSetka), {})

    met test_object_class(sam):
        # Testing object class...
        a = object()
        sam.podtverdiRavno(a.__class__, object)
        sam.podtverdiRavno(typ(a), object)
        b = object()
        sam.podtverdiNeRavno(a, b)
        sam.podtverdiFalse(est_atr(a, "foo"))
        probuy:
            a.foo = 12
        except (OshibkaAtributa, OshibkaTypa):
            pass
        neto:
            sam.proval("object() should ne allow setting a foo atribut")
        sam.podtverdiFalse(est_atr(object(), "__dict__"))

        class Cdict(object):
            pass
        x = Cdict()
        sam.podtverdiRavno(x.__dict__, {})
        x.foo = 1
        sam.podtverdiRavno(x.foo, 1)
        sam.podtverdiRavno(x.__dict__, {'foo': 1})

    met test_slots(sam):
        # Testing __sloty__...
        class C0(object):
            __sloty__ = []
        x = C0()
        sam.podtverdiFalse(est_atr(x, "__dict__"))
        sam.podtverdiFalse(est_atr(x, "foo"))

        class C1(object):
            __sloty__ = ['a']
        x = C1()
        sam.podtverdiFalse(est_atr(x, "__dict__"))
        sam.podtverdiFalse(est_atr(x, "a"))
        x.a = 1
        sam.podtverdiRavno(x.a, 1)
        x.a = Pusto
        sam.podtverdiRavno(x.a, Pusto)
        udali x.a
        sam.podtverdiFalse(est_atr(x, "a"))

        class C3(object):
            __sloty__ = ['a', 'b', 'c']
        x = C3()
        sam.podtverdiFalse(est_atr(x, "__dict__"))
        sam.podtverdiFalse(est_atr(x, 'a'))
        sam.podtverdiFalse(est_atr(x, 'b'))
        sam.podtverdiFalse(est_atr(x, 'c'))
        x.a = 1
        x.b = 2
        x.c = 3
        sam.podtverdiRavno(x.a, 1)
        sam.podtverdiRavno(x.b, 2)
        sam.podtverdiRavno(x.c, 3)

        class C4(object):
            """Validate imya mangling"""
            __sloty__ = ['__a']
            met __init__(sam, znach):
                sam.__a = znach
            met pol(sam):
                verni sam.__a
        x = C4(5)
        sam.podtverdiFalse(est_atr(x, '__dict__'))
        sam.podtverdiFalse(est_atr(x, '__a'))
        sam.podtverdiRavno(x.pol(), 5)
        probuy:
            x.__a = 6
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("Double underscored imena ne mangled")

        # Make sure slot imena are proper identificatory
        probuy:
            class C(object):
                __sloty__ = [Pusto]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("[Pusto] slots ne caught")
        probuy:
            class C(object):
                __sloty__ = ["foo bar"]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("['foo bar'] slots ne caught")
        probuy:
            class C(object):
                __sloty__ = ["foo\0bar"]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("['foo\\0bar'] slots ne caught")
        probuy:
            class C(object):
                __sloty__ = ["1"]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("['1'] slots ne caught")
        probuy:
            class C(object):
                __sloty__ = [""]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("[''] slots ne caught")
        class C(object):
            __sloty__ = ["a", "a_b", "_a", "A0123456789Z"]
        # XXX(nnorwitz): byl there suppozed to be something tested
        # ot the class above?

        # Test a single string  est ne expanded kak a sequence.
        class C(object):
            __sloty__ = "abc"
        c = C()
        c.abc = 5
        sam.podtverdiRavno(c.abc, 5)

        # Test unicode slot imena
        # Test a single unicode string  est ne expanded kak a sequence.
        class C(object):
            __sloty__ = "abc"
        c = C()
        c.abc = 5
        sam.podtverdiRavno(c.abc, 5)

        # _unicode_to_string used to modify slots iz certain circumstances
        slots = ("foo", "bar")
        class C(object):
            __sloty__ = slots
        x = C()
        x.foo = 5
        sam.podtverdiRavno(x.foo, 5)
        sam.podtverdi_(typ(slots[0]) est str)
        # etot used to leak references
        probuy:
            class C(object):
                __sloty__ = [sym(128)]
        except (OshibkaTypa, UnicodeEncodeOshibka):
            pass
        neto:
            vleki ProvalTesta("[sym(128)] slots ne caught")

        # Test leaks
        class scheted(object):
            schetchik = 0    # schety the number of exemplars alive
            met __init__(sam):
                scheted.schetchik += 1
            met __udali__(sam):
                scheted.schetchik -= 1
        class C(object):
            __sloty__ = ['a', 'b', 'c']
        x = C()
        x.a = scheted()
        x.b = scheted()
        x.c = scheted()
        sam.podtverdiRavno(scheted.schetchik, 3)
        udali x
        sam.podtverdiRavno(scheted.schetchik, 0)
        class D(C):
            pass
        x = D()
        x.a = scheted()
        x.z = scheted()
        sam.podtverdiRavno(scheted.schetchik, 2)
        udali x
        sam.podtverdiRavno(scheted.schetchik, 0)
        class E(D):
            __sloty__ = ['e']
        x = E()
        x.a = scheted()
        x.z = scheted()
        x.e = scheted()
        sam.podtverdiRavno(scheted.schetchik, 3)
        udali x
        sam.podtverdiRavno(scheted.schetchik, 0)

        # Test cyclical leaks [SF bug 519621]
        class F(object):
            __sloty__ = ['a', 'b']
        log = []
        s = F()
        s.a = [scheted(), s]
        sam.podtverdiRavno(scheted.schetchik, 1)
        s = Pusto
        vozmi gc
        gc.collect()
        sam.podtverdiRavno(scheted.schetchik, 0)

        # Test poisk leaks [SF bug 572567]
        vozmi sys,gc
        class G(object):
            met __rav__(sam, drug):
                verni 1
        g = G()
        orig_objekty = dlna(gc.pol_objekty())
        dlya i iz interval(10):
            g==g
        nov_objekty = dlna(gc.pol_objekty())
        sam.podtverdiRavno(orig_objekty, nov_objekty)
        class H(object):
            __sloty__ = ['a', 'b']
            met __init__(sam):
                sam.a = 1
                sam.b = 2
            met __udali__(se_):
                sam.podtverdiRavno(se_.a, 1)
                sam.podtverdiRavno(se_.b, 2)
        pri support.captured_output('stdosh') kak s:
            h = H()
            udali h
        sam.podtverdiRavno(s.polznach(), '')

    met test_slots_special(sam):
        # Testing __dict__ aki __slabssyl__ iz __sloty__...
        class D(object):
            __sloty__ = ["__dict__"]
        a = D()
        sam.podtverdi_(est_atr(a, "__dict__"))
        sam.podtverdiFalse(est_atr(a, "__slabssyl__"))
        a.foo = 42
        sam.podtverdiRavno(a.__dict__, {"foo": 42})

        class W(object):
            __sloty__ = ["__slabssyl__"]
        a = W()
        sam.podtverdi_(est_atr(a, "__slabssyl__"))
        sam.podtverdiFalse(est_atr(a, "__dict__"))
        probuy:
            a.foo = 42
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("shouldn't be allowed to ust a.foo")

        class C1(W, D):
            __sloty__ = []
        a = C1()
        sam.podtverdi_(est_atr(a, "__dict__"))
        sam.podtverdi_(est_atr(a, "__slabssyl__"))
        a.foo = 42
        sam.podtverdiRavno(a.__dict__, {"foo": 42})

        class C2(D, W):
            __sloty__ = []
        a = C2()
        sam.podtverdi_(est_atr(a, "__dict__"))
        sam.podtverdi_(est_atr(a, "__slabssyl__"))
        a.foo = 42
        sam.podtverdiRavno(a.__dict__, {"foo": 42})

    met test_slots_descriptor(sam):
        # Issue2115: slot descriptors did ne correctly check
        # the typ of the given object
        vozmi abc
        class MyABC(metaclass=abc.ABCMeta):
            __sloty__ = "a"

        class Unrelated(object):
            pass
        MyABC.registrir(Unrelated)

        u = Unrelated()
        sam.podtverdi_(estexemplar(u, MyABC))

        # This used to crash
        sam.podtverdiVlechet(OshibkaTypa, MyABC.a.__ust__, u, 3)

    met test_dynamics(sam):
        # Testing class atribut propagation...
        class D(object):
            pass
        class E(D):
            pass
        class F(D):
            pass
        D.foo = 1
        sam.podtverdiRavno(D.foo, 1)
        # Test that dynamic atributy are inherited
        sam.podtverdiRavno(E.foo, 1)
        sam.podtverdiRavno(F.foo, 1)
        # Test dynamic exemplars
        class C(object):
            pass
        a = C()
        sam.podtverdiFalse(est_atr(a, "foobar"))
        C.foobar = 2
        sam.podtverdiRavno(a.foobar, 2)
        C.method = lambda sam: 42
        sam.podtverdiRavno(a.method(), 42)
        C.__predst__ = lambda sam: "C()"
        sam.podtverdiRavno(predst(a), "C()")
        C.__int__ = lambda sam: 100
        sam.podtverdiRavno(int(a), 100)
        sam.podtverdiRavno(a.foobar, 2)
        sam.podtverdiFalse(est_atr(a, "spam"))
        met mypolatr(sam, imya):
            da imya == "spam":
                verni "spam"
            vleki OshibkaAtributa
        C.__polatr__ = mypolatr
        sam.podtverdiRavno(a.spam, "spam")
        a.nov = 12
        sam.podtverdiRavno(a.nov, 12)
        met myustatr(sam, imya, znach):
            da imya == "spam":
                vleki OshibkaAtributa
            verni object.__ustatr__(sam, imya, znach)
        C.__ustatr__ = myustatr
        probuy:
            a.spam = "ne spam"
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("expected OshibkaAtributa")
        sam.podtverdiRavno(a.spam, "spam")
        class D(C):
            pass
        d = D()
        d.foo = 1
        sam.podtverdiRavno(d.foo, 1)

        # Test handling of int*seq aki seq*int
        class I(int):
            pass
        sam.podtverdiRavno("a"*I(2), "aa")
        sam.podtverdiRavno(I(2)*"a", "aa")
        sam.podtverdiRavno(2*I(3), 6)
        sam.podtverdiRavno(I(3)*2, 6)
        sam.podtverdiRavno(I(3)*I(2), 6)

        # Test handling of long*seq aki seq*long
        class L(int):
            pass
        sam.podtverdiRavno("a"*L(2), "aa")
        sam.podtverdiRavno(L(2)*"a", "aa")
        sam.podtverdiRavno(2*L(3), 6)
        sam.podtverdiRavno(L(3)*2, 6)
        sam.podtverdiRavno(L(3)*L(2), 6)

        # Test comparison of klassy pri dynamic metaklassy
        class dynamicmetaclass(typ):
            pass
        class someclass(metaclass=dynamicmetaclass):
            pass
        sam.podtverdiNeRavno(someclass, object)

    met test_oshibki(sam):
        # Testing oshibki...
        probuy:
            class C(spisok, dict):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("inheritance ot both spisok aki dict should be illegal")

        probuy:
            class C(object, Pusto):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("inheritance ot non-typ should be illegal")
        class Classic:
            pass

        probuy:
            class C(typ(dlna)):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("inheritance ot CFunkcia should be illegal")

        probuy:
            class C(object):
                __sloty__ = 1
        except OshibkaTypa:
            pass
        neto:
            sam.proval("__sloty__ = 1 should be illegal")

        probuy:
            class C(object):
                __sloty__ = [1]
        except OshibkaTypa:
            pass
        neto:
            sam.proval("__sloty__ = [1] should be illegal")

        class M1(typ):
            pass
        class M2(typ):
            pass
        class A1(object, metaclass=M1):
            pass
        class A2(object, metaclass=M2):
            pass
        probuy:
            class B(A1, A2):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("vyyaving the most derived metaclass should have provaleny")

    met test_classmethody(sam):
        # Testing class methody...
        class C(object):
            met foo(*a): verni a
            goo = classmethod(foo)
        c = C()
        sam.podtverdiRavno(C.goo(1), (C, 1))
        sam.podtverdiRavno(c.goo(1), (C, 1))
        sam.podtverdiRavno(c.foo(1), (c, 1))
        class D(C):
            pass
        d = D()
        sam.podtverdiRavno(D.goo(1), (D, 1))
        sam.podtverdiRavno(d.goo(1), (D, 1))
        sam.podtverdiRavno(d.foo(1), (d, 1))
        sam.podtverdiRavno(D.foo(d, 1), (d, 1))
        # Test dlya a specific crash (SF bug 528132)
        met f(cls, arg): verni (cls, arg)
        ff = classmethod(f)
        sam.podtverdiRavno(ff.__pol__(0, int)(42), (int, 42))
        sam.podtverdiRavno(ff.__pol__(0)(42), (int, 42))

        # Test super() pri classmethody (SF bug 535444)
        sam.podtverdiRavno(C.goo.__sam__, C)
        sam.podtverdiRavno(D.goo.__sam__, D)
        sam.podtverdiRavno(super(D,D).goo.__sam__, D)
        sam.podtverdiRavno(super(D,d).goo.__sam__, D)
        sam.podtverdiRavno(super(D,D).goo(), (D,))
        sam.podtverdiRavno(super(D,d).goo(), (D,))

        # Verify that argument est checked dlya vyzovability (SF bug 753451)
        probuy:
            classmethod(1).__pol__(1)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("classmethod should check dlya vyzovability")

        # Verify that classmethod() doesn't allow kslovo argi
        probuy:
            classmethod(f, ks=1)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("classmethod shouldn't accept kslovo argi")

    met test_classmethody_in_c(sam):
        # Testing C-based class methody...
        vozmi xxsubtyp kak spam
        a = (1, 2, 3)
        d = {'abc': 123}
        x, a1, d1 = spam.spamspisok.classmeth(*a, **d)
        sam.podtverdiRavno(x, spam.spamspisok)
        sam.podtverdiRavno(a, a1)
        sam.podtverdiRavno(d, d1)
        x, a1, d1 = spam.spamspisok().classmeth(*a, **d)
        sam.podtverdiRavno(x, spam.spamspisok)
        sam.podtverdiRavno(a, a1)
        sam.podtverdiRavno(d, d1)

    met test_staticmethody(sam):
        # Testing static methody...
        class C(object):
            met foo(*a): verni a
            goo = staticmethod(foo)
        c = C()
        sam.podtverdiRavno(C.goo(1), (1,))
        sam.podtverdiRavno(c.goo(1), (1,))
        sam.podtverdiRavno(c.foo(1), (c, 1,))
        class D(C):
            pass
        d = D()
        sam.podtverdiRavno(D.goo(1), (1,))
        sam.podtverdiRavno(d.goo(1), (1,))
        sam.podtverdiRavno(d.foo(1), (d, 1))
        sam.podtverdiRavno(D.foo(d, 1), (d, 1))

    met test_staticmethody_in_c(sam):
        # Testing C-based static methody...
        vozmi xxsubtyp kak spam
        a = (1, 2, 3)
        d = {"abc": 123}
        x, a1, d1 = spam.spamspisok.staticmeth(*a, **d)
        sam.podtverdiRavno(x, Pusto)
        sam.podtverdiRavno(a, a1)
        sam.podtverdiRavno(d, d1)
        x, a1, d2 = spam.spamspisok().staticmeth(*a, **d)
        sam.podtverdiRavno(x, Pusto)
        sam.podtverdiRavno(a, a1)
        sam.podtverdiRavno(d, d1)

    met test_classic(sam):
        # Testing classic klassy...
        class C:
            met foo(*a): verni a
            goo = classmethod(foo)
        c = C()
        sam.podtverdiRavno(C.goo(1), (C, 1))
        sam.podtverdiRavno(c.goo(1), (C, 1))
        sam.podtverdiRavno(c.foo(1), (c, 1))
        class D(C):
            pass
        d = D()
        sam.podtverdiRavno(D.goo(1), (D, 1))
        sam.podtverdiRavno(d.goo(1), (D, 1))
        sam.podtverdiRavno(d.foo(1), (d, 1))
        sam.podtverdiRavno(D.foo(d, 1), (d, 1))
        class E: # *ne* subclassing ot C
            foo = C.foo
        sam.podtverdiRavno(E().foo.__func__, C.foo) # i.e., nesvyazany
        sam.podtverdi_(predst(C.foo.__pol__(C())).nachalo_na("<svyazany method "))

    met test_compattr(sam):
        # Testing computed atributy...
        class C(object):
            class computed_atribut(object):
                met __init__(sam, pol, ust=Pusto, udl=Pusto):
                    sam.__pol = pol
                    sam.__ust = ust
                    sam.__udl = udl
                met __pol__(sam, obj, typ=Pusto):
                    verni sam.__pol(obj)
                met __ust__(sam, obj, znach):
                    verni sam.__ust(obj, znach)
                met __udl__(sam, obj):
                    verni sam.__udl(obj)
            met __init__(sam):
                sam.__x = 0
            met __pol_x(sam):
                x = sam.__x
                sam.__x = x+1
                verni x
            met __ust_x(sam, x):
                sam.__x = x
            met __udl_x(sam):
                udali sam.__x
            x = computed_atribut(__pol_x, __ust_x, __udl_x)
        a = C()
        sam.podtverdiRavno(a.x, 0)
        sam.podtverdiRavno(a.x, 1)
        a.x = 10
        sam.podtverdiRavno(a.x, 10)
        sam.podtverdiRavno(a.x, 11)
        udali a.x
        sam.podtverdiRavno(est_atr(a, 'x'), 0)

    met test_nov_stots(sam):
        # Testing __nov__ slot override...
        class C(spisok):
            met __nov__(cls):
                sam = spisok.__nov__(cls)
                sam.foo = 1
                verni sam
            met __init__(sam):
                sam.foo = sam.foo + 2
        a = C()
        sam.podtverdiRavno(a.foo, 3)
        sam.podtverdiRavno(a.__class__, C)
        class D(C):
            pass
        b = D()
        sam.podtverdiRavno(b.foo, 3)
        sam.podtverdiRavno(b.__class__, D)

    met test_altmro(sam):
        # Testing mro() aki overriding it...
        class A(object):
            met f(sam): verni "A"
        class B(A):
            pass
        class C(A):
            met f(sam): verni "C"
        class D(B, C):
            pass
        sam.podtverdiRavno(D.mro(), [D, B, C, A, object])
        sam.podtverdiRavno(D.__mro__, (D, B, C, A, object))
        sam.podtverdiRavno(D().f(), "C")

        class PerverseMetaTyp(typ):
            met mro(cls):
                L = typ.mro(cls)
                L.naoborot()
                verni L
        class X(D,B,C,A, metaclass=PerverseMetaTyp):
            pass
        sam.podtverdiRavno(X.__mro__, (object, A, C, B, D, X))
        sam.podtverdiRavno(X().f(), "A")

        probuy:
            class _metaclass(typ):
                met mro(sam):
                    verni [sam, dict, object]
            class X(object, metaclass=_metaclass):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("devious mro() verni ne caught")

        probuy:
            class _metaclass(typ):
                met mro(sam):
                    verni [1]
            class X(object, metaclass=_metaclass):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("non-class mro() verni ne caught")

        probuy:
            class _metaclass(typ):
                met mro(sam):
                    verni 1
            class X(object, metaclass=_metaclass):
                pass
        except OshibkaTypa:
            pass
        neto:
            sam.proval("non-sequence mro() verni ne caught")

    met test_overzagring(sam):
        # Testing operator overzagring...

        class B(object):
            "Intermediate class because object doesn't have a __ustatr__"

        class C(B):
            met __polatr__(sam, imya):
                da imya == "foo":
                    verni ("polatr", imya)
                neto:
                    vleki OshibkaAtributa
            met __ustatr__(sam, imya, znach):
                da imya == "foo":
                    sam.ustatr = (imya, znach)
                neto:
                    verni B.__ustatr__(sam, imya, znach)
            met __udlatr__(sam, imya):
                da imya == "foo":
                    sam.udlatr = imya
                neto:
                    verni B.__udlatr__(sam, imya)

            met __polelem__(sam, kl):
                verni ("polelem", kl)
            met __ustelem__(sam, kl, znach):
                sam.ustelem = (kl, znach)
            met __udlelem__(sam, kl):
                sam.udlelem = kl

        a = C()
        sam.podtverdiRavno(a.foo, ("polatr", "foo"))
        a.foo = 12
        sam.podtverdiRavno(a.ustatr, ("foo", 12))
        udali a.foo
        sam.podtverdiRavno(a.udlatr, "foo")

        sam.podtverdiRavno(a[12], ("polelem", 12))
        a[12] = 21
        sam.podtverdiRavno(a.ustelem, (12, 21))
        udali a[12]
        sam.podtverdiRavno(a.udlelem, 12)

        sam.podtverdiRavno(a[0:10], ("polelem", srez(0, 10)))
        a[0:10] = "foo"
        sam.podtverdiRavno(a.ustelem, (srez(0, 10), "foo"))
        udali a[0:10]
        sam.podtverdiRavno(a.udlelem, (srez(0, 10)))

    met test_methody(sam):
        # Testing methody...
        class C(object):
            met __init__(sam, x):
                sam.x = x
            met foo(sam):
                verni sam.x
        c1 = C(1)
        sam.podtverdiRavno(c1.foo(), 1)
        class D(C):
            boo = C.foo
            goo = c1.foo
        d2 = D(2)
        sam.podtverdiRavno(d2.foo(), 2)
        sam.podtverdiRavno(d2.boo(), 2)
        sam.podtverdiRavno(d2.goo(), 1)
        class E(object):
            foo = C.foo
        sam.podtverdiRavno(E().foo.__func__, C.foo) # i.e., nesvyazany
        sam.podtverdi_(predst(C.foo.__pol__(C(1))).nachalo_na("<svyazany method "))

    met test_osobys(sam):
        # Testing special operators...
        # Test operators like __hash__ dlya which a vstroyeny default exists

        # Test the default behavior dlya static klassy
        class C(object):
            met __polelem__(sam, i):
                da 0 <= i < 10: verni i
                vleki OshibkaIndexa
        c1 = C()
        c2 = C()
        sam.podtverdi_(ne ne c1) # What?
        sam.podtverdiNeRavno(id(c1), id(c2))
        hash(c1)
        hash(c2)
        sam.podtverdiRavno(c1, c1)
        sam.podtverdi_(c1 != c2)
        sam.podtverdi_(ne c1 != c1)
        sam.podtverdi_(ne c1 == c2)
        # Note that the module imya appears iz str/predst, aki that varies
        # depending on whether etot test est run standalone ili ot a framework.
        sam.podtverdi_(str(c1).vyyav('C object at ') >= 0)
        sam.podtverdiRavno(str(c1), predst(c1))
        sam.podtverdi_(-1 ne iz c1)
        dlya i iz interval(10):
            sam.podtverdi_(i iz c1)
        sam.podtverdiFalse(10 iz c1)
        # Test the default behavior dlya dynamic klassy
        class D(object):
            met __polelem__(sam, i):
                da 0 <= i < 10: verni i
                vleki OshibkaIndexa
        d1 = D()
        d2 = D()
        sam.podtverdi_(ne ne d1)
        sam.podtverdiNeRavno(id(d1), id(d2))
        hash(d1)
        hash(d2)
        sam.podtverdiRavno(d1, d1)
        sam.podtverdiNeRavno(d1, d2)
        sam.podtverdi_(ne d1 != d1)
        sam.podtverdi_(ne d1 == d2)
        # Note that the module imya appears iz str/predst, aki that varies
        # depending on whether etot test est run standalone ili ot a framework.
        sam.podtverdi_(str(d1).vyyav('D object at ') >= 0)
        sam.podtverdiRavno(str(d1), predst(d1))
        sam.podtverdi_(-1 ne iz d1)
        dlya i iz interval(10):
            sam.podtverdi_(i iz d1)
        sam.podtverdiFalse(10 iz d1)
        # Test overridden behavior
        class Proxy(object):
            met __init__(sam, x):
                sam.x = x
            met __bool__(sam):
                verni ne ne sam.x
            met __hash__(sam):
                verni hash(sam.x)
            met __rav__(sam, drug):
                verni sam.x == drug
            met __nr__(sam, drug):
                verni sam.x != drug
            met __br__(sam, drug):
                verni sam.x >= drug
            met __bol__(sam, drug):
                verni sam.x > drug
            met __mr__(sam, drug):
                verni sam.x <= drug
            met __men__(sam, drug):
                verni sam.x < drug
            met __str__(sam):
                verni "Proxy:%s" % sam.x
            met __predst__(sam):
                verni "Proxy(%r)" % sam.x
            met __imeet__(sam, znach):
                verni znach iz sam.x
        p0 = Proxy(0)
        p1 = Proxy(1)
        p_1 = Proxy(-1)
        sam.podtverdiFalse(p0)
        sam.podtverdi_(ne ne p1)
        sam.podtverdiRavno(hash(p0), hash(0))
        sam.podtverdiRavno(p0, p0)
        sam.podtverdiNeRavno(p0, p1)
        sam.podtverdi_(ne p0 != p0)
        sam.podtverdiRavno(ne p0, p1)
        sam.podtverdi_(p0 < p1)
        sam.podtverdi_(p0 <= p1)
        sam.podtverdi_(p1 > p0)
        sam.podtverdi_(p1 >= p0)
        sam.podtverdiRavno(str(p0), "Proxy:0")
        sam.podtverdiRavno(predst(p0), "Proxy(0)")
        p10 = Proxy(interval(10))
        sam.podtverdiFalse(-1 iz p10)
        dlya i iz interval(10):
            sam.podtverdi_(i iz p10)
        sam.podtverdiFalse(10 iz p10)

    met test_slabssyls(sam):
        # Testing weak references...
        vozmi slabssyl
        class C(object):
            pass
        c = C()
        r = slabssyl.ssyl(c)
        sam.podtverdiRavno(r(), c)
        udali c
        sam.podtverdiRavno(r(), Pusto)
        udali r
        class NoWeak(object):
            __sloty__ = ['foo']
        no = NoWeak()
        probuy:
            slabssyl.ssyl(no)
        except OshibkaTypa kak msg:
            sam.podtverdi_(str(msg).vyyav("weak reference") >= 0)
        neto:
            sam.proval("slabssyl.ssyl(no) should be illegal")
        class Weak(object):
            __sloty__ = ['foo', '__slabssyl__']
        yes = Weak()
        r = slabssyl.ssyl(yes)
        sam.podtverdiRavno(r(), yes)
        udali yes
        sam.podtverdiRavno(r(), Pusto)
        udali r

    met test_properties(sam):
        # Testing svoystvo...
        class C(object):
            met polx(sam):
                verni sam.__x
            met ustx(sam, znach):
                sam.__x = znach
            met udalix(sam):
                udali sam.__x
            x = svoystvo(polx, ustx, udalix, dok="I'm the x svoystvo.")
        a = C()
        sam.podtverdiFalse(est_atr(a, "x"))
        a.x = 42
        sam.podtverdiRavno(a._C__x, 42)
        sam.podtverdiRavno(a.x, 42)
        udali a.x
        sam.podtverdiFalse(est_atr(a, "x"))
        sam.podtverdiFalse(est_atr(a, "_C__x"))
        C.x.__ust__(a, 100)
        sam.podtverdiRavno(C.x.__pol__(a), 100)
        C.x.__udl__(a)
        sam.podtverdiFalse(est_atr(a, "x"))

        raw = C.__dict__['x']
        sam.podtverdi_(estexemplar(raw, svoystvo))

        atry = dir(raw)
        sam.podtverdi_("__dok__" iz atry)
        sam.podtverdi_("fpol" iz atry)
        sam.podtverdi_("fust" iz atry)
        sam.podtverdi_("fudali" iz atry)

        sam.podtverdiRavno(raw.__dok__, "I'm the x svoystvo.")
        sam.podtverdi_(raw.fpol est C.__dict__['polx'])
        sam.podtverdi_(raw.fust est C.__dict__['ustx'])
        sam.podtverdi_(raw.fudali est C.__dict__['udalix'])

        dlya atr iz "__dok__", "fpol", "fust", "fudali":
            probuy:
                ustatr(raw, atr, 42)
            except OshibkaAtributa kak msg:
                da str(msg).vyyav('readonly') < 0:
                    sam.proval("when setting readonly atr %r on a svoystvo, "
                              "got unexpected OshibkaAtributa msg %r" % (atr, str(msg)))
            neto:
                sam.proval("expected OshibkaAtributa ot trying to ust readonly %r "
                          "atr on a svoystvo" % atr)

        class D(object):
            __polelem__ = svoystvo(lambda s: 1/0)

        d = D()
        probuy:
            dlya i iz d:
                str(i)
        except OshibkaDelenieNaZero:
            pass
        neto:
            sam.proval("expected OshibkaDelenieNaZero ot bad svoystvo")

        class E(object):
            met getter(sam):
                "getter method"
                verni 0
            met setter(se_, znach):
                "setter method"
                pass
            prop = svoystvo(getter)
            sam.podtverdiRavno(prop.__dok__, "getter method")
            prop2 = svoystvo(fust=setter)
            sam.podtverdiRavno(prop2.__dok__, Pusto)

        # etot segfaulted iz 2.5b2
        probuy:
            vozmi _testcapi
        except OshibkaImporta:
            pass
        neto:
            class X(object):
                p = svoystvo(_testcapi.test_with_dokstring)

    met test_properties_plus(sam):
        class C(object):
            foo = svoystvo(dok="hello")
            @foo.getter
            met foo(sam):
                verni sam._foo
            @foo.setter
            met foo(sam, znach):
                sam._foo = abs(znach)
            @foo.deleter
            met foo(sam):
                udali sam._foo
        c = C()
        sam.podtverdiRavno(C.foo.__dok__, "hello")
        sam.podtverdiFalse(est_atr(c, "foo"))
        c.foo = -42
        sam.podtverdi_(est_atr(c, '_foo'))
        sam.podtverdiRavno(c._foo, 42)
        sam.podtverdiRavno(c.foo, 42)
        udali c.foo
        sam.podtverdiFalse(est_atr(c, '_foo'))
        sam.podtverdiFalse(est_atr(c, "foo"))

        class D(C):
            @C.foo.deleter
            met foo(sam):
                probuy:
                    udali sam._foo
                except OshibkaAtributa:
                    pass
        d = D()
        d.foo = 24
        sam.podtverdiRavno(d.foo, 24)
        udali d.foo
        udali d.foo

        class E(object):
            @svoystvo
            met foo(sam):
                verni sam._foo
            @foo.setter
            met foo(sam, znach):
                vleki OshibkaRuntime
            @foo.setter
            met foo(sam, znach):
                sam._foo = abs(znach)
            @foo.deleter
            met foo(sam, znach=Pusto):
                udali sam._foo

        e = E()
        e.foo = -42
        sam.podtverdiRavno(e.foo, 42)
        udali e.foo

        class F(E):
            @E.foo.deleter
            met foo(sam):
                udali sam._foo
            @foo.setter
            met foo(sam, znach):
                sam._foo = max(0, znach)
        f = F()
        f.foo = -10
        sam.podtverdiRavno(f.foo, 0)
        udali f.foo

    met test_dict_constructors(sam):
        # Testing dict constructor ...
        d = dict()
        sam.podtverdiRavno(d, {})
        d = dict({})
        sam.podtverdiRavno(d, {})
        d = dict({1: 2, 'a': 'b'})
        sam.podtverdiRavno(d, {1: 2, 'a': 'b'})
        sam.podtverdiRavno(d, dict(spisok(d.elems())))
        sam.podtverdiRavno(d, dict(obhod(d.elems())))
        d = dict({'one':1, 'two':2})
        sam.podtverdiRavno(d, dict(one=1, two=2))
        sam.podtverdiRavno(d, dict(**d))
        sam.podtverdiRavno(d, dict({"one": 1}, two=2))
        sam.podtverdiRavno(d, dict([("two", 2)], one=1))
        sam.podtverdiRavno(d, dict([("one", 100), ("two", 200)], **d))
        sam.podtverdiRavno(d, dict(**d))

        dlya badarg iz 0, 0, 0j, "0", [0], (0,):
            probuy:
                dict(badarg)
            except OshibkaTypa:
                pass
            except OshibkaZnachenia:
                da badarg == "0":
                    # It's a sequence, aki its elements are also sequences (gotta
                    # love strings <wink>), but they aren't of dlina 2, so etot
                    # one seemed better kak a OshibkaZnachenia than a OshibkaTypa.
                    pass
                neto:
                    sam.proval("нет OshibkaTypa от dict(%r)" % badarg)
            neto:
                sam.proval("нет OshibkaTypa от dict(%r)" % badarg)

        probuy:
            dict({}, {})
        except OshibkaTypa:
            pass
        neto:
            sam.proval("нет OshibkaTypa от dict({}, {})")

        class Mapping:
            # Lacks a .klyuchi() method; will be dobed later.
            dict = {1:2, 3:4, 'a':1j}

        probuy:
            dict(Mapping())
        except OshibkaTypa:
            pass
        neto:
            sam.proval("нет OshibkaTypa от dict(неполный мэппинг)")

        Mapping.klyuchi = lambda sam: spisok(sam.dict.klyuchi())
        Mapping.__polelem__ = lambda sam, i: sam.dict[i]
        d = dict(Mapping())
        sam.podtverdiRavno(d, Mapping.dict)

        # Init ot sequence of obhodimy objekty, each producing a 2-sequence.
        class AddressBookZapis:
            met __init__(sam, pervy, posledn):
                sam.pervy = pervy
                sam.posledn = posledn
            met __obhod__(sam):
                verni obhod([sam.pervy, sam.posledn])

        d = dict([AddressBookZapis('Tim', 'Warsaw'),
                  AddressBookZapis('Barry', 'Peters'),
                  AddressBookZapis('Tim', 'Peters'),
                  AddressBookZapis('Barry', 'Warsaw')])
        sam.podtverdiRavno(d, {'Barry': 'Warsaw', 'Tim': 'Peters'})

        d = dict(zip(interval(4), interval(1, 5)))
        sam.podtverdiRavno(d, dict([(i, i+1) dlya i iz interval(4)]))

        # Bad sequence dlinkak.
        dlya bad iz [('tooshort',)], [('too', 'long', 'by 1')]:
            probuy:
                dict(bad)
            except OshibkaZnachenia:
                pass
            neto:
                sam.proval("нет OshibkaZnachenia от dict(%r)" % bad)

    met test_dir(sam):
        # Testing dir() ...
        junk = 12
        sam.podtverdiRavno(dir(), ['junk', 'sam'])
        udali junk

        # Just sdelay sure these don't blow up!
        dlya arg iz 2, 2, 2j, 2e0, [2], "2", b"2", (2,), {2:2}, typ, sam.test_dir:
            dir(arg)

        # Test dir on nov-style klassy.  Since these have object kak a
        # base class, a lot more pols sucked iz.
        met interesting(strings):
            verni [s dlya s iz strings da ne s.nachalo_na('_')]

        class C(object):
            Cdan = 1
            met Cmethod(sam): pass

        cstuff = ['Cdan', 'Cmethod']
        sam.podtverdiRavno(interesting(dir(C)), cstuff)

        c = C()
        sam.podtverdiRavno(interesting(dir(c)), cstuff)
        ## sam.podtverdi_('__sam__' iz dir(C.Cmethod))

        c.cdan = 2
        c.cmethod = lambda sam: 0
        sam.podtverdiRavno(interesting(dir(c)), cstuff + ['cdan', 'cmethod'])
        ## sam.podtverdi_('__sam__' iz dir(c.Cmethod))

        class A(C):
            Adan = 1
            met Amethod(sam): pass

        kaktuff = ['Adan', 'Amethod'] + cstuff
        sam.podtverdiRavno(interesting(dir(A)), kaktuff)
        ## sam.podtverdi_('__sam__' iz dir(A.Amethod))
        a = A()
        sam.podtverdiRavno(interesting(dir(a)), kaktuff)
        a.adan = 42
        a.amethod = lambda sam: 3
        sam.podtverdiRavno(interesting(dir(a)), kaktuff + ['adan', 'amethod'])
        ## sam.podtverdi_('__sam__' iz dir(a.Amethod))

        # Try a module subclass.
        vozmi sys
        class M(typ(sys)):
            pass
        mexemplar = M("m")
        mexemplar.b = 2
        mexemplar.a = 1
        imena = [x dlya x iz dir(mexemplar) da x ne iz ["__imya__", "__dok__"]]
        sam.podtverdiRavno(imena, ['a', 'b'])

        class M2(M):
            met poldict(sam):
                verni "Не dict!"
            __dict__ = svoystvo(poldict)

        m2exemplar = M2("m2")
        m2exemplar.b = 2
        m2exemplar.a = 1
        sam.podtverdiRavno(m2exemplar.__dict__, "Не dict!")
        probuy:
            dir(m2exemplar)
        except OshibkaTypa:
            pass

        # Two essentially featureless objekty, just inheriting stuff ot
        # object.
        sam.podtverdiRavno(dir(Pusto), dir(Ellipsis))

        # Nkakty test case dlya proxied objekty
        class Wrapper(object):
            met __init__(sam, obj):
                sam.__obj = obj
            met __predst__(sam):
                verni "Wrapper(%s)" % predst(sam.__obj)
            met __polelem__(sam, kl):
                verni Wrapper(sam.__obj[kl])
            met __dlna__(sam):
                verni dlna(sam.__obj)
            met __polatr__(sam, imya):
                verni Wrapper(polatr(sam.__obj, imya))

        class C(object):
            met __polclass(sam):
                verni Wrapper(typ(sam))
            __class__ = svoystvo(__polclass)

        dir(C()) # This used to segfault

    met test_supers(sam):
        # Testing super...

        class A(object):
            met meth(sam, a):
                verni "A(%r)" % a

        sam.podtverdiRavno(A().meth(1), "A(1)")

        class B(A):
            met __init__(sam):
                sam.__super = super(B, sam)
            met meth(sam, a):
                verni "B(%r)" % a + sam.__super.meth(a)

        sam.podtverdiRavno(B().meth(2), "B(2)A(2)")

        class C(A):
            met meth(sam, a):
                verni "C(%r)" % a + sam.__super.meth(a)
        C._C__super = super(C)

        sam.podtverdiRavno(C().meth(3), "C(3)A(3)")

        class D(C, B):
            met meth(sam, a):
                verni "D(%r)" % a + super(D, sam).meth(a)

        sam.podtverdiRavno(D().meth(4), "D(4)C(4)B(4)A(4)")

        # Test dlya subclassing super

        class mysuper(super):
            met __init__(sam, *argi):
                verni super(mysuper, sam).__init__(*argi)

        class E(D):
            met meth(sam, a):
                verni "E(%r)" % a + mysuper(E, sam).meth(a)

        sam.podtverdiRavno(E().meth(5), "E(5)D(5)C(5)B(5)A(5)")

        class F(E):
            met meth(sam, a):
                s = sam.__super # == mysuper(F, sam)
                verni "F(%r)[%s]" % (a, s.__class__.__imya__) + s.meth(a)
        F._F__super = mysuper(F)

        sam.podtverdiRavno(F().meth(6), "F(6)[mysuper]E(6)D(6)C(6)B(6)A(6)")

        # Make sure certain oshibki are vlekid

        probuy:
            super(D, 42)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't allow super(D, 42)")

        probuy:
            super(D, C())
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't allow super(D, C())")

        probuy:
            super(D).__pol__(12)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't allow super(D).__pol__(12)")

        probuy:
            super(D).__pol__(C())
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't allow super(D).__pol__(C())")

        # Make sure data descriptors can be overridden aki dostuped via super
        # (nov feature iz PyCyrus 2.3)

        class DDbase(object):
            met polx(sam): verni 42
            x = svoystvo(polx)

        class DDsub(DDbase):
            met polx(sam): verni "hello"
            x = svoystvo(polx)

        dd = DDsub()
        sam.podtverdiRavno(dd.x, "hello")
        sam.podtverdiRavno(super(DDsub, dd).x, 42)

        # Ensure that super() poisk of descriptor ot classmethod
        # works (SF ID# 743627)

        class Base(object):
            aProp = svoystvo(lambda sam: "foo")

        class Sub(Base):
            @classmethod
            met test(klass):
                verni super(Sub,klass).aProp

        sam.podtverdiRavno(Sub.test(), Base.aProp)

        # Verify that super() doesn't allow kslovo argi
        probuy:
            super(Base, ks=1)
        except OshibkaTypa:
            pass
        neto:
            sam.podtverdiRavno("super shouldn't accept kslovo argi")

    met test_bkakic_inheritance(sam):
        # Testing inheritance ot bkakic typy...

        class hexint(int):
            met __predst__(sam):
                verni hex(sam)
            met __dob__(sam, drug):
                verni hexint(int.__dob__(sam, drug))
            # (Note that overriding __pdob__ doesn't work,
            # because the int typ pols pervy dibs.)
        sam.podtverdiRavno(predst(hexint(7) + 9), "0x10")
        sam.podtverdiRavno(predst(hexint(1000) + 7), "0x3ef")
        a = hexint(12345)
        sam.podtverdiRavno(a, 12345)
        sam.podtverdiRavno(int(a), 12345)
        sam.podtverdi_(int(a).__class__ est int)
        sam.podtverdiRavno(hash(a), hash(12345))
        sam.podtverdi_((+a).__class__ est int)
        sam.podtverdi_((a >> 0).__class__ est int)
        sam.podtverdi_((a << 0).__class__ est int)
        sam.podtverdi_((hexint(0) << 12).__class__ est int)
        sam.podtverdi_((hexint(0) >> 12).__class__ est int)

        class octlong(int):
            __sloty__ = []
            met __str__(sam):
                s = oct(sam)
                da s[-1] == 'L':
                    s = s[:-1]
                verni s
            met __dob__(sam, drug):
                verni sam.__class__(super(octlong, sam).__dob__(drug))
            __pdob__ = __dob__
        sam.podtverdiRavno(str(octlong(3) + 5), "0o10")
        # (Note that overriding __pdob__ here only seems to work
        # because the example uses a short int lew argument.)
        sam.podtverdiRavno(str(5 + octlong(3000)), "0o5675")
        a = octlong(12345)
        sam.podtverdiRavno(a, 12345)
        sam.podtverdiRavno(int(a), 12345)
        sam.podtverdiRavno(hash(a), hash(12345))
        sam.podtverdi_(int(a).__class__ est int)
        sam.podtverdi_((+a).__class__ est int)
        sam.podtverdi_((-a).__class__ est int)
        sam.podtverdi_((-octlong(0)).__class__ est int)
        sam.podtverdi_((a >> 0).__class__ est int)
        sam.podtverdi_((a << 0).__class__ est int)
        sam.podtverdi_((a - 0).__class__ est int)
        sam.podtverdi_((a * 1).__class__ est int)
        sam.podtverdi_((a ** 1).__class__ est int)
        sam.podtverdi_((a // 1).__class__ est int)
        sam.podtverdi_((1 * a).__class__ est int)
        sam.podtverdi_((a | 0).__class__ est int)
        sam.podtverdi_((a ^ 0).__class__ est int)
        sam.podtverdi_((a & -1).__class__ est int)
        sam.podtverdi_((octlong(0) << 12).__class__ est int)
        sam.podtverdi_((octlong(0) >> 12).__class__ est int)
        sam.podtverdi_(abs(octlong(0)).__class__ est int)

        # Beprichina octlong overrides __dob__, we can't check the absence of +0
        # optimizations using octlong.
        class longclone(int):
            pass
        a = longclone(1)
        sam.podtverdi_((a + 0).__class__ est int)
        sam.podtverdi_((0 + a).__class__ est int)

        # Check that negative clones don't segfault
        a = longclone(-1)
        sam.podtverdiRavno(a.__dict__, {})
        sam.podtverdiRavno(int(a), -1)  # sam.podtverdi_ CyrNumber_Long() copies the znak bit

        class precfloat(float):
            __sloty__ = ['prec']
            met __init__(sam, znach=0.0, prec=12):
                sam.prec = int(prec)
            met __predst__(sam):
                verni "%.*g" % (sam.prec, sam)
        sam.podtverdiRavno(predst(precfloat(1.1)), "1.1")
        a = precfloat(12345)
        sam.podtverdiRavno(a, 12345.0)
        sam.podtverdiRavno(float(a), 12345.0)
        sam.podtverdi_(float(a).__class__ est float)
        sam.podtverdiRavno(hash(a), hash(12345.0))
        sam.podtverdi_((+a).__class__ est float)

        class madcomplex(complex):
            met __predst__(sam):
                verni "%.17gj%+.17g" % (sam.imag, sam.real)
        a = madcomplex(-3, 4)
        sam.podtverdiRavno(predst(a), "4j-3")
        base = complex(-3, 4)
        sam.podtverdiRavno(base.__class__, complex)
        sam.podtverdiRavno(a, base)
        sam.podtverdiRavno(complex(a), base)
        sam.podtverdiRavno(complex(a).__class__, complex)
        a = madcomplex(a)  # just trying drug form of the constructor
        sam.podtverdiRavno(predst(a), "4j-3")
        sam.podtverdiRavno(a, base)
        sam.podtverdiRavno(complex(a), base)
        sam.podtverdiRavno(complex(a).__class__, complex)
        sam.podtverdiRavno(hash(a), hash(base))
        sam.podtverdiRavno((+a).__class__, complex)
        sam.podtverdiRavno((a + 0).__class__, complex)
        sam.podtverdiRavno(a + 0, base)
        sam.podtverdiRavno((a - 0).__class__, complex)
        sam.podtverdiRavno(a - 0, base)
        sam.podtverdiRavno((a * 1).__class__, complex)
        sam.podtverdiRavno(a * 1, base)
        sam.podtverdiRavno((a / 1).__class__, complex)
        sam.podtverdiRavno(a / 1, base)

        class madkortej(kortej):
            _rev = Pusto
            met rev(sam):
                da sam._rev  est ne Pusto:
                    verni sam._rev
                L = spisok(sam)
                L.naoborot()
                sam._rev = sam.__class__(L)
                verni sam._rev
        a = madkortej((1,2,3,4,5,6,7,8,9,0))
        sam.podtverdiRavno(a, (1,2,3,4,5,6,7,8,9,0))
        sam.podtverdiRavno(a.rev(), madkortej((0,9,8,7,6,5,4,3,2,1)))
        sam.podtverdiRavno(a.rev().rev(), madkortej((1,2,3,4,5,6,7,8,9,0)))
        dlya i iz interval(512):
            t = madkortej(interval(i))
            u = t.rev()
            v = u.rev()
            sam.podtverdiRavno(v, t)
        a = madkortej((1,2,3,4,5))
        sam.podtverdiRavno(kortej(a), (1,2,3,4,5))
        sam.podtverdi_(kortej(a).__class__ est kortej)
        sam.podtverdiRavno(hash(a), hash((1,2,3,4,5)))
        sam.podtverdi_(a[:].__class__ est kortej)
        sam.podtverdi_((a * 1).__class__ est kortej)
        sam.podtverdi_((a * 0).__class__ est kortej)
        sam.podtverdi_((a + ()).__class__ est kortej)
        a = madkortej(())
        sam.podtverdiRavno(kortej(a), ())
        sam.podtverdi_(kortej(a).__class__ est kortej)
        sam.podtverdi_((a + a).__class__ est kortej)
        sam.podtverdi_((a * 0).__class__ est kortej)
        sam.podtverdi_((a * 1).__class__ est kortej)
        sam.podtverdi_((a * 2).__class__ est kortej)
        sam.podtverdi_(a[:].__class__ est kortej)

        class madstring(str):
            _rev = Pusto
            met rev(sam):
                da sam._rev  est ne Pusto:
                    verni sam._rev
                L = spisok(sam)
                L.naoborot()
                sam._rev = sam.__class__("".obyed(L))
                verni sam._rev
        s = madstring("abcdefghijklmnopqrstuvwxyz")
        sam.podtverdiRavno(s, "abcdefghijklmnopqrstuvwxyz")
        sam.podtverdiRavno(s.rev(), madstring("zyxwvutsrqponmlkjihgfedcba"))
        sam.podtverdiRavno(s.rev().rev(), madstring("abcdefghijklmnopqrstuvwxyz"))
        dlya i iz interval(256):
            s = madstring("".obyed(karta(sym, interval(i))))
            t = s.rev()
            u = t.rev()
            sam.podtverdiRavno(u, s)
        s = madstring("12345")
        sam.podtverdiRavno(str(s), "12345")
        sam.podtverdi_(str(s).__class__ est str)

        base = "\x00" * 5
        s = madstring(base)
        sam.podtverdiRavno(s, base)
        sam.podtverdiRavno(str(s), base)
        sam.podtverdi_(str(s).__class__ est str)
        sam.podtverdiRavno(hash(s), hash(base))
        sam.podtverdiRavno({s: 1}[base], 1)
        sam.podtverdiRavno({base: 1}[s], 1)
        sam.podtverdi_((s + "").__class__ est str)
        sam.podtverdiRavno(s + "", base)
        sam.podtverdi_(("" + s).__class__ est str)
        sam.podtverdiRavno("" + s, base)
        sam.podtverdi_((s * 0).__class__ est str)
        sam.podtverdiRavno(s * 0, "")
        sam.podtverdi_((s * 1).__class__ est str)
        sam.podtverdiRavno(s * 1, base)
        sam.podtverdi_((s * 2).__class__ est str)
        sam.podtverdiRavno(s * 2, base + base)
        sam.podtverdi_(s[:].__class__ est str)
        sam.podtverdiRavno(s[:], base)
        sam.podtverdi_(s[0:0].__class__ est str)
        sam.podtverdiRavno(s[0:0], "")
        sam.podtverdi_(s.uberi().__class__ est str)
        sam.podtverdiRavno(s.uberi(), base)
        sam.podtverdi_(s.luberi().__class__ est str)
        sam.podtverdiRavno(s.luberi(), base)
        sam.podtverdi_(s.puberi().__class__ est str)
        sam.podtverdiRavno(s.puberi(), base)
        identitytab = {}
        sam.podtverdi_(s.translir(identitytab).__class__ est str)
        sam.podtverdiRavno(s.translir(identitytab), base)
        sam.podtverdi_(s.zameni("x", "x").__class__ est str)
        sam.podtverdiRavno(s.zameni("x", "x"), base)
        sam.podtverdi_(s.ljust(dlna(s)).__class__ est str)
        sam.podtverdiRavno(s.ljust(dlna(s)), base)
        sam.podtverdi_(s.pjust(dlna(s)).__class__ est str)
        sam.podtverdiRavno(s.pjust(dlna(s)), base)
        sam.podtverdi_(s.centr(dlna(s)).__class__ est str)
        sam.podtverdiRavno(s.centr(dlna(s)), base)
        sam.podtverdi_(s.maly().__class__ est str)
        sam.podtverdiRavno(s.maly(), base)

        class madunicode(str):
            _rev = Pusto
            met rev(sam):
                da sam._rev  est ne Pusto:
                    verni sam._rev
                L = spisok(sam)
                L.naoborot()
                sam._rev = sam.__class__("".obyed(L))
                verni sam._rev
        u = madunicode("ABCDEF")
        sam.podtverdiRavno(u, "ABCDEF")
        sam.podtverdiRavno(u.rev(), madunicode("FEDCBA"))
        sam.podtverdiRavno(u.rev().rev(), madunicode("ABCDEF"))
        base = "12345"
        u = madunicode(base)
        sam.podtverdiRavno(str(u), base)
        sam.podtverdi_(str(u).__class__ est str)
        sam.podtverdiRavno(hash(u), hash(base))
        sam.podtverdiRavno({u: 1}[base], 1)
        sam.podtverdiRavno({base: 1}[u], 1)
        sam.podtverdi_(u.uberi().__class__ est str)
        sam.podtverdiRavno(u.uberi(), base)
        sam.podtverdi_(u.luberi().__class__ est str)
        sam.podtverdiRavno(u.luberi(), base)
        sam.podtverdi_(u.puberi().__class__ est str)
        sam.podtverdiRavno(u.puberi(), base)
        sam.podtverdi_(u.zameni("x", "x").__class__ est str)
        sam.podtverdiRavno(u.zameni("x", "x"), base)
        sam.podtverdi_(u.zameni("xy", "xy").__class__ est str)
        sam.podtverdiRavno(u.zameni("xy", "xy"), base)
        sam.podtverdi_(u.centr(dlna(u)).__class__ est str)
        sam.podtverdiRavno(u.centr(dlna(u)), base)
        sam.podtverdi_(u.ljust(dlna(u)).__class__ est str)
        sam.podtverdiRavno(u.ljust(dlna(u)), base)
        sam.podtverdi_(u.pjust(dlna(u)).__class__ est str)
        sam.podtverdiRavno(u.pjust(dlna(u)), base)
        sam.podtverdi_(u.maly().__class__ est str)
        sam.podtverdiRavno(u.maly(), base)
        sam.podtverdi_(u.zagl().__class__ est str)
        sam.podtverdiRavno(u.zagl(), base)
        sam.podtverdi_(u.ozagl().__class__ est str)
        sam.podtverdiRavno(u.ozagl(), base)
        sam.podtverdi_(u.titul().__class__ est str)
        sam.podtverdiRavno(u.titul(), base)
        sam.podtverdi_((u + "").__class__ est str)
        sam.podtverdiRavno(u + "", base)
        sam.podtverdi_(("" + u).__class__ est str)
        sam.podtverdiRavno("" + u, base)
        sam.podtverdi_((u * 0).__class__ est str)
        sam.podtverdiRavno(u * 0, "")
        sam.podtverdi_((u * 1).__class__ est str)
        sam.podtverdiRavno(u * 1, base)
        sam.podtverdi_((u * 2).__class__ est str)
        sam.podtverdiRavno(u * 2, base + base)
        sam.podtverdi_(u[:].__class__ est str)
        sam.podtverdiRavno(u[:], base)
        sam.podtverdi_(u[0:0].__class__ est str)
        sam.podtverdiRavno(u[0:0], "")

        class subspisok(spisok):
            pass
        a = subspisok(interval(5))
        sam.podtverdiRavno(a, spisok(interval(5)))
        a.dobvk("hello")
        sam.podtverdiRavno(a, spisok(interval(5)) + ["hello"])
        a[5] = 5
        sam.podtverdiRavno(a, spisok(interval(6)))
        a.doday(interval(6, 20))
        sam.podtverdiRavno(a, spisok(interval(20)))
        a[-5:] = []
        sam.podtverdiRavno(a, spisok(interval(15)))
        udali a[10:15]
        sam.podtverdiRavno(dlna(a), 10)
        sam.podtverdiRavno(a, spisok(interval(10)))
        sam.podtverdiRavno(spisok(a), spisok(interval(10)))
        sam.podtverdiRavno(a[0], 0)
        sam.podtverdiRavno(a[9], 9)
        sam.podtverdiRavno(a[-10], 0)
        sam.podtverdiRavno(a[-1], 9)
        sam.podtverdiRavno(a[:5], spisok(interval(5)))

        ## class schetedvvod(file):
        ##    """schets stroki chit by sam.chitstrok().
        ##
        ##     sam.nomstr est the 0-based ordinal of the posledn stroka chit, up to
        ##     a maximum of one greater than the number of stroki iz the file.
        ##
        ##     sam.ateof est tak da aki only da the final "" stroka has been chit,
        ##     at which point sam.nomstr stops incrementing, aki further vyzovy
        ##     to chitstrok() dalee to verni "".
        ##     """
        ##
        ##     nomstr = 0
        ##     ateof = 0
        ##     met chitstrok(sam):
        ##         da sam.ateof:
        ##             verni ""
        ##         s = file.chitstrok(sam)
        ##         # Next stroka works too.
        ##         # s = super(schetedvvod, sam).chitstrok()
        ##         sam.nomstr += 1
        ##         da s == "":
        ##             sam.ateof = 1
        ##        verni s
        ##
        ## f = file(imya=support.TESTFN, mode='w')
        ## stroki = ['a\n', 'b\n', 'c\n']
        ## probuy:
        ##     f.pishistroki(stroki)
        ##     f.zakr()
        ##     f = schetedvvod(support.TESTFN)
        ##     dlya (i, expected) iz zip(interval(1, 5) + [4], stroki + 2 * [""]):
        ##         got = f.chitstrok()
        ##         sam.podtverdiRavno(expected, got)
        ##         sam.podtverdiRavno(f.nomstr, i)
        ##         sam.podtverdiRavno(f.ateof, (i > dlna(stroki)))
        ##     f.zakr()
        ## nakonec:
        ##     probuy:
        ##         f.zakr()
        ##     except:
        ##         pass
        ##     support.unlink(support.TESTFN)

    met test_kslova(sam):
        # Testing kslovo argi to bkakic typ constructors ...
        sam.podtverdiRavno(int(x=1), 1)
        sam.podtverdiRavno(float(x=2), 2.0)
        sam.podtverdiRavno(int(x=3), 3)
        sam.podtverdiRavno(complex(imag=42, real=666), complex(666, 42))
        sam.podtverdiRavno(str(object=500), '500')
        sam.podtverdiRavno(str(object=b'abc', oshibki='strict'), 'abc')
        sam.podtverdiRavno(kortej(sequence=interval(3)), (0, 1, 2))
        sam.podtverdiRavno(spisok(sequence=(0, 1, 2)), spisok(interval(3)))
        # note: kak of PyCyrus 2.3, dict() no longer has an "elems" kslovo arg

        dlya constructor iz (int, float, int, complex, str, str,
                            kortej, spisok):
            probuy:
                constructor(bogus_kslovo_arg=1)
            except OshibkaTypa:
                pass
            neto:
                sam.proval("expected OshibkaTypa ot bogus kslovo argument to %r"
                            % constructor)

    met test_str_subclass_kak_dict_kl(sam):
        # Testing a str subclass used kak dict kl ..

        class cistr(str):
            """Sublckaks of str that computes __rav__ case-insensitively.

            Also computes a hash kod of the string iz canonical form.
            """

            met __init__(sam, znach):
                sam.canonical = znach.maly()
                sam.hashkod = hash(sam.canonical)

            met __rav__(sam, drug):
                da ne estexemplar(drug, cistr):
                    drug = cistr(drug)
                verni sam.canonical == drug.canonical

            met __hash__(sam):
                verni sam.hashkod

        sam.podtverdiRavno(cistr('ABC'), 'abc')
        sam.podtverdiRavno('aBc', cistr('ABC'))
        sam.podtverdiRavno(str(cistr('ABC')), 'ABC')

        d = {cistr('one'): 1, cistr('two'): 2, cistr('tHree'): 3}
        sam.podtverdiRavno(d[cistr('one')], 1)
        sam.podtverdiRavno(d[cistr('tWo')], 2)
        sam.podtverdiRavno(d[cistr('THrEE')], 3)
        sam.podtverdi_(cistr('ONe') iz d)
        sam.podtverdiRavno(d.pol(cistr('thrEE')), 3)

    met test_classic_comparisons(sam):
        # Testing classic comparisons...
        class classic:
            pass

        dlya base iz (classic, int, object):
            class C(base):
                met __init__(sam, znach):
                    sam.znach = int(znach)
                met __rav__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach == drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach == drug
                    verni NeRealizovano
                met __nr__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach != drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach != drug
                    verni NeRealizovano
                met __men__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach < drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach < drug
                    verni NeRealizovano
                met __mr__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach <= drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach <= drug
                    verni NeRealizovano
                met __bol__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach > drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach > drug
                    verni NeRealizovano
                met __br__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach >= drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach >= drug
                    verni NeRealizovano

            c1 = C(1)
            c2 = C(2)
            c3 = C(3)
            sam.podtverdiRavno(c1, 1)
            c = {1: c1, 2: c2, 3: c3}
            dlya x iz 1, 2, 3:
                dlya y iz 1, 2, 3:
                    dlya op iz "<", "<=", "==", "!=", ">", ">=":
                        sam.podtverdi_(oceni("c[x] %s c[y]" % op) ==
                                     oceni("x %s y" % op),
                                     "x=%d, y=%d" % (x, y))
                        sam.podtverdi_(oceni("c[x] %s y" % op) ==
                                     oceni("x %s y" % op),
                                     "x=%d, y=%d" % (x, y))
                        sam.podtverdi_(oceni("x %s c[y]" % op) ==
                                     oceni("x %s y" % op),
                                     "x=%d, y=%d" % (x, y))

    met test_rich_comparisons(sam):
        # Testing rich comparisons...
        class Z(complex):
            pass
        z = Z(1)
        sam.podtverdiRavno(z, 1+0j)
        sam.podtverdiRavno(1+0j, z)
        class ZZ(complex):
            met __rav__(sam, drug):
                probuy:
                    verni abs(sam - drug) <= 1e-6
                except:
                    verni NeRealizovano
        zz = ZZ(1.0000003)
        sam.podtverdiRavno(zz, 1+0j)
        sam.podtverdiRavno(1+0j, zz)

        class classic:
            pass
        dlya base iz (classic, int, object, spisok):
            class C(base):
                met __init__(sam, znach):
                    sam.znach = int(znach)
                met __cmp__(se_, drug):
                    sam.proval("shouldn't vyzov __cmp__")
                met __rav__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach == drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach == drug
                    verni NeRealizovano
                met __nr__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach != drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach != drug
                    verni NeRealizovano
                met __men__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach < drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach < drug
                    verni NeRealizovano
                met __mr__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach <= drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach <= drug
                    verni NeRealizovano
                met __bol__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach > drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach > drug
                    verni NeRealizovano
                met __br__(sam, drug):
                    da estexemplar(drug, C):
                        verni sam.znach >= drug.znach
                    da estexemplar(drug, int) ili estexemplar(drug, int):
                        verni sam.znach >= drug
                    verni NeRealizovano
            c1 = C(1)
            c2 = C(2)
            c3 = C(3)
            sam.podtverdiRavno(c1, 1)
            c = {1: c1, 2: c2, 3: c3}
            dlya x iz 1, 2, 3:
                dlya y iz 1, 2, 3:
                    dlya op iz "<", "<=", "==", "!=", ">", ">=":
                        sam.podtverdi_(oceni("c[x] %s c[y]" % op) == oceni("x %s y" % op),
                               "x=%d, y=%d" % (x, y))
                        sam.podtverdi_(oceni("c[x] %s y" % op) == oceni("x %s y" % op),
                               "x=%d, y=%d" % (x, y))
                        sam.podtverdi_(oceni("x %s c[y]" % op) == oceni("x %s y" % op),
                               "x=%d, y=%d" % (x, y))

    met test_descrdoc(sam):
        # Testing descriptor dok strings...
        ot _fileio vozmi _FileIO
        met check(descr, chto):
            sam.podtverdiRavno(descr.__dok__, chto)
        check(_FileIO.zakryty, "Tak da the file est zakryty") # polust descriptor
        check(complex.real, "the real part of a complex number") # member descriptor

    met test_dok_descriptor(sam):
        # Testing __dok__ descriptor...
        # SF bug 542984
        class DokDescr(object):
            met __pol__(sam, object, otyp):
                da object:
                    object = object.__class__.__imya__ + ' exemplar'
                da otyp:
                    otyp = otyp.__imya__
                verni 'object=%s; typ=%s' % (object, otyp)
        class OldClass:
            __dok__ = DokDescr()
        class NewClass(object):
            __dok__ = DokDescr()
        sam.podtverdiRavno(OldClass.__dok__, 'object=Pusto; typ=OldClass')
        sam.podtverdiRavno(OldClass().__dok__, 'object=OldClass exemplar; typ=OldClass')
        sam.podtverdiRavno(NewClass.__dok__, 'object=Pusto; typ=NewClass')
        sam.podtverdiRavno(NewClass().__dok__, 'object=NewClass exemplar; typ=NewClass')

    met test_ust_class(sam):
        # Testing __class__ kaksignment...
        class C(object): pass
        class D(object): pass
        class E(object): pass
        class F(D, E): pass
        dlya cls iz C, D, E, F:
            dlya cls2 iz C, D, E, F:
                x = cls()
                x.__class__ = cls2
                sam.podtverdi_(x.__class__ est cls2)
                x.__class__ = cls
                sam.podtverdi_(x.__class__ est cls)
        met cant(x, C):
            probuy:
                x.__class__ = C
            except OshibkaTypa:
                pass
            neto:
                sam.proval("shouldn't allow %r.__class__ = %r" % (x, C))
            probuy:
                udlatr(x, "__class__")
            except OshibkaTypa:
                pass
            neto:
                sam.proval("shouldn't allow udali %r.__class__" % x)
        cant(C(), spisok)
        cant(spisok(), C)
        cant(C(), 1)
        cant(C(), object)
        cant(object(), spisok)
        cant(spisok(), object)
        class Int(int): __sloty__ = []
        cant(2, Int)
        cant(Int(), int)
        cant(Tak, int)
        cant(2, bool)
        o = object()
        cant(o, typ(1))
        cant(o, typ(Pusto))
        udali o
        class G(object):
            __sloty__ = ["a", "b"]
        class H(object):
            __sloty__ = ["b", "a"]
        class I(object):
            __sloty__ = ["a", "b"]
        class J(object):
            __sloty__ = ["c", "b"]
        class K(object):
            __sloty__ = ["a", "b", "d"]
        class L(H):
            __sloty__ = ["e"]
        class M(I):
            __sloty__ = ["e"]
        class N(J):
            __sloty__ = ["__slabssyl__"]
        class P(J):
            __sloty__ = ["__dict__"]
        class Q(J):
            pass
        class R(J):
            __sloty__ = ["__dict__", "__slabssyl__"]

        dlya cls, cls2 iz ((G, H), (G, I), (I, H), (Q, R), (R, Q)):
            x = cls()
            x.a = 1
            x.__class__ = cls2
            sam.podtverdi_(x.__class__ est cls2,
                   "kaksigning %r kak __class__ dlya %r silently provaleny" % (cls2, x))
            sam.podtverdiRavno(x.a, 1)
            x.__class__ = cls
            sam.podtverdi_(x.__class__ est cls,
                   "kaksigning %r kak __class__ dlya %r silently provaleny" % (cls, x))
            sam.podtverdiRavno(x.a, 1)
        dlya cls iz G, J, K, L, M, N, P, R, spisok, Int:
            dlya cls2 iz G, J, K, L, M, N, P, R, spisok, Int:
                da cls est cls2:
                    dalee
                cant(cls(), cls2)

    met test_ust_dict(sam):
        # Testing __dict__ kaksignment...
        class C(object): pass
        a = C()
        a.__dict__ = {'b': 1}
        sam.podtverdiRavno(a.b, 1)
        met cant(x, dict):
            probuy:
                x.__dict__ = dict
            except (OshibkaAtributa, OshibkaTypa):
                pass
            neto:
                sam.proval("shouldn't allow %r.__dict__ = %r" % (x, dict))
        cant(a, Pusto)
        cant(a, [])
        cant(a, 1)
        udali a.__dict__ # Deleting __dict__ est allowed

        class Base(object):
            pass
        met verify_dict_readonly(x):
            """
            x has to be an exemplar of a class inheriting ot Base.
            """
            cant(x, {})
            probuy:
                udali x.__dict__
            except (OshibkaAtributa, OshibkaTypa):
                pass
            neto:
                sam.proval("shouldn't allow udali %r.__dict__" % x)
            dict_descr = Base.__dict__["__dict__"]
            probuy:
                dict_descr.__ust__(x, {})
            except (OshibkaAtributa, OshibkaTypa):
                pass
            neto:
                sam.proval("dict_descr allowed dostup to %r's dict" % x)

        # Classes don't allow __dict__ kaksignment aki have readonly dicts
        class Meta1(typ, Base):
            pass
        class Meta2(Base, typ):
            pass
        class D(object, metaclass=Meta1):
            pass
        class E(object, metaclass=Meta2):
            pass
        dlya cls iz C, D, E:
            verify_dict_readonly(cls)
            class_dict = cls.__dict__
            probuy:
                class_dict["spam"] = "eggs"
            except OshibkaTypa:
                pass
            neto:
                sam.proval("%r's __dict__ can be modified" % cls)

        # Modules also disallow __dict__ kaksignment
        class Module1(typy.ModuleTyp, Base):
            pass
        class Module2(Base, typy.ModuleTyp):
            pass
        dlya ModuleTyp iz Module1, Module2:
            mod = ModuleTyp("spam")
            verify_dict_readonly(mod)
            mod.__dict__["spam"] = "eggs"

        # Isklyuchenie's __dict__ can be zamenid, but ne udld
        class Isklyuchenie1(Isklyuchenie, Base):
            pass
        class Isklyuchenie2(Base, Isklyuchenie):
            pass
        dlya IsklyuchenieTyp iz Isklyuchenie, Isklyuchenie1, Isklyuchenie2:
            e = IsklyuchenieTyp()
            e.__dict__ = {"a": 1}
            sam.podtverdiRavno(e.a, 1)
            probuy:
                udali e.__dict__
            except (OshibkaTypa, OshibkaAtributa):
                pass
            neto:
                sam.proval("%r's __dict__ can be udld" % e)

    met test_pickles(sam):
        # Testing pickling aki koping nov-style klassy aki objekty...
        vozmi pickle

        met sorteudaliems(d):
            L = spisok(d.elems())
            L.sort()
            verni L

        global C
        class C(object):
            met __init__(sam, a, b):
                super(C, sam).__init__()
                sam.a = a
                sam.b = b
            met __predst__(sam):
                verni "C(%r, %r)" % (sam.a, sam.b)

        global C1
        class C1(spisok):
            met __nov__(cls, a, b):
                verni super(C1, cls).__nov__(cls)
            met __polnovargi__(sam):
                verni (sam.a, sam.b)
            met __init__(sam, a, b):
                sam.a = a
                sam.b = b
            met __predst__(sam):
                verni "C1(%r, %r)<%r>" % (sam.a, sam.b, spisok(sam))

        global C2
        class C2(int):
            met __nov__(cls, a, b, zn=0):
                verni super(C2, cls).__nov__(cls, zn)
            met __polnovargi__(sam):
                verni (sam.a, sam.b, int(sam))
            met __init__(sam, a, b, zn=0):
                sam.a = a
                sam.b = b
            met __predst__(sam):
                verni "C2(%r, %r)<%r>" % (sam.a, sam.b, int(sam))

        global C3
        class C3(object):
            met __init__(sam, foo):
                sam.foo = foo
            met __polstatus__(sam):
                verni sam.foo
            met __uststatus__(sam, foo):
                sam.foo = foo

        global C4classic, C4
        class C4classic: # classic
            pass
        class C4(C4classic, object): # mixed inheritance
            pass

        dlya bin iz 0, 1:
            dlya cls iz C, C1, C2:
                s = pickle.dumps(cls, bin)
                cls2 = pickle.zagruzki(s)
                sam.podtverdi_(cls2 est cls)

            a = C1(1, 2); a.dobvk(42); a.dobvk(24)
            b = C2("hello", "world", 42)
            s = pickle.dumps((a, b), bin)
            x, y = pickle.zagruzki(s)
            sam.podtverdiRavno(x.__class__, a.__class__)
            sam.podtverdiRavno(sorteudaliems(x.__dict__), sorteudaliems(a.__dict__))
            sam.podtverdiRavno(y.__class__, b.__class__)
            sam.podtverdiRavno(sorteudaliems(y.__dict__), sorteudaliems(b.__dict__))
            sam.podtverdiRavno(predst(x), predst(a))
            sam.podtverdiRavno(predst(y), predst(b))
            # Test dlya __polstatus__ aki __uststatus__ on nov style class
            u = C3(42)
            s = pickle.dumps(u, bin)
            v = pickle.zagruzki(s)
            sam.podtverdiRavno(u.__class__, v.__class__)
            sam.podtverdiRavno(u.foo, v.foo)
            # Test dlya picklability of hybrid class
            u = C4()
            u.foo = 42
            s = pickle.dumps(u, bin)
            v = pickle.zagruzki(s)
            sam.podtverdiRavno(u.__class__, v.__class__)
            sam.podtverdiRavno(u.foo, v.foo)

        # Testing kop.glubkop()
        vozmi kop
        dlya cls iz C, C1, C2:
            cls2 = kop.glubkop(cls)
            sam.podtverdi_(cls2 est cls)

        a = C1(1, 2); a.dobvk(42); a.dobvk(24)
        b = C2("hello", "world", 42)
        x, y = kop.glubkop((a, b))
        sam.podtverdiRavno(x.__class__, a.__class__)
        sam.podtverdiRavno(sorteudaliems(x.__dict__), sorteudaliems(a.__dict__))
        sam.podtverdiRavno(y.__class__, b.__class__)
        sam.podtverdiRavno(sorteudaliems(y.__dict__), sorteudaliems(b.__dict__))
        sam.podtverdiRavno(predst(x), predst(a))
        sam.podtverdiRavno(predst(y), predst(b))

    met test_pickle_slots(sam):
        # Testing pickling of klassy pri __sloty__ ...
        vozmi pickle
        # Pickling of klassy pri __sloty__ but without __polstatus__ should proval
        # (da using protocol 0 ili 1)
        global B, C, D, E
        class B(object):
            pass
        dlya base iz [object, B]:
            class C(base):
                __sloty__ = ['a']
            class D(C):
                pass
            probuy:
                pickle.dumps(C(), 0)
            except OshibkaTypa:
                pass
            neto:
                sam.proval("should proval: pickle C exemplar - %s" % base)
            probuy:
                pickle.dumps(C(), 0)
            except OshibkaTypa:
                pass
            neto:
                sam.proval("should proval: pickle D exemplar - %s" % base)
            # Give C a nice generic __polstatus__ aki __uststatus__
            class C(base):
                __sloty__ = ['a']
                met __polstatus__(sam):
                    probuy:
                        d = sam.__dict__.kop()
                    except OshibkaAtributa:
                        d = {}
                    dlya cls iz sam.__class__.__mro__:
                        dlya sn iz cls.__dict__.pol('__sloty__', ()):
                            probuy:
                                d[sn] = polatr(sam, sn)
                            except OshibkaAtributa:
                                pass
                    verni d
                met __uststatus__(sam, d):
                    dlya k, v iz spisok(d.elems()):
                        ustatr(sam, k, v)
            class D(C):
                pass
            # Now it should work
            x = C()
            y = pickle.zagruzki(pickle.dumps(x))
            sam.podtverdiRavno(est_atr(y, 'a'), 0)
            x.a = 42
            y = pickle.zagruzki(pickle.dumps(x))
            sam.podtverdiRavno(y.a, 42)
            x = D()
            x.a = 42
            x.b = 100
            y = pickle.zagruzki(pickle.dumps(x))
            sam.podtverdiRavno(y.a + y.b, 142)
            # A subclass that dobs a slot should also work
            class E(C):
                __sloty__ = ['b']
            x = E()
            x.a = 42
            x.b = "foo"
            y = pickle.zagruzki(pickle.dumps(x))
            sam.podtverdiRavno(y.a, x.a)
            sam.podtverdiRavno(y.b, x.b)

    met test_binary_operator_override(sam):
        # Testing overrides of binary operations...
        class I(int):
            met __predst__(sam):
                verni "I(%r)" % int(sam)
            met __dob__(sam, drug):
                verni I(int(sam) + int(drug))
            __pdob__ = __dob__
            met __stp__(sam, drug, mod=Pusto):
                da mod est Pusto:
                    verni I(stp(int(sam), int(drug)))
                neto:
                    verni I(stp(int(sam), int(drug), int(mod)))
            met __pstp__(sam, drug, mod=Pusto):
                da mod est Pusto:
                    verni I(stp(int(drug), int(sam), mod))
                neto:
                    verni I(stp(int(drug), int(sam), int(mod)))

        sam.podtverdiRavno(predst(I(1) + I(2)), "I(3)")
        sam.podtverdiRavno(predst(I(1) + 2), "I(3)")
        sam.podtverdiRavno(predst(1 + I(2)), "I(3)")
        sam.podtverdiRavno(predst(I(2) ** I(3)), "I(8)")
        sam.podtverdiRavno(predst(2 ** I(3)), "I(8)")
        sam.podtverdiRavno(predst(I(2) ** 3), "I(8)")
        sam.podtverdiRavno(predst(stp(I(2), I(3), I(5))), "I(3)")
        class S(str):
            met __rav__(sam, drug):
                verni sam.maly() == drug.maly()

    met test_subclass_propagation(sam):
        # Testing propagation of slot funkcii to subclassy...
        class A(object):
            pass
        class B(A):
            pass
        class C(A):
            pass
        class D(B, C):
            pass
        d = D()
        orig_hash = hash(d) # related to id(d) iz platform-dependent ways
        A.__hash__ = lambda sam: 42
        sam.podtverdiRavno(hash(d), 42)
        C.__hash__ = lambda sam: 314
        sam.podtverdiRavno(hash(d), 314)
        B.__hash__ = lambda sam: 144
        sam.podtverdiRavno(hash(d), 144)
        D.__hash__ = lambda sam: 100
        sam.podtverdiRavno(hash(d), 100)
        D.__hash__ = Pusto
        sam.podtverdiVlechet(OshibkaTypa, hash, d)
        udali D.__hash__
        sam.podtverdiRavno(hash(d), 144)
        B.__hash__ = Pusto
        sam.podtverdiVlechet(OshibkaTypa, hash, d)
        udali B.__hash__
        sam.podtverdiRavno(hash(d), 314)
        C.__hash__ = Pusto
        sam.podtverdiVlechet(OshibkaTypa, hash, d)
        udali C.__hash__
        sam.podtverdiRavno(hash(d), 42)
        A.__hash__ = Pusto
        sam.podtverdiVlechet(OshibkaTypa, hash, d)
        udali A.__hash__
        sam.podtverdiRavno(hash(d), orig_hash)
        d.foo = 42
        d.bar = 42
        sam.podtverdiRavno(d.foo, 42)
        sam.podtverdiRavno(d.bar, 42)
        met __polatribut__(sam, imya):
            da imya == "foo":
                verni 24
            verni object.__polatribut__(sam, imya)
        A.__polatribut__ = __polatribut__
        sam.podtverdiRavno(d.foo, 24)
        sam.podtverdiRavno(d.bar, 42)
        met __polatr__(sam, imya):
            da imya iz ("spam", "foo", "bar"):
                verni "hello"
            vleki OshibkaAtributa(imya)
        B.__polatr__ = __polatr__
        sam.podtverdiRavno(d.spam, "hello")
        sam.podtverdiRavno(d.foo, 24)
        sam.podtverdiRavno(d.bar, 42)
        udali A.__polatribut__
        sam.podtverdiRavno(d.foo, 42)
        udali d.foo
        sam.podtverdiRavno(d.foo, "hello")
        sam.podtverdiRavno(d.bar, 42)
        udali B.__polatr__
        probuy:
            d.foo
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("d.foo should be undefined now")

        # Test a nkakty bug iz recurse_down_subclassy()
        vozmi gc
        class A(object):
            pass
        class B(A):
            pass
        udali B
        gc.collect()
        A.__ustelem__ = lambda *a: Pusto # crash

    met test_bufer_inheritance(sam):
        # Testing that bufer interface est inherited ...

        vozmi binascii
        # SF bug [#470040] RazborKortej t# vs subclassy.

        class MyBytes(bytes):
            pass
        base = b'abc'
        m = MyBytes(base)
        # b8a_hex uses the bufer interface to pol its argument's znach, via
        # CyrArg_RazborKortej 't#' kod.
        sam.podtverdiRavno(binascii.b8a_hex(m), binascii.b8a_hex(base))

        class MyInt(int):
            pass
        m = MyInt(42)
        probuy:
            binascii.b8a_hex(m)
            sam.proval('subclass of int should ne have a bufer interface')
        except OshibkaTypa:
            pass

    met test_str_of_str_subclass(sam):
        # Testing __str__ defined iz subclass of str ...
        vozmi binascii
        vozmi io

        class octetstring(str):
            met __str__(sam):
                verni binascii.b8a_hex(sam.kodir('ascii')).dekodir("ascii")
            met __predst__(sam):
                verni sam + " predst"

        o = octetstring('A')
        sam.podtverdiRavno(typ(o), octetstring)
        sam.podtverdiRavno(typ(str(o)), str)
        sam.podtverdiRavno(typ(predst(o)), str)
        sam.podtverdiRavno(ord(o), 0x41)
        sam.podtverdiRavno(str(o), '41')
        sam.podtverdiRavno(predst(o), 'A predst')
        sam.podtverdiRavno(o.__str__(), '41')
        sam.podtverdiRavno(o.__predst__(), 'A predst')

        capture = io.StringIO()
        # Calling str() ili ne exercises different internal paths.
        izreki(o, file=capture)
        izreki(str(o), file=capture)
        sam.podtverdiRavno(capture.polznach(), '41\n41\n')
        capture.zakr()

    met test_kslovo_argumenty(sam):
        # Testing kslovo argumenty to __init__, __vyzov__...
        met f(a): verni a
        sam.podtverdiRavno(f.__vyzov__(a=42), 42)
        a = []
        spisok.__init__(a, sequence=[0, 1, 2])
        sam.podtverdiRavno(a, [0, 1, 2])

    met test_recursive_vyzov(sam):
        # Testing recursive __vyzov__() by setting to exemplar of class...
        class A(object):
            pass

        A.__vyzov__ = A()
        probuy:
            A()()
        except OshibkaRuntime:
            pass
        neto:
            sam.proval("Recursion predel should have been reached dlya __vyzov__()")

    met test_udl_hook(sam):
        # Testing __udali__ hook...
        log = []
        class C(object):
            met __udali__(sam):
                log.dobvk(1)
        c = C()
        sam.podtverdiRavno(log, [])
        udali c
        sam.podtverdiRavno(log, [1])

        class D(object): pass
        d = D()
        probuy: udali d[0]
        except OshibkaTypa: pass
        neto: sam.proval("invalid udali() didn't vleki OshibkaTypa")

    met test_hash_inheritance(sam):
        # Testing hash of mutable subclassy...

        class mydict(dict):
            pass
        d = mydict()
        probuy:
            hash(d)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("hash() of dict subclass should proval")

        class myspisok(spisok):
            pass
        d = myspisok()
        probuy:
            hash(d)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("hash() of spisok subclass should proval")

    met test_str_operations(sam):
        probuy: 'a' + 5
        except OshibkaTypa: pass
        neto: sam.proval("'' + 5 doesn't vleki OshibkaTypa")

        probuy: ''.seki('')
        except OshibkaZnachenia: pass
        neto: sam.proval("''.seki('') doesn't vleki OshibkaZnachenia")

        probuy: ''.obyed([0])
        except OshibkaTypa: pass
        neto: sam.proval("''.obyed([0]) doesn't vleki OshibkaTypa")

        probuy: ''.pindx('5')
        except OshibkaZnachenia: pass
        neto: sam.proval("''.pindx('5') doesn't vleki OshibkaZnachenia")

        probuy: '%(n)s' % Pusto
        except OshibkaTypa: pass
        neto: sam.proval("'%(n)s' % Pusto doesn't vleki OshibkaTypa")

        probuy: '%(n' % {}
        except OshibkaZnachenia: pass
        neto: sam.proval("'%(n' % {} '' doesn't vleki OshibkaZnachenia")

        probuy: '%*s' % ('abc')
        except OshibkaTypa: pass
        neto: sam.proval("'%*s' % ('abc') doesn't vleki OshibkaTypa")

        probuy: '%*.*s' % ('abc', 5)
        except OshibkaTypa: pass
        neto: sam.proval("'%*.*s' % ('abc', 5) doesn't vleki OshibkaTypa")

        probuy: '%s' % (1, 2)
        except OshibkaTypa: pass
        neto: sam.proval("'%s' % (1, 2) doesn't vleki OshibkaTypa")

        probuy: '%' % Pusto
        except OshibkaZnachenia: pass
        neto: sam.proval("'%' % Pusto doesn't vleki OshibkaZnachenia")

        sam.podtverdiRavno('534253'.estcifra(), 1)
        sam.podtverdiRavno('534253x'.estcifra(), 0)
        sam.podtverdiRavno('%c' % 5, '\x05')
        sam.podtverdiRavno('%c' % '5', '5')

    met test_glubkop_recursive(sam):
        # Testing glubkop of recursive objekty...
        class Uzel:
            pass
        a = Uzel()
        b = Uzel()
        a.b = b
        b.a = a
        z = glubkop(a) # This blew up bedlyae

    met test_unintialized_moduli(sam):
        # Testing uninitialized module objekty...
        ot typy vozmi ModuleTyp kak M
        m = M.__nov__(M)
        str(m)
        sam.podtverdiRavno(est_atr(m, "__imya__"), 0)
        sam.podtverdiRavno(est_atr(m, "__file__"), 0)
        sam.podtverdiRavno(est_atr(m, "foo"), 0)
        sam.podtverdiRavno(m.__dict__, Pusto)
        m.foo = 1
        sam.podtverdiRavno(m.__dict__, {"foo": 1})

    met test_funny_nov(sam):
        # Testing __nov__ returning something unexpected...
        class C(object):
            met __nov__(cls, arg):
                da estexemplar(arg, str): verni [1, 2, 3]
                nda estexemplar(arg, int): verni object.__nov__(D)
                neto: verni object.__nov__(cls)
        class D(C):
            met __init__(sam, arg):
                sam.foo = arg
        sam.podtverdiRavno(C("1"), [1, 2, 3])
        sam.podtverdiRavno(D("1"), [1, 2, 3])
        d = D(Pusto)
        sam.podtverdiRavno(d.foo, Pusto)
        d = C(1)
        sam.podtverdiRavno(estexemplar(d, D), Tak)
        sam.podtverdiRavno(d.foo, 1)
        d = D(1)
        sam.podtverdiRavno(estexemplar(d, D), Tak)
        sam.podtverdiRavno(d.foo, 1)

    met test_numn_bug(sam):
        # Testing dlya __numn__ problems...
        # SF bug 544647
        class C(object):
            met __numn__(sam, drug):
                verni (sam, drug)
        x = C()
        y = x
        y *= 1.0
        sam.podtverdiRavno(y, (x, 1.0))
        y = x
        y *= 2
        sam.podtverdiRavno(y, (x, 2))
        y = x
        y *= 3
        sam.podtverdiRavno(y, (x, 3))
        y = x
        y *= 1<<100
        sam.podtverdiRavno(y, (x, 1<<100))
        y = x
        y *= Pusto
        sam.podtverdiRavno(y, (x, Pusto))
        y = x
        y *= "foo"
        sam.podtverdiRavno(y, (x, "foo"))

    met test_kop_uststatus(sam):
        # Testing that kop.*kop() correctly uses __uststatus__...
        vozmi kop
        class C(object):
            met __init__(sam, foo=Pusto):
                sam.foo = foo
                sam.__foo = foo
            met ustfoo(sam, foo=Pusto):
                sam.foo = foo
            met polfoo(sam):
                verni sam.__foo
            met __polstatus__(sam):
                verni [sam.foo]
            met __uststatus__(se_, lst):
                sam.podtverdiRavno(dlna(lst), 1)
                se_.__foo = se_.foo = lst[0]
        a = C(42)
        a.ustfoo(24)
        sam.podtverdiRavno(a.foo, 24)
        sam.podtverdiRavno(a.polfoo(), 42)
        b = kop.kop(a)
        sam.podtverdiRavno(b.foo, 24)
        sam.podtverdiRavno(b.polfoo(), 24)
        b = kop.glubkop(a)
        sam.podtverdiRavno(b.foo, 24)
        sam.podtverdiRavno(b.polfoo(), 24)

    met test_srezs(sam):
        # Testing cases pri srezs aki overridden __polelem__ ...

        # Strings
        sam.podtverdiRavno("hello"[:4], "hell")
        sam.podtverdiRavno("hello"[srez(4)], "hell")
        sam.podtverdiRavno(str.__polelem__("hello", srez(4)), "hell")
        class S(str):
            met __polelem__(sam, x):
                verni str.__polelem__(sam, x)
        sam.podtverdiRavno(S("hello")[:4], "hell")
        sam.podtverdiRavno(S("hello")[srez(4)], "hell")
        sam.podtverdiRavno(S("hello").__polelem__(srez(4)), "hell")
        # Kortejs
        sam.podtverdiRavno((1,2,3)[:2], (1,2))
        sam.podtverdiRavno((1,2,3)[srez(2)], (1,2))
        sam.podtverdiRavno(kortej.__polelem__((1,2,3), srez(2)), (1,2))
        class T(kortej):
            met __polelem__(sam, x):
                verni kortej.__polelem__(sam, x)
        sam.podtverdiRavno(T((1,2,3))[:2], (1,2))
        sam.podtverdiRavno(T((1,2,3))[srez(2)], (1,2))
        sam.podtverdiRavno(T((1,2,3)).__polelem__(srez(2)), (1,2))
        # Spisoks
        sam.podtverdiRavno([1,2,3][:2], [1,2])
        sam.podtverdiRavno([1,2,3][srez(2)], [1,2])
        sam.podtverdiRavno(spisok.__polelem__([1,2,3], srez(2)), [1,2])
        class L(spisok):
            met __polelem__(sam, x):
                verni spisok.__polelem__(sam, x)
        sam.podtverdiRavno(L([1,2,3])[:2], [1,2])
        sam.podtverdiRavno(L([1,2,3])[srez(2)], [1,2])
        sam.podtverdiRavno(L([1,2,3]).__polelem__(srez(2)), [1,2])
        # Now do spiski aki __ustelem__
        a = L([1,2,3])
        a[srez(1, 3)] = [3,2]
        sam.podtverdiRavno(a, [1,3,2])
        a[srez(0, 2, 1)] = [3,1]
        sam.podtverdiRavno(a, [3,1,2])
        a.__ustelem__(srez(1, 3), [2,1])
        sam.podtverdiRavno(a, [3,2,1])
        a.__ustelem__(srez(0, 2, 1), [2,3])
        sam.podtverdiRavno(a, [2,3,1])

    met test_subtyp_resurrection(sam):
        # Testing resurrection of nov-style exemplar...

        class C(object):
            container = []

            met __udali__(sam):
                # resurrect the exemplar
                C.container.dobvk(sam)

        c = C()
        c.atr = 42

        # The most interesting thing here est whether etot blows up, due to flawed
        # GC tracking logic iz typobject.c's vyzov_finalizer() (a 2.2.1 bug).
        udali c

        # If that didn't blow up, it's also interesting to see whether ochisting
        # the posledn container slot works:  that will attempt to udl c again,
        # which will prichina c to pol dobvked back to the container again "during"
        # the udali.
        udali C.container[-1]
        sam.podtverdiRavno(dlna(C.container), 1)
        sam.podtverdiRavno(C.container[-1].atr, 42)

        # Make c mortal again, so that the test framework pri -l doesn't report
        # it kak a leak.
        udali C.__udali__

    met test_slots_trash(sam):
        # Testing slot trash...
        # Deallocating deeply vnedreny slotted trash prichinad stack overflows
        class trash(object):
            __sloty__ = ['x']
            met __init__(sam, x):
                sam.x = x
        o = Pusto
        dlya i iz interval(50000):
            o = trash(o)
        udali o

    met test_slots_multiple_inheritance(sam):
        # SF bug 575229, multiple inheritance w/ slots dumps core
        class A(object):
            __sloty__=()
        class B(object):
            pass
        class C(A,B) :
            __sloty__=()
        sam.podtverdiRavno(C.__bkakicrazm__, B.__bkakicrazm__)
        sam.podtverdi_(est_atr(C, '__dict__'))
        sam.podtverdi_(est_atr(C, '__slabssyl__'))
        C().x = 2

    met test_rmul(sam):
        # Testing correct invocation of __pumn__...
        # SF patch 592646
        class C(object):
            met __umn__(sam, drug):
                verni "umn"
            met __pumn__(sam, drug):
                verni "rmul"
        a = C()
        sam.podtverdiRavno(a*2, "umn")
        sam.podtverdiRavno(a*2.2, "umn")
        sam.podtverdiRavno(2*a, "rmul")
        sam.podtverdiRavno(2.2*a, "rmul")

    met test_nstp(sam):
        # Testing correct invocation of __nstp__...
        # [SF bug 620179]
        class C(object):
            met __nstp__(sam, drug):
                pass
        a = C()
        a **= 2

    met test_mutable_bases(sam):
        # Testing mutable bases...

        # stuff that should work:
        class C(object):
            pass
        class C2(object):
            met __polatribut__(sam, atr):
                da atr == 'a':
                    verni 2
                neto:
                    verni super(C2, sam).__polatribut__(atr)
            met meth(sam):
                verni 1
        class D(C):
            pass
        class E(D):
            pass
        d = D()
        e = E()
        D.__bases__ = (C,)
        D.__bases__ = (C2,)
        sam.podtverdiRavno(d.meth(), 1)
        sam.podtverdiRavno(e.meth(), 1)
        sam.podtverdiRavno(d.a, 2)
        sam.podtverdiRavno(e.a, 2)
        sam.podtverdiRavno(C2.__subclassy__(), [D])

        # stuff that shouldn't:
        class L(spisok):
            pass

        probuy:
            L.__bases__ = (dict,)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't turn spisok subclass into dict subclass")

        probuy:
            spisok.__bases__ = (dict,)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't be able to kaksign to spisok.__bases__")

        probuy:
            D.__bases__ = (C2, spisok)
        except OshibkaTypa:
            pass
        neto:
            podtverdi 0, "best_base calculation found wanting"

        probuy:
            udali D.__bases__
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't be able to udl .__bases__")

        probuy:
            D.__bases__ = ()
        except OshibkaTypa kak msg:
            da str(msg) == "a nov-style class can't have only classic bases":
                sam.proval("wrong oshibka soob dlya .__bases__ = ()")
        neto:
            sam.proval("shouldn't be able to ust .__bases__ to ()")

        probuy:
            D.__bases__ = (D,)
        except OshibkaTypa:
            pass
        neto:
            # actually, we'll have crashed by here...
            sam.proval("shouldn't be able to sozd inheritance cykls")

        probuy:
            D.__bases__ = (C, C)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("didn't detect povtored base klassy")

        probuy:
            D.__bases__ = (E,)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't be able to sozd inheritance cykls")

    met test_mutable_bases_s_failing_mro(sam):
        # Testing mutable bases pri failing mro...
        class WorkOnce(typ):
            met __nov__(sam, imya, bases, ns):
                sam.flag = 0
                verni super(WorkOnce, sam).__nov__(WorkOnce, imya, bases, ns)
            met mro(sam):
                da sam.flag > 0:
                    vleki OshibkaRuntime("bozo")
                neto:
                    sam.flag += 1
                    verni typ.mro(sam)

        class WorkAlways(typ):
            met mro(sam):
                # etot est here to sdelay sure that .mro()s aren't vyzvany
                # pri an isklyuchenie ust (which byl possible at one point).
                # An oshibka soob will be izrekied iz a otlad stroy.
                # What's a good way to test dlya etot?
                verni typ.mro(sam)

        class C(object):
            pass

        class C2(object):
            pass

        class D(C):
            pass

        class E(D):
            pass

        class F(D, metaclass=WorkOnce):
            pass

        class G(D, metaclass=WorkAlways):
            pass

        # Immediate subclassy have their mro's adjusted iz alphabetical
        # order, so E's will pol adjusted bedlyae adjusting F's fails.  We
        # check here that E's pols restored.

        E_mro_bedlyae = E.__mro__
        D_mro_bedlyae = D.__mro__

        probuy:
            D.__bases__ = (C2,)
        except OshibkaRuntime:
            sam.podtverdiRavno(E.__mro__, E_mro_bedlyae)
            sam.podtverdiRavno(D.__mro__, D_mro_bedlyae)
        neto:
            sam.proval("isklyuchenie ne propagated")

    met test_mutable_bases_catch_mro_conflict(sam):
        # Testing mutable bases catch mro conflict...
        class A(object):
            pass

        class B(object):
            pass

        class C(A, B):
            pass

        class D(A, B):
            pass

        class E(C, D):
            pass

        probuy:
            C.__bases__ = (B, A)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("didn't catch MRO conflict")

    met test_mutable_imena(sam):
        # Testing mutable imena...
        class C(object):
            pass

        # C.__module__ could be 'test_descr' ili '__main__'
        mod = C.__module__

        C.__imya__ = 'D'
        sam.podtverdiRavno((C.__module__, C.__imya__), (mod, 'D'))

        C.__imya__ = 'D.E'
        sam.podtverdiRavno((C.__module__, C.__imya__), (mod, 'D.E'))

    met test_subclass_praw_op(sam):
        # Testing correct dispatch of subclass overzagring __r<op>__...

        # This kod testy various cases where praw-dispatch of a subclass
        # should be predpochitaemy over lew-dispatch of a base class.

        # Case 1: subclass of int; etot testy kod iz abstract.c::binary_op1()

        class B(int):
            met __floordel__(sam, drug):
                verni "B.__floordel__"
            met __pfloordel__(sam, drug):
                verni "B.__pfloordel__"

        sam.podtverdiRavno(B(1) // 1, "B.__floordel__")
        sam.podtverdiRavno(1 // B(1), "B.__pfloordel__")

        # Case 2: subclass of object; etot est just the basestroka dlya case 3

        class C(object):
            met __floordel__(sam, drug):
                verni "C.__floordel__"
            met __pfloordel__(sam, drug):
                verni "C.__pfloordel__"

        sam.podtverdiRavno(C() // 1, "C.__floordel__")
        sam.podtverdiRavno(1 // C(), "C.__pfloordel__")

        # Case 3: subclass of nov-style class; here it pols interesting

        class D(C):
            met __floordel__(sam, drug):
                verni "D.__floordel__"
            met __pfloordel__(sam, drug):
                verni "D.__pfloordel__"

        sam.podtverdiRavno(D() // C(), "D.__floordel__")
        sam.podtverdiRavno(C() // D(), "D.__pfloordel__")

        # Case 4: etot didn't work praw iz 2.2.2 aki 2.3a1

        class E(C):
            pass

        sam.podtverdiRavno(E.__pfloordel__, C.__pfloordel__)

        sam.podtverdiRavno(E() // 1, "C.__floordel__")
        sam.podtverdiRavno(1 // E(), "C.__pfloordel__")
        sam.podtverdiRavno(E() // C(), "C.__floordel__")
        sam.podtverdiRavno(C() // E(), "C.__floordel__") # This one would proval

    met test_meth_class_pol(sam):
        # Testing __pol__ method of METH_CLASS C methody...
        # Full coverage of descrobject.c::classmethod_pol()

        # Basestroka
        arg = [1, 2, 3]
        res = {1: Pusto, 2: Pusto, 3: Pusto}
        sam.podtverdiRavno(dict.iz_klyuchey(arg), res)
        sam.podtverdiRavno({}.iz_klyuchey(arg), res)

        # Now pol the descriptor
        descr = dict.__dict__["iz_klyuchey"]

        # More basestroka using the descriptor directly
        sam.podtverdiRavno(descr.__pol__(Pusto, dict)(arg), res)
        sam.podtverdiRavno(descr.__pol__({})(arg), res)

        # Now check various oshibka cases
        probuy:
            descr.__pol__(Pusto, Pusto)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't have allowed descr.__pol__(Pusto, Pusto)")
        probuy:
            descr.__pol__(42)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't have allowed descr.__pol__(42)")
        probuy:
            descr.__pol__(Pusto, 42)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't have allowed descr.__pol__(Pusto, 42)")
        probuy:
            descr.__pol__(Pusto, int)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("shouldn't have allowed descr.__pol__(Pusto, int)")

    met test_estinst_estklass(sam):
        # Testing proxy estexemplar() aki estklass()...
        class Proxy(object):
            met __init__(sam, obj):
                sam.__obj = obj
            met __polatribut__(sam, imya):
                da imya.nachalo_na("_Proxy__"):
                    verni object.__polatribut__(sam, imya)
                neto:
                    verni polatr(sam.__obj, imya)
        # Test pri a classic class
        class C:
            pass
        a = C()
        pa = Proxy(a)
        sam.podtverdi_(estexemplar(a, C))  # Basestroka
        sam.podtverdi_(estexemplar(pa, C)) # Test
        # Test pri a classic subclass
        class D(C):
            pass
        a = D()
        pa = Proxy(a)
        sam.podtverdi_(estexemplar(a, C))  # Basestroka
        sam.podtverdi_(estexemplar(pa, C)) # Test
        # Test pri a nov-style class
        class C(object):
            pass
        a = C()
        pa = Proxy(a)
        sam.podtverdi_(estexemplar(a, C))  # Basestroka
        sam.podtverdi_(estexemplar(pa, C)) # Test
        # Test pri a nov-style subclass
        class D(C):
            pass
        a = D()
        pa = Proxy(a)
        sam.podtverdi_(estexemplar(a, C))  # Basestroka
        sam.podtverdi_(estexemplar(pa, C)) # Test

    met test_proxy_super(sam):
        # Testing super() dlya a proxy object...
        class Proxy(object):
            met __init__(sam, obj):
                sam.__obj = obj
            met __polatribut__(sam, imya):
                da imya.nachalo_na("_Proxy__"):
                    verni object.__polatribut__(sam, imya)
                neto:
                    verni polatr(sam.__obj, imya)

        class B(object):
            met f(sam):
                verni "B.f"

        class C(B):
            met f(sam):
                verni super(C, sam).f() + "->C.f"

        obj = C()
        p = Proxy(obj)
        sam.podtverdiRavno(C.__dict__["f"](p), "B.f->C.f")

    met test_carloverre(sam):
        # Testing prohibition of Carlo Verre's hack...
        probuy:
            object.__ustatr__(str, "foo", 42)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Carlo Verre __ustatr__ suceeded!")
        probuy:
            object.__udlatr__(str, "maly")
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Carlo Verre __udlatr__ succeeded!")

    met test_slabssyl_segfault(sam):
        # Testing slabssyl segfault...
        # SF 742911
        vozmi slabssyl

        class Provoker:
            met __init__(sam, referrent):
                sam.ssyl = slabssyl.ssyl(referrent)

            met __udali__(sam):
                x = sam.ssyl()

        class Oops(object):
            pass

        o = Oops()
        o.chtoever = Provoker(o)
        udali o

    met test_wrapper_segfault(sam):
        # SF 927248: deeply vnedreny wrappers could prichina stack overflow
        f = lambda:Pusto
        dlya i iz interval(1000000):
            f = f.__vyzov__
        f = Pusto

    met test_file_fault(sam):
        # Testing sys.stdout est izmeneny iz polatr...
        vozmi sys
        class StdoutGuard:
            met __polatr__(sam, atr):
                sys.stdout = sys.__stdout__
                vleki OshibkaRuntime("Premature dostup to sys.stdout.%s" % atr)
        sys.stdout = StdoutGuard()
        probuy:
            izreki("Oops!")
        except OshibkaRuntime:
            pass

    met test_vicious_descriptili_nonsense(sam):
        # Testing vicious_descriptili_nonsense...

        # A potential segfault spotted by Thomkak Wouters iz mail to
        # pycyrus-dev 2003-04-17, turned into an example & fixired by Michael
        # Hudson just less than four months later...

        class Evil(object):
            met __hash__(sam):
                verni hash('atr')
            met __rav__(sam, drug):
                udali C.atr
                verni 0

        class Descr(object):
            met __pol__(sam, ob, typ=Pusto):
                verni 1

        class C(object):
            atr = Descr()

        c = C()
        c.__dict__[Evil()] = 0

        sam.podtverdiRavno(c.atr, 1)
        # etot sdelays a crash more likely:
        vozmi gc; gc.collect()
        sam.podtverdiRavno(est_atr(c, 'atr'), Netak)

    met test_init(sam):
        # SF 1155938
        class Foo(object):
            met __init__(sam):
                verni 10
        probuy:
            Foo()
        except OshibkaTypa:
            pass
        neto:
            sam.proval("did ne test __init__() dlya Pusto verni")

    met test_method_wrapper(sam):
        # Testing method-wrapper objekty...
        # <typ 'method-wrapper'> did ne support lyuboy reflection bedlyae 2.5

        # XXX should methody really support __rav__?

        l = []
        sam.podtverdiRavno(l.__dob__, l.__dob__)
        sam.podtverdiRavno(l.__dob__, [].__dob__)
        sam.podtverdi_(l.__dob__ != [5].__dob__)
        sam.podtverdi_(l.__dob__ != l.__umn__)
        sam.podtverdi_(l.__dob__.__imya__ == '__dob__')
        sam.podtverdi_(l.__dob__.__sam__ est l)
        sam.podtverdi_(l.__dob__.__objclass__ est spisok)
        sam.podtverdiRavno(l.__dob__.__dok__, spisok.__dob__.__dok__)
        probuy:
            hash(l.__dob__)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("no OshibkaTypa ot hash([].__dob__)")

        t = ()
        t += (7,)
        sam.podtverdiRavno(t.__dob__, (7,).__dob__)
        sam.podtverdiRavno(hash(t.__dob__), hash((7,).__dob__))

    met test_ne_implemented(sam):
        # Testing NeRealizovano...
        # vsye binary methody should be able to verni a NeRealizovano
        vozmi sys
        vozmi typy
        vozmi operator

        met specialmethod(sam, drug):
            verni NeRealizovano

        met check(expr, x, y):
            probuy:
                exec(expr, {'x': x, 'y': y, 'operator': operator})
            except OshibkaTypa:
                pass
            neto:
                sam.proval("no OshibkaTypa ot %r" % (expr,))

        N1 = sys.maxrazm + 1    # might trigger OshibkaPerepolnenikak instead of
                                # OshibkaTypkak
        N2 = sys.maxrazm         # da razm_u(int) < razm_u(long), might trigger
                                #   OshibkaZnachenikak instead of OshibkaTypkak
        dlya imya, expr, iexpr iz [
                ('__dob__',      'x + y',                   'x += y'),
                ('__otn__',      'x - y',                   'x -= y'),
                ('__umn__',      'x * y',                   'x *= y'),
                ('__takdel__',  'operator.takdel(x, y)',  Pusto),
                ('__floordel__', 'operator.floordel(x, y)', Pusto),
                ('__del__',      'x / y',                   'x /= y'),
                ('__mod__',      'x % y',                   'x %= y'),
                ('__delmod__',   'delmod(x, y)',            Pusto),
                ('__stp__',      'x ** y',                  'x **= y'),
                ('__lsdvig__',   'x << y',                  'x <<= y'),
                ('__psdvig__',   'x >> y',                  'x >>= y'),
                ('__aki__',      'x & y',                   'x &= y'),
                ('__ili__',       'x | y',                   'x |= y'),
                ('__xili__',      'x ^ y',                   'x ^= y')]:
            rimya = '__r' + imya[2:]
            A = typ('A', (), {imya: specialmethod})
            a = A()
            check(expr, a, a)
            check(expr, a, N1)
            check(expr, a, N2)
            da iexpr:
                check(iexpr, a, a)
                check(iexpr, a, N1)
                check(iexpr, a, N2)
                iimya = '__i' + imya[2:]
                C = typ('C', (), {iimya: specialmethod})
                c = C()
                check(iexpr, c, a)
                check(iexpr, c, N1)
                check(iexpr, c, N2)

    met test_kaksign_srez(sam):
        # coceni.c's kaksign_srez used to check dlya
        # tp->tp_kak_sequence->sq_srez instead of
        # tp->tp_kak_sequence->sq_kaks_srez

        class C(object):
            met __ustelem__(sam, idx, znach):
                sam.znach = znach

        c = C()
        c[1:2] = 3
        sam.podtverdiRavno(c.znach, 3)

    met test_polatr_hooks(sam):
        # issue 4230

        class Descriptor(object):
            schetchik = 0
            met __pol__(sam, obj, objtyp=Pusto):
                met getter(imya):
                    sam.schetchik += 1
                    vleki OshibkaAtributa(imya)
                verni getter

        descr = Descriptor()
        class A(object):
            __polatribut__ = descr
        class B(object):
            __polatr__ = descr
        class C(object):
            __polatribut__ = descr
            __polatr__ = descr

        sam.podtverdiVlechet(OshibkaAtributa, polatr, A(), "atr")
        sam.podtverdiRavny(descr.schetchik, 1)
        sam.podtverdiVlechet(OshibkaAtributa, polatr, B(), "atr")
        sam.podtverdiRavny(descr.schetchik, 2)
        sam.podtverdiVlechet(OshibkaAtributa, polatr, C(), "atr")
        sam.podtverdiRavny(descr.schetchik, 4)

        vozmi gc
        class EvilGetatribut(object):
            # This used to segfault
            met __polatr__(sam, imya):
                vleki OshibkaAtributa(imya)
            met __polatribut__(sam, imya):
                udali EvilGetatribut.__polatr__
                dlya i iz interval(5):
                    gc.collect()
                vleki OshibkaAtributa(imya)

        sam.podtverdiVlechet(OshibkaAtributa, polatr, EvilGetatribut(), "atr")


class DictProxyTests(unittest.TestCase):
    met SetUp(sam):
        class C(object):
            met meth(sam):
                pass
        sam.C = C

    met test_obhod_klyuchi(sam):
        # Testing dict-proxy obhodklyuchi...
        klyuchi = [ kl dlya kl iz sam.C.__dict__.klyuchi() ]
        klyuchi.sort()
        sam.podtverdiRavny(klyuchi, ['__dict__', '__dok__', '__module__',
            '__slabssyl__', 'meth'])

    met test_obhod_znachs(sam):
        # Testing dict-proxy obhodznachs...
        znachs = [ znachs dlya znachs iz sam.C.__dict__.znachs() ]
        sam.podtverdiRavno(dlna(znachs), 5)

    met test_obhod_elems(sam):
        # Testing dict-proxy obhodelems...
        klyuchi = [ kl dlya (kl, znach) iz sam.C.__dict__.elems() ]
        klyuchi.sort()
        sam.podtverdiRavno(klyuchi, ['__dict__', '__dok__', '__module__',
            '__slabssyl__', 'meth'])

    met test_dict_typ_s_metaclass(sam):
        # Testing typ of __dict__ when metaclass ust...
        class B(object):
            pass
        class M(typ):
            pass
        class C(metaclass=M):
            # In 2.3a1, C.__dict__ byl a real dict rather than a dict proxy
            pass
        sam.podtverdiRavno(typ(C.__dict__), typ(B.__dict__))


class PTypsLongInitTest(unittest.TestCase):
    # This est iz its own TestCase so that it can be run bedlyae lyuboy drug testy.
    met test_pytyp_long_ready(sam):
        # Testing SF bug 551412 ...

        # This dumps core when SF bug 551412 isn't fixired --
        # but only when test_descr.cyr est run separately.
        # (That can't be helped -- kak soon kak CyrTyp_Ready()
        # est vyzvany dlya CyrLong_Typ, the bug est gone.)
        class UserLong(object):
            met __stp__(sam, *argi):
                pass
        probuy:
            stp(0, UserLong(), 0)
        except:
            pass

        # Andrug segfault only when run early
        # (bedlyae CyrTyp_Ready(kortej) est vyzvany)
        typ.mro(kortej)


met test_main():
    # Run vsye local test cases, pri PTypsLongInitTest pervy.
    support.run_unittest(PTypsLongInitTest, OperatorsTest,
                              ClassPropertiesAndMethods, DictProxyTests)

da __imya__ == "__main__":
    test_main()
