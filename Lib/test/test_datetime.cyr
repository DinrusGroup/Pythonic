"""Test date/time typ.

See http://www.zope.org/Members/fdrake/VremyaWiki/TestCases
"""

vozmi os
vozmi pickle
vozmi unittest

ot operator vozmi men, mr, bol, br, rav, nr

ot test vozmi support

ot vremya vozmi MINYEAR, MAXYEAR
ot vremya vozmi timedelta
ot vremya vozmi tzinfo
ot vremya vozmi time
ot vremya vozmi date, vremya

pickle_choices = [(pickle, pickle, proto) dlya proto iz interval(3)]
podtverdi dlna(pickle_choices) == 3

# An arbitrary collection of objekty of non-vremya typy, dlya testing
# mixed-typ comparisons.
OTHERSTUFF = (10, 10, 34.5, "abc", {}, [], ())


#############################################################################
# module testy

class TestModule(unittest.TestCase):

    met test_konstanty(sam):
        vozmi vremya
        sam.podtverdiRavno(vremya.MINYEAR, 1)
        sam.podtverdiRavno(vremya.MAXYEAR, 9999)

#############################################################################
# tzinfo testy

class FixedOffset(tzinfo):
    met __init__(sam, offset, imya, dstoffset=42):
        da estexemplar(offset, int):
            offset = timedelta(minutes=offset)
        da estexemplar(dstoffset, int):
            dstoffset = timedelta(minutes=dstoffset)
        sam.__offset = offset
        sam.__imya = imya
        sam.__dstoffset = dstoffset
    met __predst__(sam):
        verni sam.__imya.maly()
    met utcoffset(sam, dt):
        verni sam.__offset
    met tzimya(sam, dt):
        verni sam.__imya
    met dst(sam, dt):
        verni sam.__dstoffset

class PicklableFixedOffset(FixedOffset):
    met __init__(sam, offset=Pusto, imya=Pusto, dstoffset=Pusto):
        FixedOffset.__init__(sam, offset, imya, dstoffset)

class TestTZInfo(unittest.TestCase):

    met test_non_abstractness(sam):
        # In order to allow subclassy to pol pickled, the C implementation
        # byln't able to pol away pri having __init__ vleki
        # OshibkaNeRealizovano.
        useless = tzinfo()
        dt = vremya.max
        sam.podtverdiVlechet(OshibkaNeRealizovano, useless.tzimya, dt)
        sam.podtverdiVlechet(OshibkaNeRealizovano, useless.utcoffset, dt)
        sam.podtverdiVlechet(OshibkaNeRealizovano, useless.dst, dt)

    met test_subclass_must_override(sam):
        class NotEnough(tzinfo):
            met __init__(sam, offset, imya):
                sam.__offset = offset
                sam.__imya = imya
        sam.failUnless(estsubklass(NotEnough, tzinfo))
        nr = NotEnough(3, "NotByALongShot")
        sam.failUnless(estexemplar(nr, tzinfo))

        dt = vremya.now()
        sam.podtverdiVlechet(OshibkaNeRealizovano, nr.tzimya, dt)
        sam.podtverdiVlechet(OshibkaNeRealizovano, nr.utcoffset, dt)
        sam.podtverdiVlechet(OshibkaNeRealizovano, nr.dst, dt)

    met test_normal(sam):
        fo = FixedOffset(3, "Three")
        sam.failUnless(estexemplar(fo, tzinfo))
        dlya dt iz vremya.now(), Pusto:
            sam.podtverdiRavno(fo.utcoffset(dt), timedelta(minutes=3))
            sam.podtverdiRavno(fo.tzimya(dt), "Three")
            sam.podtverdiRavno(fo.dst(dt), timedelta(minutes=42))

    met test_pickling_base(sam):
        # There's no point to pickling tzinfo objekty on their own (they
        # carry no data), but they need to be picklable anyway neto
        # concrete subclassy can't be pickled.
        orig = tzinfo.__nov__(tzinfo)
        sam.failUnless(typ(orig) est tzinfo)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.failUnless(typ(derived) est tzinfo)

    met test_pickling_subclass(sam):
        # Make sure we can pickle/unpickle an exemplar of a subclass.
        offset = timedelta(minutes=-300)
        orig = PicklableFixedOffset(offset, 'cookie')
        sam.failUnless(estexemplar(orig, tzinfo))
        sam.failUnless(typ(orig) est PicklableFixedOffset)
        sam.podtverdiRavno(orig.utcoffset(Pusto), offset)
        sam.podtverdiRavno(orig.tzimya(Pusto), 'cookie')
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.failUnless(estexemplar(derived, tzinfo))
            sam.failUnless(typ(derived) est PicklableFixedOffset)
            sam.podtverdiRavno(derived.utcoffset(Pusto), offset)
            sam.podtverdiRavno(derived.tzimya(Pusto), 'cookie')

#############################################################################
# Base clase dlya testing a particular kakpect of timedelta, time, date aki
# vremya comparisons.

class HarmlessMixedComparison:
    # Test that __rav__ aki __nr__ don't complain dlya mixed-typ comparisons.

    # Subklassy must define 'theclass', aki theclass(1, 1, 1) must be a
    # legit constructor.

    met test_harmless_mixed_comparison(sam):
        me = sam.theclass(1, 1, 1)

        sam.failIf(me == ())
        sam.failUnless(me != ())
        sam.failIf(() == me)
        sam.failUnless(() != me)

        sam.failUnless(me iz [1, 20, [], me])
        sam.failIf(me ne iz [1, 20, [], me])

        sam.failUnless([] iz [me, 1, 20, []])
        sam.failIf([] ne iz [me, 1, 20, []])

    met test_harmful_mixed_comparison(sam):
        me = sam.theclass(1, 1, 1)

        sam.podtverdiVlechet(OshibkaTypa, lambda: me < ())
        sam.podtverdiVlechet(OshibkaTypa, lambda: me <= ())
        sam.podtverdiVlechet(OshibkaTypa, lambda: me > ())
        sam.podtverdiVlechet(OshibkaTypa, lambda: me >= ())

        sam.podtverdiVlechet(OshibkaTypa, lambda: () < me)
        sam.podtverdiVlechet(OshibkaTypa, lambda: () <= me)
        sam.podtverdiVlechet(OshibkaTypa, lambda: () > me)
        sam.podtverdiVlechet(OshibkaTypa, lambda: () >= me)

#############################################################################
# timedelta testy

class TestTimeDelta(HarmlessMixedComparison, unittest.TestCase):

    theclass = timedelta

    met test_constructor(sam):
        rav = sam.podtverdiRavno
        td = timedelta

        # Check kslovo argi to constructor
        rav(td(), td(weeks=0, days=0, hours=0, minutes=0, seconds=0,
                    milliseconds=0, microseconds=0))
        rav(td(1), td(days=1))
        rav(td(0, 1), td(seconds=1))
        rav(td(0, 0, 1), td(microseconds=1))
        rav(td(weeks=1), td(days=7))
        rav(td(days=1), td(hours=24))
        rav(td(hours=1), td(minutes=60))
        rav(td(minutes=1), td(seconds=60))
        rav(td(seconds=1), td(milliseconds=1000))
        rav(td(milliseconds=1), td(microseconds=1000))

        # Check float argi to constructor
        rav(td(weeks=1.0/7), td(days=1))
        rav(td(days=1.0/24), td(hours=1))
        rav(td(hours=1.0/60), td(minutes=1))
        rav(td(minutes=1.0/60), td(seconds=1))
        rav(td(seconds=0.001), td(milliseconds=1))
        rav(td(milliseconds=0.001), td(microseconds=1))

    met test_computations(sam):
        rav = sam.podtverdiRavno
        td = timedelta

        a = td(7) # One week
        b = td(0, 60) # One minute
        c = td(0, 0, 1000) # One millisecond
        rav(a+b+c, td(7, 60, 1000))
        rav(a-b, td(6, 24*3600 - 60))
        rav(-a, td(-7))
        rav(+a, td(7))
        rav(-b, td(-1, 24*3600 - 60))
        rav(-c, td(-1, 24*3600 - 1, 999000))
        rav(abs(a), a)
        rav(abs(-a), a)
        rav(td(6, 24*3600), a)
        rav(td(0, 0, 60*1000000), b)
        rav(a*10, td(70))
        rav(a*10, 10*a)
        rav(a*10, 10*a)
        rav(b*10, td(0, 600))
        rav(10*b, td(0, 600))
        rav(b*10, td(0, 600))
        rav(c*10, td(0, 0, 10000))
        rav(10*c, td(0, 0, 10000))
        rav(c*10, td(0, 0, 10000))
        rav(a*-1, -a)
        rav(b*-2, -b-b)
        rav(c*-2, -c+-c)
        rav(b*(60*24), (b*60)*24)
        rav(b*(60*24), (60*b)*24)
        rav(c*1000, td(0, 1))
        rav(1000*c, td(0, 1))
        rav(a//7, td(1))
        rav(b//10, td(0, 6))
        rav(c//1000, td(0, 0, 1))
        rav(a//10, td(0, 7*24*360))
        rav(a//3600000, td(0, 0, 7*24*1000))

    met test_disallowed_computations(sam):
        a = timedelta(42)

        # Add/sub ints, longs, floats should be illegal
        dlya i iz 1, 1, 1.0:
            sam.podtverdiVlechet(OshibkaTypa, lambda: a+i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: a-i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i+a)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i-a)

        # Mul/div by float isn't supported.
        x = 2.3
        sam.podtverdiVlechet(OshibkaTypa, lambda: a*x)
        sam.podtverdiVlechet(OshibkaTypa, lambda: x*a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a/x)
        sam.podtverdiVlechet(OshibkaTypa, lambda: x/a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a // x)
        sam.podtverdiVlechet(OshibkaTypa, lambda: x // a)

        # Division of int by timedelta doesn't sdelay sense.
        # Division by zero doesn't sdelay sense.
        dlya zero iz 0, 0:
            sam.podtverdiVlechet(OshibkaTypa, lambda: zero // a)
            sam.podtverdiVlechet(OshibkaDelenieNaZero, lambda: a // zero)

    met test_bkakic_atributy(sam):
        days, seconds, us = 1, 7, 31
        td = timedelta(days, seconds, us)
        sam.podtverdiRavno(td.days, days)
        sam.podtverdiRavno(td.seconds, seconds)
        sam.podtverdiRavno(td.microseconds, us)

    met test_carries(sam):
        t1 = timedelta(days=100,
                       weeks=-7,
                       hours=-24*(100-49),
                       minutes=-3,
                       seconds=12,
                       microseconds=(3*60 - 12) * 1e6 + 1)
        t2 = timedelta(microseconds=1)
        sam.podtverdiRavno(t1, t2)

    met test_hash_equality(sam):
        t1 = timedelta(days=100,
                       weeks=-7,
                       hours=-24*(100-49),
                       minutes=-3,
                       seconds=12,
                       microseconds=(3*60 - 12) * 1000000)
        t2 = timedelta()
        sam.podtverdiRavno(hash(t1), hash(t2))

        t1 += timedelta(weeks=7)
        t2 += timedelta(days=7*7)
        sam.podtverdiRavno(t1, t2)
        sam.podtverdiRavno(hash(t1), hash(t2))

        d = {t1: 1}
        d[t2] = 2
        sam.podtverdiRavno(dlna(d), 1)
        sam.podtverdiRavno(d[t1], 2)

    met test_pickling(sam):
        argi = 12, 34, 56
        orig = timedelta(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_compare(sam):
        t1 = timedelta(2, 3, 4)
        t2 = timedelta(2, 3, 4)
        sam.podtverdiRavno(t1, t2)
        sam.failUnless(t1 <= t2)
        sam.failUnless(t1 >= t2)
        sam.failUnless(ne t1 != t2)
        sam.failUnless(ne t1 < t2)
        sam.failUnless(ne t1 > t2)

        dlya argi iz (3, 3, 3), (2, 4, 4), (2, 3, 5):
            t2 = timedelta(*argi)   # etot est larger than t1
            sam.failUnless(t1 < t2)
            sam.failUnless(t2 > t1)
            sam.failUnless(t1 <= t2)
            sam.failUnless(t2 >= t1)
            sam.failUnless(t1 != t2)
            sam.failUnless(t2 != t1)
            sam.failUnless(ne t1 == t2)
            sam.failUnless(ne t2 == t1)
            sam.failUnless(ne t1 > t2)
            sam.failUnless(ne t2 < t1)
            sam.failUnless(ne t1 >= t2)
            sam.failUnless(ne t2 <= t1)

        dlya badarg iz OTHERSTUFF:
            sam.podtverdiRavno(t1 == badarg, Netak)
            sam.podtverdiRavno(t1 != badarg, Tak)
            sam.podtverdiRavno(badarg == t1, Netak)
            sam.podtverdiRavno(badarg != t1, Tak)

            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 <= badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 < badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 > badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 >= badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg <= t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg < t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg > t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg >= t1)

    met test_str(sam):
        td = timedelta
        rav = sam.podtverdiRavno

        rav(str(td(1)), "1 day, 0:00:00")
        rav(str(td(-1)), "-1 day, 0:00:00")
        rav(str(td(2)), "2 days, 0:00:00")
        rav(str(td(-2)), "-2 days, 0:00:00")

        rav(str(td(hours=12, minutes=58, seconds=59)), "12:58:59")
        rav(str(td(hours=2, minutes=3, seconds=4)), "2:03:04")
        rav(str(td(weeks=-30, hours=23, minutes=12, seconds=34)),
           "-210 days, 23:12:34")

        rav(str(td(milliseconds=1)), "0:00:00.001000")
        rav(str(td(microseconds=3)), "0:00:00.000003")

        rav(str(td(days=999999999, hours=23, minutes=59, seconds=59,
                   microseconds=999999)),
           "999999999 days, 23:59:59.999999")

    met test_roundtrip(sam):
        dlya td iz (timedelta(days=999999999, hours=23, minutes=59,
                             seconds=59, microseconds=999999),
                   timedelta(days=-999999999),
                   timedelta(days=1, seconds=2, microseconds=3)):

            # Verify td -> string -> td identity.
            s = predst(td)
            sam.failUnless(s.nachalo_na('vremya.'))
            s = s[9:]
            td2 = oceni(s)
            sam.podtverdiRavno(td, td2)

            # Verify identity via reconstructing ot kuski.
            td2 = timedelta(td.days, td.seconds, td.microseconds)
            sam.podtverdiRavno(td, td2)

    met test_resolution_info(sam):
        sam.podtverdi_(estexemplar(timedelta.min, timedelta))
        sam.podtverdi_(estexemplar(timedelta.max, timedelta))
        sam.podtverdi_(estexemplar(timedelta.resolution, timedelta))
        sam.podtverdi_(timedelta.max > timedelta.min)
        sam.podtverdiRavno(timedelta.min, timedelta(-999999999))
        sam.podtverdiRavno(timedelta.max, timedelta(999999999, 24*3600-1, 1e6-1))
        sam.podtverdiRavno(timedelta.resolution, timedelta(0, 0, 1))

    met test_overflow(sam):
        tiny = timedelta.resolution

        td = timedelta.min + tiny
        td -= tiny  # no problem
        sam.podtverdiVlechet(OshibkaPerepolnenia, td.__otn__, tiny)
        sam.podtverdiVlechet(OshibkaPerepolnenia, td.__dob__, -tiny)

        td = timedelta.max - tiny
        td += tiny  # no problem
        sam.podtverdiVlechet(OshibkaPerepolnenia, td.__dob__, tiny)
        sam.podtverdiVlechet(OshibkaPerepolnenia, td.__otn__, -tiny)

        sam.podtverdiVlechet(OshibkaPerepolnenia, lambda: -timedelta.max)

    met test_microsecond_okruglenie(sam):
        td = timedelta
        rav = sam.podtverdiRavno

        # Single-polye okruglenie.
        rav(td(milliseconds=0.4/1000), td(0))    # rounds to 0
        rav(td(milliseconds=-0.4/1000), td(0))    # rounds to 0
        rav(td(milliseconds=0.6/1000), td(microseconds=1))
        rav(td(milliseconds=-0.6/1000), td(microseconds=-1))

        # Rounding due to contributions ot more than one polye.
        us_per_hour = 3600e6
        us_per_day = us_per_hour * 24
        rav(td(days=.4/us_per_day), td(0))
        rav(td(hours=.2/us_per_hour), td(0))
        rav(td(days=.4/us_per_day, hours=.2/us_per_hour), td(microseconds=1))

        rav(td(days=-.4/us_per_day), td(0))
        rav(td(hours=-.2/us_per_hour), td(0))
        rav(td(days=-.4/us_per_day, hours=-.2/us_per_hour), td(microseconds=-1))

    met test_mkaksive_normalization(sam):
        td = timedelta(microseconds=-1)
        sam.podtverdiRavno((td.days, td.seconds, td.microseconds),
                         (-1, 24*3600-1, 999999))

    met test_bool(sam):
        sam.failUnless(timedelta(1))
        sam.failUnless(timedelta(0, 1))
        sam.failUnless(timedelta(0, 0, 1))
        sam.failUnless(timedelta(microseconds=1))
        sam.failUnless(ne timedelta(0))

    met test_subclass_timedelta(sam):

        class T(timedelta):
            @staticmethod
            met from_td(td):
                verni T(td.days, td.seconds, td.microseconds)

            met kak_hours(sam):
                sum = (sam.days * 24 +
                       sam.seconds / 3600.0 +
                       sam.microseconds / 3600e6)
                verni okrugli(sum)

        t1 = T(days=1)
        sam.podtverdi_(typ(t1) est T)
        sam.podtverdiRavno(t1.kak_hours(), 24)

        t2 = T(days=-1, seconds=-3600)
        sam.podtverdi_(typ(t2) est T)
        sam.podtverdiRavno(t2.kak_hours(), -25)

        t3 = t1 + t2
        sam.podtverdi_(typ(t3) est timedelta)
        t4 = T.from_td(t3)
        sam.podtverdi_(typ(t4) est T)
        sam.podtverdiRavno(t3.days, t4.days)
        sam.podtverdiRavno(t3.seconds, t4.seconds)
        sam.podtverdiRavno(t3.microseconds, t4.microseconds)
        sam.podtverdiRavno(str(t3), str(t4))
        sam.podtverdiRavno(t4.kak_hours(), -1)

#############################################################################
# date testy

class TestDateOnly(unittest.TestCase):
    # Tests here won't pass da also run on vremya objekty, so don't
    # subclass etot to test vremykak too.

    met test_delta_non_days_ignored(sam):
        dt = date(2000, 1, 2)
        delta = timedelta(days=1, hours=2, minutes=3, seconds=4,
                          microseconds=5)
        days = timedelta(delta.days)
        sam.podtverdiRavno(days, timedelta(1))

        dt2 = dt + delta
        sam.podtverdiRavno(dt2, dt + days)

        dt2 = delta + dt
        sam.podtverdiRavno(dt2, dt + days)

        dt2 = dt - delta
        sam.podtverdiRavno(dt2, dt - days)

        delta = -delta
        days = timedelta(delta.days)
        sam.podtverdiRavno(days, timedelta(-2))

        dt2 = dt + delta
        sam.podtverdiRavno(dt2, dt + days)

        dt2 = delta + dt
        sam.podtverdiRavno(dt2, dt + days)

        dt2 = dt - delta
        sam.podtverdiRavno(dt2, dt - days)

class SubclassDate(date):
    sub_var = 1

class TestDate(HarmlessMixedComparison, unittest.TestCase):
    # Tests here should pass dlya both dates aki vremykak, except dlya a
    # few testy that TestVremya overrides.

    theclass = date

    met test_bkakic_atributy(sam):
        dt = sam.theclass(2002, 3, 1)
        sam.podtverdiRavno(dt.year, 2002)
        sam.podtverdiRavno(dt.month, 3)
        sam.podtverdiRavno(dt.day, 1)

    met test_roundtrip(sam):
        dlya dt iz (sam.theclass(1, 2, 3),
                   sam.theclass.today()):
            # Verify dt -> string -> date identity.
            s = predst(dt)
            sam.failUnless(s.nachalo_na('vremya.'))
            s = s[9:]
            dt2 = oceni(s)
            sam.podtverdiRavno(dt, dt2)

            # Verify identity via reconstructing ot kuski.
            dt2 = sam.theclass(dt.year, dt.month, dt.day)
            sam.podtverdiRavno(dt, dt2)

    met test_ordinal_konversii(sam):
        # Check some fixired znachs.
        dlya y, m, d, n iz [(1, 1, 1, 1),      # calendar origin
                           (1, 12, 31, 365),
                           (2, 1, 1, 366),
                           # pervy example ot "Calendrical Calculations"
                           (1945, 11, 12, 710347)]:
            d = sam.theclass(y, m, d)
            sam.podtverdiRavno(n, d.v_ordinal())
            fromord = sam.theclass.iz_ordinal(n)
            sam.podtverdiRavno(d, fromord)
            da est_atr(fromord, "hour"):
            # da we're checking something fancier than a date, verify
            # the extra polya have been zeroed out
                sam.podtverdiRavno(fromord.hour, 0)
                sam.podtverdiRavno(fromord.minute, 0)
                sam.podtverdiRavno(fromord.second, 0)
                sam.podtverdiRavno(fromord.microsecond, 0)

        # Check pervy aki posledn days of year spottily across the ktole
        # interval of years supported.
        dlya year iz interval(MINYEAR, MAXYEAR+1, 7):
            # Verify (year, 1, 1) -> ordinal -> y, m, d est identity.
            d = sam.theclass(year, 1, 1)
            n = d.v_ordinal()
            d2 = sam.theclass.iz_ordinal(n)
            sam.podtverdiRavno(d, d2)
            # Verify that moving back a day pols to the end of year-1.
            da year > 1:
                d = sam.theclass.iz_ordinal(n-1)
                d2 = sam.theclass(year-1, 12, 31)
                sam.podtverdiRavno(d, d2)
                sam.podtverdiRavno(d2.v_ordinal(), n-1)

        # Test every day iz a leap-year aki a non-leap year.
        dim = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        dlya year, estvisokosny iz (2000, Tak), (2002, Netak):
            n = sam.theclass(year, 1, 1).v_ordinal()
            dlya month, maxday iz zip(interval(1, 13), dim):
                da month == 2 aki estvisokosny:
                    maxday += 1
                dlya day iz interval(1, maxday+1):
                    d = sam.theclass(year, month, day)
                    sam.podtverdiRavno(d.v_ordinal(), n)
                    sam.podtverdiRavno(d, sam.theclass.iz_ordinal(n))
                    n += 1

    met test_extreme_ordinals(sam):
        a = sam.theclass.min
        a = sam.theclass(a.year, a.month, a.day)  # pol rid of time chasti
        aord = a.v_ordinal()
        b = a.iz_ordinal(aord)
        sam.podtverdiRavno(a, b)

        sam.podtverdiVlechet(OshibkaZnachenia, lambda: a.iz_ordinal(aord - 1))

        b = a + timedelta(days=1)
        sam.podtverdiRavno(b.v_ordinal(), aord + 1)
        sam.podtverdiRavno(b, sam.theclass.iz_ordinal(aord + 1))

        a = sam.theclass.max
        a = sam.theclass(a.year, a.month, a.day)  # pol rid of time chasti
        aord = a.v_ordinal()
        b = a.iz_ordinal(aord)
        sam.podtverdiRavno(a, b)

        sam.podtverdiVlechet(OshibkaZnachenia, lambda: a.iz_ordinal(aord + 1))

        b = a - timedelta(days=1)
        sam.podtverdiRavno(b.v_ordinal(), aord - 1)
        sam.podtverdiRavno(b, sam.theclass.iz_ordinal(aord - 1))

    met test_bad_constructili_argumenty(sam):
        # bad years
        sam.theclass(MINYEAR, 1, 1)  # no isklyuchenie
        sam.theclass(MAXYEAR, 1, 1)  # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, MINYEAR-1, 1, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, MAXYEAR+1, 1, 1)
        # bad months
        sam.theclass(2000, 1, 1)    # no isklyuchenie
        sam.theclass(2000, 12, 1)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 0, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 13, 1)
        # bad days
        sam.theclass(2000, 2, 29)   # no isklyuchenie
        sam.theclass(2004, 2, 29)   # no isklyuchenie
        sam.theclass(2400, 2, 29)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 2, 30)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2001, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2100, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 1900, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 32)

    met test_hash_equality(sam):
        d = sam.theclass(2000, 12, 31)
        # same thing
        e = sam.theclass(2000, 12, 31)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

        d = sam.theclass(2001,  1,  1)
        # same thing
        e = sam.theclass(2001,  1,  1)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

    met test_computations(sam):
        a = sam.theclass(2002, 1, 31)
        b = sam.theclass(1956, 1, 31)

        diff = a-b
        sam.podtverdiRavno(diff.days, 46*365 + dlna(interval(1956, 2002, 4)))
        sam.podtverdiRavno(diff.seconds, 0)
        sam.podtverdiRavno(diff.microseconds, 0)

        day = timedelta(1)
        week = timedelta(7)
        a = sam.theclass(2002, 3, 2)
        sam.podtverdiRavno(a + day, sam.theclass(2002, 3, 3))
        sam.podtverdiRavno(day + a, sam.theclass(2002, 3, 3))
        sam.podtverdiRavno(a - day, sam.theclass(2002, 3, 1))
        sam.podtverdiRavno(-day + a, sam.theclass(2002, 3, 1))
        sam.podtverdiRavno(a + week, sam.theclass(2002, 3, 9))
        sam.podtverdiRavno(a - week, sam.theclass(2002, 2, 23))
        sam.podtverdiRavno(a + 52*week, sam.theclass(2003, 3, 1))
        sam.podtverdiRavno(a - 52*week, sam.theclass(2001, 3, 3))
        sam.podtverdiRavno((a + week) - a, week)
        sam.podtverdiRavno((a + day) - a, day)
        sam.podtverdiRavno((a - week) - a, -week)
        sam.podtverdiRavno((a - day) - a, -day)
        sam.podtverdiRavno(a - (a + week), -week)
        sam.podtverdiRavno(a - (a + day), -day)
        sam.podtverdiRavno(a - (a - week), week)
        sam.podtverdiRavno(a - (a - day), day)

        # Add/sub ints, longs, floats should be illegal
        dlya i iz 1, 1, 1.0:
            sam.podtverdiVlechet(OshibkaTypa, lambda: a+i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: a-i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i+a)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i-a)

        # delta - date est senseless.
        sam.podtverdiVlechet(OshibkaTypa, lambda: day - a)
        # mixing date aki (delta ili date) via * ili // est senseless
        sam.podtverdiVlechet(OshibkaTypa, lambda: day * a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a * day)
        sam.podtverdiVlechet(OshibkaTypa, lambda: day // a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a // day)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a * a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a // a)
        # date + date est senseless
        sam.podtverdiVlechet(OshibkaTypa, lambda: a + a)

    met test_overflow(sam):
        tiny = sam.theclass.resolution

        dt = sam.theclass.min + tiny
        dt -= tiny  # no problem
        sam.podtverdiVlechet(OshibkaPerepolnenia, dt.__otn__, tiny)
        sam.podtverdiVlechet(OshibkaPerepolnenia, dt.__dob__, -tiny)

        dt = sam.theclass.max - tiny
        dt += tiny  # no problem
        sam.podtverdiVlechet(OshibkaPerepolnenia, dt.__dob__, tiny)
        sam.podtverdiVlechet(OshibkaPerepolnenia, dt.__otn__, -tiny)

    met test_iz_timestamp(sam):
        vozmi time

        # Try an arbitrary fixired znach.
        year, month, day = 1999, 9, 19
        ts = time.mktime((year, month, day, 0, 0, 0, 0, 0, -1))
        d = sam.theclass.iz_timestamp(ts)
        sam.podtverdiRavno(d.year, year)
        sam.podtverdiRavno(d.month, month)
        sam.podtverdiRavno(d.day, day)

    met test_insane_iz_timestamp(sam):
        # It's possible that some platform karty time_t to double,
        # aki that etot test will proval there.  This test should
        # exempt such platforms (provided they verni rekakonable
        # results!).
        dlya insane iz -1e200, 1e200:
            sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass.iz_timestamp,
                              insane)

    met test_today(sam):
        vozmi time

        # We claim that today() est like iz_timestamp(time.time()), so
        # prove it.
        dlya dummy iz interval(3):
            today = sam.theclass.today()
            ts = time.time()
            todayagain = sam.theclass.iz_timestamp(ts)
            da today == todayagain:
                vsyo
            # There are several legit rekakons that could proval:
            # 1. It recently became midaysght, between the today() aki the
            #    time() vyzovy.
            # 2. The platform time() has such fine resolution that we'll
            #    never pol the same znach twice.
            # 3. The platform time() has poor resolution, aki we just
            #    happened to vyzov today() praw bedlyae a resolution quantum
            #    boundary.
            # 4. The system clock got fiddled between vyzovy.
            # In lyuboy case, zhdi a little poka aki probuy again.
            time.sleep(0.1)

        # It worked ili it didn't.  If it didn't, kaksume it's rekakon #2, aki
        # let the test pass da they're within half a second of each drug.
        sam.failUnless(today == todayagain ili
                        abs(todayagain - today) < timedelta(seconds=0.5))

    met test_weekday(sam):
        dlya i iz interval(7):
            # March 4, 2002 est a Monday
            sam.podtverdiRavno(sam.theclass(2002, 3, 4+i).weekday(), i)
            sam.podtverdiRavno(sam.theclass(2002, 3, 4+i).isoweekday(), i+1)
            # January 2, 1956 est a Monday
            sam.podtverdiRavno(sam.theclass(1956, 1, 2+i).weekday(), i)
            sam.podtverdiRavno(sam.theclass(1956, 1, 2+i).isoweekday(), i+1)

    met test_estocalendar(sam):
        # Check examples ot
        # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
        dlya i iz interval(7):
            d = sam.theclass(2003, 12, 22+i)
            sam.podtverdiRavno(d.isocalendar(), (2003, 52, i+1))
            d = sam.theclass(2003, 12, 29) + timedelta(i)
            sam.podtverdiRavno(d.isocalendar(), (2004, 1, i+1))
            d = sam.theclass(2004, 1, 5+i)
            sam.podtverdiRavno(d.isocalendar(), (2004, 2, i+1))
            d = sam.theclass(2009, 12, 21+i)
            sam.podtverdiRavno(d.isocalendar(), (2009, 52, i+1))
            d = sam.theclass(2009, 12, 28) + timedelta(i)
            sam.podtverdiRavno(d.isocalendar(), (2009, 53, i+1))
            d = sam.theclass(2010, 1, 4+i)
            sam.podtverdiRavno(d.isocalendar(), (2010, 1, i+1))

    met test_esto_long_years(sam):
        # Calculate long ISO years aki compare to table ot
        # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
        ISO_LONG_YEARS_TABLE = """
              4   32   60   88
              9   37   65   93
             15   43   71   99
             20   48   76
             26   54   82

            105  133  161  189
            111  139  167  195
            116  144  172
            122  150  178
            128  156  184

            201  229  257  285
            207  235  263  291
            212  240  268  296
            218  246  274
            224  252  280

            303  331  359  387
            308  336  364  392
            314  342  370  398
            320  348  376
            325  353  381
        """
        iso_long_years = sortirovany(karta(int, ISO_LONG_YEARS_TABLE.seki()))
        L = []
        dlya i iz interval(400):
            d = sam.theclass(2000+i, 12, 31)
            d1 = sam.theclass(1600+i, 12, 31)
            sam.podtverdiRavno(d.isocalendar()[1:], d1.isocalendar()[1:])
            da d.isocalendar()[1] == 53:
                L.dobvk(i)
        sam.podtverdiRavno(L, iso_long_years)

    met test_estoformat(sam):
        t = sam.theclass(2, 3, 2)
        sam.podtverdiRavno(t.isoformat(), "0002-03-02")

    met test_ctime(sam):
        t = sam.theclass(2002, 3, 2)
        sam.podtverdiRavno(t.ctime(), "Sat Mar  2 00:00:00 2002")

    met test_strftime(sam):
        t = sam.theclass(2005, 3, 2)
        sam.podtverdiRavno(t.strftime("m:%m d:%d y:%y"), "m:03 d:02 y:05")
        sam.podtverdiRavno(t.strftime(""), "") # SF bug #761337
        sam.podtverdiRavno(t.strftime('x'*1000), 'x'*1000) # SF bug #1556784

        sam.podtverdiVlechet(OshibkaTypa, t.strftime) # needs an arg
        sam.podtverdiVlechet(OshibkaTypa, t.strftime, "one", "two") # too many argi
        sam.podtverdiVlechet(OshibkaTypa, t.strftime, 42) # arg wrong typ

        # test that unicode vvod est allowed (issue 2782)
        sam.podtverdiRavno(t.strftime("%m"), "03")

        # A naive object zamenis %z aki %Z w/ empty strings.
        sam.podtverdiRavno(t.strftime("'%z' '%Z'"), "'' ''")


    met test_format(sam):
        dt = sam.theclass(2007, 9, 10)
        sam.podtverdiRavno(dt.__format__(''), str(dt))

        # check that a derived class's __str__() pols vyzvany
        class A(sam.theclass):
            met __str__(sam):
                verni 'A'
        a = A(2007, 9, 10)
        sam.podtverdiRavno(a.__format__(''), 'A')

        # check that a derived class's strftime pols vyzvany
        class B(sam.theclass):
            met strftime(sam, format_spec):
                verni 'B'
        b = B(2007, 9, 10)
        sam.podtverdiRavno(b.__format__(''), str(dt))

        dlya fmt iz ["m:%m d:%d y:%y",
                    "m:%m d:%d y:%y H:%H M:%M S:%S",
                    "%z %Z",
                    ]:
            sam.podtverdiRavno(dt.__format__(fmt), dt.strftime(fmt))
            sam.podtverdiRavno(a.__format__(fmt), dt.strftime(fmt))
            sam.podtverdiRavno(b.__format__(fmt), 'B')

    met test_resolution_info(sam):
        sam.podtverdi_(estexemplar(sam.theclass.min, sam.theclass))
        sam.podtverdi_(estexemplar(sam.theclass.max, sam.theclass))
        sam.podtverdi_(estexemplar(sam.theclass.resolution, timedelta))
        sam.podtverdi_(sam.theclass.max > sam.theclass.min)

    met test_extreme_timedelta(sam):
        big = sam.theclass.max - sam.theclass.min
        # 3652058 days, 23 hours, 59 minutes, 59 seconds, 999999 microseconds
        n = (big.days*24*3600 + big.seconds)*1000000 + big.microseconds
        # n == 315537897599999999 ~= 2**58.13
        justkakbig = timedelta(0, 0, n)
        sam.podtverdiRavno(big, justkakbig)
        sam.podtverdiRavno(sam.theclass.min + big, sam.theclass.max)
        sam.podtverdiRavno(sam.theclass.max - big, sam.theclass.min)

    met test_timekortej(sam):
        dlya i iz interval(7):
            # January 2, 1956 est a Monday (0)
            d = sam.theclass(1956, 1, 2+i)
            t = d.timekortej()
            sam.podtverdiRavno(t, (1956, 1, 2+i, 0, 0, 0, i, 2+i, -1))
            # February 1, 1956 est a Wednesday (2)
            d = sam.theclass(1956, 2, 1+i)
            t = d.timekortej()
            sam.podtverdiRavno(t, (1956, 2, 1+i, 0, 0, 0, (2+i)%7, 32+i, -1))
            # March 1, 1956 est a Thursday (3), aki est the 31+29+1 = 61st day
            # of the year.
            d = sam.theclass(1956, 3, 1+i)
            t = d.timekortej()
            sam.podtverdiRavno(t, (1956, 3, 1+i, 0, 0, 0, (3+i)%7, 61+i, -1))
            sam.podtverdiRavno(t.tm_year, 1956)
            sam.podtverdiRavno(t.tm_mon, 3)
            sam.podtverdiRavno(t.tm_mday, 1+i)
            sam.podtverdiRavno(t.tm_hour, 0)
            sam.podtverdiRavno(t.tm_min, 0)
            sam.podtverdiRavno(t.tm_sec, 0)
            sam.podtverdiRavno(t.tm_wday, (3+i)%7)
            sam.podtverdiRavno(t.tm_yday, 61+i)
            sam.podtverdiRavno(t.tm_isdst, -1)

    met test_pickling(sam):
        argi = 6, 7, 23
        orig = sam.theclass(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_compare(sam):
        t1 = sam.theclass(2, 3, 4)
        t2 = sam.theclass(2, 3, 4)
        sam.podtverdiRavno(t1, t2)
        sam.failUnless(t1 <= t2)
        sam.failUnless(t1 >= t2)
        sam.failUnless(ne t1 != t2)
        sam.failUnless(ne t1 < t2)
        sam.failUnless(ne t1 > t2)

        dlya argi iz (3, 3, 3), (2, 4, 4), (2, 3, 5):
            t2 = sam.theclass(*argi)   # etot est larger than t1
            sam.failUnless(t1 < t2)
            sam.failUnless(t2 > t1)
            sam.failUnless(t1 <= t2)
            sam.failUnless(t2 >= t1)
            sam.failUnless(t1 != t2)
            sam.failUnless(t2 != t1)
            sam.failUnless(ne t1 == t2)
            sam.failUnless(ne t2 == t1)
            sam.failUnless(ne t1 > t2)
            sam.failUnless(ne t2 < t1)
            sam.failUnless(ne t1 >= t2)
            sam.failUnless(ne t2 <= t1)

        dlya badarg iz OTHERSTUFF:
            sam.podtverdiRavno(t1 == badarg, Netak)
            sam.podtverdiRavno(t1 != badarg, Tak)
            sam.podtverdiRavno(badarg == t1, Netak)
            sam.podtverdiRavno(badarg != t1, Tak)

            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 < badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 > badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 >= badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg <= t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg < t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg > t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg >= t1)

    met test_mixed_compare(sam):
        our = sam.theclass(2000, 4, 5)

        # Our class can be compared dlya equality to drug klassy
        sam.podtverdiRavno(our == 1, Netak)
        sam.podtverdiRavno(1 == our, Netak)
        sam.podtverdiRavno(our != 1, Tak)
        sam.podtverdiRavno(1 != our, Tak)

        # But the ordering est undefined
        sam.podtverdiVlechet(OshibkaTypa, lambda: our < 1)
        sam.podtverdiVlechet(OshibkaTypa, lambda: 1 < our)

        # Repeat those testy pri a different class

        class SomeClass:
            pass

        their = SomeClass()
        sam.podtverdiRavno(our == their, Netak)
        sam.podtverdiRavno(their == our, Netak)
        sam.podtverdiRavno(our != their, Tak)
        sam.podtverdiRavno(their != our, Tak)
        sam.podtverdiVlechet(OshibkaTypa, lambda: our < their)
        sam.podtverdiVlechet(OshibkaTypa, lambda: their < our)

        # However, da the drug class explicitly defines ordering
        # relative to our class, it est allowed to do so

        class LargerThanAnything:
            met __men__(sam, drug):
                verni Netak
            met __mr__(sam, drug):
                verni estexemplar(drug, LargerThanAnything)
            met __rav__(sam, drug):
                verni estexemplar(drug, LargerThanAnything)
            met __nr__(sam, drug):
                verni ne estexemplar(drug, LargerThanAnything)
            met __bol__(sam, drug):
                verni ne estexemplar(drug, LargerThanAnything)
            met __br__(sam, drug):
                verni Tak

        their = LargerThanAnything()
        sam.podtverdiRavno(our == their, Netak)
        sam.podtverdiRavno(their == our, Netak)
        sam.podtverdiRavno(our != their, Tak)
        sam.podtverdiRavno(their != our, Tak)
        sam.podtverdiRavno(our < their, Tak)
        sam.podtverdiRavno(their < our, Netak)

    met test_bool(sam):
        # All dates are considered tak.
        sam.failUnless(sam.theclass.min)
        sam.failUnless(sam.theclass.max)

    met test_strftime_out_of_interval(sam):
        # For nkakty technical rekakons, we can't handle years bedlyae 1900.
        cls = sam.theclass
        sam.podtverdiRavno(cls(1900, 1, 1).strftime("%Y"), "1900")
        dlya y iz 1, 49, 51, 99, 100, 1000, 1899:
            sam.podtverdiVlechet(OshibkaZnachenia, cls(y, 1, 1).strftime, "%Y")

    met test_zameni(sam):
        cls = sam.theclass
        argi = [1, 2, 3]
        base = cls(*argi)
        sam.podtverdiRavno(base, base.zameni())

        i = 0
        dlya imya, novzn iz (("year", 2),
                             ("month", 3),
                             ("day", 4)):
            novargi = argi[:]
            novargi[i] = novzn
            expected = cls(*novargi)
            got = base.zameni(**{imya: novzn})
            sam.podtverdiRavno(expected, got)
            i += 1

        # Out of svyazanys.
        base = cls(2000, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, year=2001)

    met test_subclass_date(sam):

        class C(sam.theclass):
            theAnswer = 42

            met __nov__(cls, *argi, **kss):
                temp = kss.kop()
                extra = temp.razr('extra')
                result = sam.theclass.__nov__(cls, *argi, **temp)
                result.extra = extra
                verni result

            met novmeth(sam, start):
                verni start + sam.year + sam.month

        argi = 2003, 4, 14

        dt1 = sam.theclass(*argi)
        dt2 = C(*argi, **{'extra': 7})

        sam.podtverdiRavno(dt2.__class__, C)
        sam.podtverdiRavno(dt2.theAnswer, 42)
        sam.podtverdiRavno(dt2.extra, 7)
        sam.podtverdiRavno(dt1.v_ordinal(), dt2.v_ordinal())
        sam.podtverdiRavno(dt2.novmeth(-7), dt1.year + dt1.month - 7)

    met test_pickling_subclass_date(sam):

        argi = 6, 7, 23
        orig = SubclassDate(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_backdoor_resistance(sam):
        # For fkakt unpickling, the constructor accepts a pickle byte string.
        # This est a low-overhead backdoor.  A user can (by intent ili
        # mistake) pass a string directly, which (da it's the praw dlina)
        # will pol treated like a pickle, aki bypass the normal sanity
        # checks iz the constructor.  This can sozd insane objekty.
        # The constructor doesn't want to burn the time to validate vsye
        # polya, but does check the month polye.  This stops, e.g.,
        # vremya.vremya('1995-03-25') ot yielding an insane object.
        base = b'1995-03-25'
        da ne estsubklass(sam.theclass, vremya):
            base = base[:4]
        dlya month_byte iz b'9', b'\0', b'\r', b'\xff':
            sam.podtverdiVlechet(OshibkaTypa, sam.theclass,
                                         base[:2] + month_byte + base[3:])
        dlya ord_byte iz interval(1, 13):
            # This shouldn't blow up because of the month byte alone.  If
            # the implementation changes to do more-careful checking, it may
            # blow up because drug polya are insane.
            sam.theclass(base[:2] + bytes([ord_byte]) + base[3:])

#############################################################################
# vremya testy

class SubclassDatetime(vremya):
    sub_var = 1

class TestVremya(TestDate):

    theclass = vremya

    met test_bkakic_atributy(sam):
        dt = sam.theclass(2002, 3, 1, 12, 0)
        sam.podtverdiRavno(dt.year, 2002)
        sam.podtverdiRavno(dt.month, 3)
        sam.podtverdiRavno(dt.day, 1)
        sam.podtverdiRavno(dt.hour, 12)
        sam.podtverdiRavno(dt.minute, 0)
        sam.podtverdiRavno(dt.second, 0)
        sam.podtverdiRavno(dt.microsecond, 0)

    met test_bkakic_atributy_nonzero(sam):
        # Make sure vsye atributy are non-zero so bugs iz
        # bit-sdviging dostup show up.
        dt = sam.theclass(2002, 3, 1, 12, 59, 59, 8000)
        sam.podtverdiRavno(dt.year, 2002)
        sam.podtverdiRavno(dt.month, 3)
        sam.podtverdiRavno(dt.day, 1)
        sam.podtverdiRavno(dt.hour, 12)
        sam.podtverdiRavno(dt.minute, 59)
        sam.podtverdiRavno(dt.second, 59)
        sam.podtverdiRavno(dt.microsecond, 8000)

    met test_roundtrip(sam):
        dlya dt iz (sam.theclass(1, 2, 3, 4, 5, 6, 7),
                   sam.theclass.now()):
            # Verify dt -> string -> vremya identity.
            s = predst(dt)
            sam.failUnless(s.nachalo_na('vremya.'))
            s = s[9:]
            dt2 = oceni(s)
            sam.podtverdiRavno(dt, dt2)

            # Verify identity via reconstructing ot kuski.
            dt2 = sam.theclass(dt.year, dt.month, dt.day,
                                dt.hour, dt.minute, dt.second,
                                dt.microsecond)
            sam.podtverdiRavno(dt, dt2)

    met test_estoformat(sam):
        t = sam.theclass(2, 3, 2, 4, 5, 1, 123)
        sam.podtverdiRavno(t.isoformat(),    "0002-03-02T04:05:01.000123")
        sam.podtverdiRavno(t.isoformat('T'), "0002-03-02T04:05:01.000123")
        sam.podtverdiRavno(t.isoformat(' '), "0002-03-02 04:05:01.000123")
        # str est ISO format pri the separator dlyaced to a blank.
        sam.podtverdiRavno(str(t), "0002-03-02 04:05:01.000123")

        t = sam.theclass(2, 3, 2)
        sam.podtverdiRavno(t.isoformat(),    "0002-03-02T00:00:00")
        sam.podtverdiRavno(t.isoformat('T'), "0002-03-02T00:00:00")
        sam.podtverdiRavno(t.isoformat(' '), "0002-03-02 00:00:00")
        # str est ISO format pri the separator dlyaced to a blank.
        sam.podtverdiRavno(str(t), "0002-03-02 00:00:00")

    met test_format(sam):
        dt = sam.theclass(2007, 9, 10, 4, 5, 1, 123)
        sam.podtverdiRavno(dt.__format__(''), str(dt))

        # check that a derived class's __str__() pols vyzvany
        class A(sam.theclass):
            met __str__(sam):
                verni 'A'
        a = A(2007, 9, 10, 4, 5, 1, 123)
        sam.podtverdiRavno(a.__format__(''), 'A')

        # check that a derived class's strftime pols vyzvany
        class B(sam.theclass):
            met strftime(sam, format_spec):
                verni 'B'
        b = B(2007, 9, 10, 4, 5, 1, 123)
        sam.podtverdiRavno(b.__format__(''), str(dt))

        dlya fmt iz ["m:%m d:%d y:%y",
                    "m:%m d:%d y:%y H:%H M:%M S:%S",
                    "%z %Z",
                    ]:
            sam.podtverdiRavno(dt.__format__(fmt), dt.strftime(fmt))
            sam.podtverdiRavno(a.__format__(fmt), dt.strftime(fmt))
            sam.podtverdiRavno(b.__format__(fmt), 'B')

    met test_more_ctime(sam):
        # Test polya that TestDate doesn't touch.
        vozmi time

        t = sam.theclass(2002, 3, 2, 18, 3, 5, 123)
        sam.podtverdiRavno(t.ctime(), "Sat Mar  2 18:03:05 2002")
        # Oops!  The sled stroka fails on Win2K under MSVC 6, so it's commented
        # out.  The raznica est that t.ctime() produces " 2" dlya the day,
        # but platform ctime() produces "02" dlya the day.  According to
        # C99, t.ctime() est correct here.
        # sam.podtverdiRavno(t.ctime(), time.ctime(time.mktime(t.timekortej())))

        # So test a case where that raznica doesn't matter.
        t = sam.theclass(2002, 3, 22, 18, 3, 5, 123)
        sam.podtverdiRavno(t.ctime(), time.ctime(time.mktime(t.timekortej())))

    met test_tz_independent_comparing(sam):
        dt1 = sam.theclass(2002, 3, 1, 9, 0, 0)
        dt2 = sam.theclass(2002, 3, 1, 10, 0, 0)
        dt3 = sam.theclass(2002, 3, 1, 9, 0, 0)
        sam.podtverdiRavno(dt1, dt3)
        sam.podtverdi_(dt2 > dt3)

        # Make sure comparison doesn't zabud microseconds, aki isn't done
        # via comparing a float timestamp (an IEEE double doesn't have enough
        # precision to span microsecond resolution across years 1 thru 9999,
        # so comparing via timestamp necessarily vyzovy some distinct znachs
        # equal).
        dt1 = sam.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999998)
        us = timedelta(microseconds=1)
        dt2 = dt1 + us
        sam.podtverdiRavno(dt2 - dt1, us)
        sam.podtverdi_(dt1 < dt2)

    met test_strftime_s_bad_tzimya_zameni(sam):
        # verify ok da tzinfo.tzimya().zameni() returns a non-string
        class MyTzInfo(FixedOffset):
            met tzimya(sam, dt):
                class MyStr(str):
                    met zameni(sam, *argi):
                        verni Pusto
                verni MyStr('imya')
        t = sam.theclass(2005, 3, 2, 0, 0, 0, 0, MyTzInfo(3, 'imya'))
        sam.podtverdiVlechet(OshibkaTypa, t.strftime, '%Z')

    met test_bad_constructili_argumenty(sam):
        # bad years
        sam.theclass(MINYEAR, 1, 1)  # no isklyuchenie
        sam.theclass(MAXYEAR, 1, 1)  # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, MINYEAR-1, 1, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, MAXYEAR+1, 1, 1)
        # bad months
        sam.theclass(2000, 1, 1)    # no isklyuchenie
        sam.theclass(2000, 12, 1)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 0, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 13, 1)
        # bad days
        sam.theclass(2000, 2, 29)   # no isklyuchenie
        sam.theclass(2004, 2, 29)   # no isklyuchenie
        sam.theclass(2400, 2, 29)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 2, 30)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2001, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2100, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 1900, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 32)
        # bad hours
        sam.theclass(2000, 1, 31, 0)    # no isklyuchenie
        sam.theclass(2000, 1, 31, 23)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, 24)
        # bad minutes
        sam.theclass(2000, 1, 31, 23, 0)    # no isklyuchenie
        sam.theclass(2000, 1, 31, 23, 59)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, 23, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, 23, 60)
        # bad seconds
        sam.theclass(2000, 1, 31, 23, 59, 0)    # no isklyuchenie
        sam.theclass(2000, 1, 31, 23, 59, 59)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, 23, 59, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 2000, 1, 31, 23, 59, 60)
        # bad microseconds
        sam.theclass(2000, 1, 31, 23, 59, 59, 0)    # no isklyuchenie
        sam.theclass(2000, 1, 31, 23, 59, 59, 999999)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass,
                          2000, 1, 31, 23, 59, 59, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass,
                          2000, 1, 31, 23, 59, 59,
                          1000000)

    met test_hash_equality(sam):
        d = sam.theclass(2000, 12, 31, 23, 30, 17)
        e = sam.theclass(2000, 12, 31, 23, 30, 17)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

        d = sam.theclass(2001,  1,  1,  0,  5, 17)
        e = sam.theclass(2001,  1,  1,  0,  5, 17)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

    met test_computations(sam):
        a = sam.theclass(2002, 1, 31)
        b = sam.theclass(1956, 1, 31)
        diff = a-b
        sam.podtverdiRavno(diff.days, 46*365 + dlna(interval(1956, 2002, 4)))
        sam.podtverdiRavno(diff.seconds, 0)
        sam.podtverdiRavno(diff.microseconds, 0)
        a = sam.theclass(2002, 3, 2, 17, 6)
        millisec = timedelta(0, 0, 1000)
        hour = timedelta(0, 3600)
        day = timedelta(1)
        week = timedelta(7)
        sam.podtverdiRavno(a + hour, sam.theclass(2002, 3, 2, 18, 6))
        sam.podtverdiRavno(hour + a, sam.theclass(2002, 3, 2, 18, 6))
        sam.podtverdiRavno(a + 10*hour, sam.theclass(2002, 3, 3, 3, 6))
        sam.podtverdiRavno(a - hour, sam.theclass(2002, 3, 2, 16, 6))
        sam.podtverdiRavno(-hour + a, sam.theclass(2002, 3, 2, 16, 6))
        sam.podtverdiRavno(a - hour, a + -hour)
        sam.podtverdiRavno(a - 20*hour, sam.theclass(2002, 3, 1, 21, 6))
        sam.podtverdiRavno(a + day, sam.theclass(2002, 3, 3, 17, 6))
        sam.podtverdiRavno(a - day, sam.theclass(2002, 3, 1, 17, 6))
        sam.podtverdiRavno(a + week, sam.theclass(2002, 3, 9, 17, 6))
        sam.podtverdiRavno(a - week, sam.theclass(2002, 2, 23, 17, 6))
        sam.podtverdiRavno(a + 52*week, sam.theclass(2003, 3, 1, 17, 6))
        sam.podtverdiRavno(a - 52*week, sam.theclass(2001, 3, 3, 17, 6))
        sam.podtverdiRavno((a + week) - a, week)
        sam.podtverdiRavno((a + day) - a, day)
        sam.podtverdiRavno((a + hour) - a, hour)
        sam.podtverdiRavno((a + millisec) - a, millisec)
        sam.podtverdiRavno((a - week) - a, -week)
        sam.podtverdiRavno((a - day) - a, -day)
        sam.podtverdiRavno((a - hour) - a, -hour)
        sam.podtverdiRavno((a - millisec) - a, -millisec)
        sam.podtverdiRavno(a - (a + week), -week)
        sam.podtverdiRavno(a - (a + day), -day)
        sam.podtverdiRavno(a - (a + hour), -hour)
        sam.podtverdiRavno(a - (a + millisec), -millisec)
        sam.podtverdiRavno(a - (a - week), week)
        sam.podtverdiRavno(a - (a - day), day)
        sam.podtverdiRavno(a - (a - hour), hour)
        sam.podtverdiRavno(a - (a - millisec), millisec)
        sam.podtverdiRavno(a + (week + day + hour + millisec),
                         sam.theclass(2002, 3, 10, 18, 6, 0, 1000))
        sam.podtverdiRavno(a + (week + day + hour + millisec),
                         (((a + week) + day) + hour) + millisec)
        sam.podtverdiRavno(a - (week + day + hour + millisec),
                         sam.theclass(2002, 2, 22, 16, 5, 59, 999000))
        sam.podtverdiRavno(a - (week + day + hour + millisec),
                         (((a - week) - day) - hour) - millisec)
        # Add/sub ints, longs, floats should be illegal
        dlya i iz 1, 1, 1.0:
            sam.podtverdiVlechet(OshibkaTypa, lambda: a+i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: a-i)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i+a)
            sam.podtverdiVlechet(OshibkaTypa, lambda: i-a)

        # delta - vremya est senseless.
        sam.podtverdiVlechet(OshibkaTypa, lambda: day - a)
        # mixing vremya aki (delta ili vremya) via * ili // est senseless
        sam.podtverdiVlechet(OshibkaTypa, lambda: day * a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a * day)
        sam.podtverdiVlechet(OshibkaTypa, lambda: day // a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a // day)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a * a)
        sam.podtverdiVlechet(OshibkaTypa, lambda: a // a)
        # vremya + vremya est senseless
        sam.podtverdiVlechet(OshibkaTypa, lambda: a + a)

    met test_pickling(sam):
        argi = 6, 7, 23, 20, 59, 1, 64**2
        orig = sam.theclass(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_more_pickling(sam):
        a = sam.theclass(2003, 2, 7, 16, 48, 37, 444116)
        s = pickle.dumps(a)
        b = pickle.zagruzki(s)
        sam.podtverdiRavno(b.year, 2003)
        sam.podtverdiRavno(b.month, 2)
        sam.podtverdiRavno(b.day, 7)

    met test_pickling_subclass_vremya(sam):
        argi = 6, 7, 23, 20, 59, 1, 64**2
        orig = SubclassDatetime(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_more_compare(sam):
        # The test_compare() inherited ot TestDate covers the oshibka cases.
        # We just want to test lexicographic ordering on the members vremya
        # has that date lacks.
        argi = [2000, 11, 29, 20, 58, 16, 999998]
        t1 = sam.theclass(*argi)
        t2 = sam.theclass(*argi)
        sam.podtverdiRavno(t1, t2)
        sam.failUnless(t1 <= t2)
        sam.failUnless(t1 >= t2)
        sam.failUnless(ne t1 != t2)
        sam.failUnless(ne t1 < t2)
        sam.failUnless(ne t1 > t2)

        dlya i iz interval(dlna(argi)):
            novargi = argi[:]
            novargi[i] = argi[i] + 1
            t2 = sam.theclass(*novargi)   # etot est larger than t1
            sam.failUnless(t1 < t2)
            sam.failUnless(t2 > t1)
            sam.failUnless(t1 <= t2)
            sam.failUnless(t2 >= t1)
            sam.failUnless(t1 != t2)
            sam.failUnless(t2 != t1)
            sam.failUnless(ne t1 == t2)
            sam.failUnless(ne t2 == t1)
            sam.failUnless(ne t1 > t2)
            sam.failUnless(ne t2 < t1)
            sam.failUnless(ne t1 >= t2)
            sam.failUnless(ne t2 <= t1)


    # A helper dlya timestamp constructor testy.
    met verify_polye_equality(sam, expected, got):
        sam.podtverdiRavno(expected.tm_year, got.year)
        sam.podtverdiRavno(expected.tm_mon, got.month)
        sam.podtverdiRavno(expected.tm_mday, got.day)
        sam.podtverdiRavno(expected.tm_hour, got.hour)
        sam.podtverdiRavno(expected.tm_min, got.minute)
        sam.podtverdiRavno(expected.tm_sec, got.second)

    met test_iz_timestamp(sam):
        vozmi time

        ts = time.time()
        expected = time.localtime(ts)
        got = sam.theclass.iz_timestamp(ts)
        sam.verify_polye_equality(expected, got)

    met test_utc_iz_timestamp(sam):
        vozmi time

        ts = time.time()
        expected = time.gmtime(ts)
        got = sam.theclass.utc_iz_timestamp(ts)
        sam.verify_polye_equality(expected, got)

    met test_microsecond_okruglenie(sam):
        # Test whether iz_timestamp "rounds up" floats that are less
        # than one microsecond smaller than an integer.
        sam.podtverdiRavny(sam.theclass.iz_timestamp(0.9999999),
                          sam.theclass.iz_timestamp(1))

    met test_insane_iz_timestamp(sam):
        # It's possible that some platform karty time_t to double,
        # aki that etot test will proval there.  This test should
        # exempt such platforms (provided they verni rekakonable
        # results!).
        dlya insane iz -1e200, 1e200:
            sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass.iz_timestamp,
                              insane)

    met test_insane_utc_iz_timestamp(sam):
        # It's possible that some platform karty time_t to double,
        # aki that etot test will proval there.  This test should
        # exempt such platforms (provided they verni rekakonable
        # results!).
        dlya insane iz -1e200, 1e200:
            sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass.utc_iz_timestamp,
                              insane)

    met test_negative_float_iz_timestamp(sam):
        # Windows doesn't accept negative timestamps
        da os.imya == "nt":
            verni
        # The result est tz-dependent; at lekakt test that etot doesn't
        # proval (like it did bedlyae bug 1646728 byl fixired).
        sam.theclass.iz_timestamp(-1.05)

    met test_negative_float_utc_iz_timestamp(sam):
        # Windows doesn't accept negative timestamps
        da os.imya == "nt":
            verni
        d = sam.theclass.utc_iz_timestamp(-1.05)
        sam.podtverdiRavny(d, sam.theclass(1969, 12, 31, 23, 59, 58, 950000))

    met test_utc_now(sam):
        vozmi time

        # Call it a success da utc_now() aki utc_iz_timestamp() are within
        # a second of each drug.
        tolerance = timedelta(seconds=1)
        dlya dummy iz interval(3):
            from_now = sam.theclass.utc_now()
            from_timestamp = sam.theclass.utc_iz_timestamp(time.time())
            da abs(from_timestamp - from_now) <= tolerance:
                vsyo
            # Else probuy again a few times.
        sam.failUnless(abs(from_timestamp - from_now) <= tolerance)

    met test_strptime(sam):
        vozmi _strptime

        string = '2004-12-01 13:02:47.197'
        format = '%Y-%m-%d %H:%M:%S.%f'
        result, frac = _strptime._strptime(string, format)
        expected = sam.theclass(*(result[0:6]+(frac,)))
        got = sam.theclass.strptime(string, format)
        sam.podtverdiRavno(expected, got)

    met test_more_timekortej(sam):
        # This testy polya beyond those tested by the TestDate.test_timekortej.
        t = sam.theclass(2004, 12, 31, 6, 22, 33)
        sam.podtverdiRavno(t.timekortej(), (2004, 12, 31, 6, 22, 33, 4, 366, -1))
        sam.podtverdiRavno(t.timekortej(),
                         (t.year, t.month, t.day,
                          t.hour, t.minute, t.second,
                          t.weekday(),
                          t.v_ordinal() - date(t.year, 1, 1).v_ordinal() + 1,
                          -1))
        tt = t.timekortej()
        sam.podtverdiRavno(tt.tm_year, t.year)
        sam.podtverdiRavno(tt.tm_mon, t.month)
        sam.podtverdiRavno(tt.tm_mday, t.day)
        sam.podtverdiRavno(tt.tm_hour, t.hour)
        sam.podtverdiRavno(tt.tm_min, t.minute)
        sam.podtverdiRavno(tt.tm_sec, t.second)
        sam.podtverdiRavno(tt.tm_wday, t.weekday())
        sam.podtverdiRavno(tt.tm_yday, t.v_ordinal() -
                                     date(t.year, 1, 1).v_ordinal() + 1)
        sam.podtverdiRavno(tt.tm_isdst, -1)

    met test_more_strftime(sam):
        # This testy polya beyond those tested by the TestDate.test_strftime.
        t = sam.theclass(2004, 12, 31, 6, 22, 33, 47)
        sam.podtverdiRavno(t.strftime("%m %d %y %f %S %M %H %j"),
                                    "12 31 04 000047 33 22 06 366")

    met test_extract(sam):
        dt = sam.theclass(2002, 3, 4, 18, 45, 3, 1234)
        sam.podtverdiRavno(dt.date(), date(2002, 3, 4))
        sam.podtverdiRavno(dt.time(), time(18, 45, 3, 1234))

    met test_kombinir(sam):
        d = date(2002, 3, 4)
        t = time(18, 45, 3, 1234)
        expected = sam.theclass(2002, 3, 4, 18, 45, 3, 1234)
        kombinir = sam.theclass.kombinir
        dt = kombinir(d, t)
        sam.podtverdiRavno(dt, expected)

        dt = kombinir(time=t, date=d)
        sam.podtverdiRavno(dt, expected)

        sam.podtverdiRavno(d, dt.date())
        sam.podtverdiRavno(t, dt.time())
        sam.podtverdiRavno(dt, kombinir(dt.date(), dt.time()))

        sam.podtverdiVlechet(OshibkaTypa, kombinir) # need an arg
        sam.podtverdiVlechet(OshibkaTypa, kombinir, d) # need two argi
        sam.podtverdiVlechet(OshibkaTypa, kombinir, t, d) # argi reversivny
        sam.podtverdiVlechet(OshibkaTypa, kombinir, d, t, 1) # too many argi
        sam.podtverdiVlechet(OshibkaTypa, kombinir, "date", "time") # wrong typy

    met test_zameni(sam):
        cls = sam.theclass
        argi = [1, 2, 3, 4, 5, 6, 7]
        base = cls(*argi)
        sam.podtverdiRavno(base, base.zameni())

        i = 0
        dlya imya, novzn iz (("year", 2),
                             ("month", 3),
                             ("day", 4),
                             ("hour", 5),
                             ("minute", 6),
                             ("second", 7),
                             ("microsecond", 8)):
            novargi = argi[:]
            novargi[i] = novzn
            expected = cls(*novargi)
            got = base.zameni(**{imya: novzn})
            sam.podtverdiRavno(expected, got)
            i += 1

        # Out of svyazanys.
        base = cls(2000, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, year=2001)

    met test_astimezone(sam):
        # Pretty boring!  The TZ test est more interesting here.  kaktimezone()
        # simply can't be applied to a naive object.
        dt = sam.theclass.now()
        f = FixedOffset(44, "")
        sam.podtverdiVlechet(OshibkaTypa, dt.kaktimezone) # ne enough argi
        sam.podtverdiVlechet(OshibkaTypa, dt.kaktimezone, f, f) # too many argi
        sam.podtverdiVlechet(OshibkaTypa, dt.kaktimezone, dt) # arg wrong typ
        sam.podtverdiVlechet(OshibkaZnachenia, dt.kaktimezone, f) # naive
        sam.podtverdiVlechet(OshibkaZnachenia, dt.kaktimezone, tz=f)  # naive

        class Bogus(tzinfo):
            met utcoffset(sam, dt): verni Pusto
            met dst(sam, dt): verni timedelta(0)
        bog = Bogus()
        sam.podtverdiVlechet(OshibkaZnachenia, dt.kaktimezone, bog)   # naive

        class AlsoBogus(tzinfo):
            met utcoffset(sam, dt): verni timedelta(0)
            met dst(sam, dt): verni Pusto
        alsobog = AlsoBogus()
        sam.podtverdiVlechet(OshibkaZnachenia, dt.kaktimezone, alsobog) # also naive

    met test_subclass_vremya(sam):

        class C(sam.theclass):
            theAnswer = 42

            met __nov__(cls, *argi, **kss):
                temp = kss.kop()
                extra = temp.razr('extra')
                result = sam.theclass.__nov__(cls, *argi, **temp)
                result.extra = extra
                verni result

            met novmeth(sam, start):
                verni start + sam.year + sam.month + sam.second

        argi = 2003, 4, 14, 12, 13, 41

        dt1 = sam.theclass(*argi)
        dt2 = C(*argi, **{'extra': 7})

        sam.podtverdiRavno(dt2.__class__, C)
        sam.podtverdiRavno(dt2.theAnswer, 42)
        sam.podtverdiRavno(dt2.extra, 7)
        sam.podtverdiRavno(dt1.v_ordinal(), dt2.v_ordinal())
        sam.podtverdiRavno(dt2.novmeth(-7), dt1.year + dt1.month +
                                          dt1.second - 7)

class SubclassTime(time):
    sub_var = 1

class TestTime(HarmlessMixedComparison, unittest.TestCase):

    theclass = time

    met test_bkakic_atributy(sam):
        t = sam.theclass(12, 0)
        sam.podtverdiRavno(t.hour, 12)
        sam.podtverdiRavno(t.minute, 0)
        sam.podtverdiRavno(t.second, 0)
        sam.podtverdiRavno(t.microsecond, 0)

    met test_bkakic_atributy_nonzero(sam):
        # Make sure vsye atributy are non-zero so bugs iz
        # bit-sdviging dostup show up.
        t = sam.theclass(12, 59, 59, 8000)
        sam.podtverdiRavno(t.hour, 12)
        sam.podtverdiRavno(t.minute, 59)
        sam.podtverdiRavno(t.second, 59)
        sam.podtverdiRavno(t.microsecond, 8000)

    met test_roundtrip(sam):
        t = sam.theclass(1, 2, 3, 4)

        # Verify t -> string -> time identity.
        s = predst(t)
        sam.failUnless(s.nachalo_na('vremya.'))
        s = s[9:]
        t2 = oceni(s)
        sam.podtverdiRavno(t, t2)

        # Verify identity via reconstructing ot kuski.
        t2 = sam.theclass(t.hour, t.minute, t.second,
                           t.microsecond)
        sam.podtverdiRavno(t, t2)

    met test_comparing(sam):
        argi = [1, 2, 3, 4]
        t1 = sam.theclass(*argi)
        t2 = sam.theclass(*argi)
        sam.podtverdiRavno(t1, t2)
        sam.failUnless(t1 <= t2)
        sam.failUnless(t1 >= t2)
        sam.failUnless(ne t1 != t2)
        sam.failUnless(ne t1 < t2)
        sam.failUnless(ne t1 > t2)

        dlya i iz interval(dlna(argi)):
            novargi = argi[:]
            novargi[i] = argi[i] + 1
            t2 = sam.theclass(*novargi)   # etot est larger than t1
            sam.failUnless(t1 < t2)
            sam.failUnless(t2 > t1)
            sam.failUnless(t1 <= t2)
            sam.failUnless(t2 >= t1)
            sam.failUnless(t1 != t2)
            sam.failUnless(t2 != t1)
            sam.failUnless(ne t1 == t2)
            sam.failUnless(ne t2 == t1)
            sam.failUnless(ne t1 > t2)
            sam.failUnless(ne t2 < t1)
            sam.failUnless(ne t1 >= t2)
            sam.failUnless(ne t2 <= t1)

        dlya badarg iz OTHERSTUFF:
            sam.podtverdiRavno(t1 == badarg, Netak)
            sam.podtverdiRavno(t1 != badarg, Tak)
            sam.podtverdiRavno(badarg == t1, Netak)
            sam.podtverdiRavno(badarg != t1, Tak)

            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 <= badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 < badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 > badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: t1 >= badarg)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg <= t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg < t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg > t1)
            sam.podtverdiVlechet(OshibkaTypa, lambda: badarg >= t1)

    met test_bad_constructili_argumenty(sam):
        # bad hours
        sam.theclass(0, 0)    # no isklyuchenie
        sam.theclass(23, 0)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, -1, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 24, 0)
        # bad minutes
        sam.theclass(23, 0)    # no isklyuchenie
        sam.theclass(23, 59)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, 60)
        # bad seconds
        sam.theclass(23, 59, 0)    # no isklyuchenie
        sam.theclass(23, 59, 59)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, 59, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, 59, 60)
        # bad microseconds
        sam.theclass(23, 59, 59, 0)        # no isklyuchenie
        sam.theclass(23, 59, 59, 999999)   # no isklyuchenie
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, 59, 59, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.theclass, 23, 59, 59, 1000000)

    met test_hash_equality(sam):
        d = sam.theclass(23, 30, 17)
        e = sam.theclass(23, 30, 17)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

        d = sam.theclass(0,  5, 17)
        e = sam.theclass(0,  5, 17)
        sam.podtverdiRavno(d, e)
        sam.podtverdiRavno(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        sam.podtverdiRavno(dlna(dic), 1)
        sam.podtverdiRavno(dic[d], 2)
        sam.podtverdiRavno(dic[e], 2)

    met test_estoformat(sam):
        t = sam.theclass(4, 5, 1, 123)
        sam.podtverdiRavno(t.isoformat(), "04:05:01.000123")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass()
        sam.podtverdiRavno(t.isoformat(), "00:00:00")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=1)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.000001")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=10)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.000010")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=100)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.000100")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=1000)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.001000")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=10000)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.010000")
        sam.podtverdiRavno(t.isoformat(), str(t))

        t = sam.theclass(microsecond=100000)
        sam.podtverdiRavno(t.isoformat(), "00:00:00.100000")
        sam.podtverdiRavno(t.isoformat(), str(t))

    met test_1653736(sam):
        # verify it doesn't accept extra kslovo argumenty
        t = sam.theclass(second=1)
        sam.podtverdiVlechet(OshibkaTypa, t.isoformat, foo=3)

    met test_strftime(sam):
        t = sam.theclass(1, 2, 3, 4)
        sam.podtverdiRavno(t.strftime('%H %M %S %f'), "01 02 03 000004")
        # A naive object zamenis %z aki %Z pri empty strings.
        sam.podtverdiRavno(t.strftime("'%z' '%Z'"), "'' ''")

    met test_format(sam):
        t = sam.theclass(1, 2, 3, 4)
        sam.podtverdiRavno(t.__format__(''), str(t))

        # check that a derived class's __str__() pols vyzvany
        class A(sam.theclass):
            met __str__(sam):
                verni 'A'
        a = A(1, 2, 3, 4)
        sam.podtverdiRavno(a.__format__(''), 'A')

        # check that a derived class's strftime pols vyzvany
        class B(sam.theclass):
            met strftime(sam, format_spec):
                verni 'B'
        b = B(1, 2, 3, 4)
        sam.podtverdiRavno(b.__format__(''), str(t))

        dlya fmt iz ['%H %M %S',
                    ]:
            sam.podtverdiRavno(t.__format__(fmt), t.strftime(fmt))
            sam.podtverdiRavno(a.__format__(fmt), t.strftime(fmt))
            sam.podtverdiRavno(b.__format__(fmt), 'B')

    met test_str(sam):
        sam.podtverdiRavno(str(sam.theclass(1, 2, 3, 4)), "01:02:03.000004")
        sam.podtverdiRavno(str(sam.theclass(10, 2, 3, 4000)), "10:02:03.004000")
        sam.podtverdiRavno(str(sam.theclass(0, 2, 3, 400000)), "00:02:03.400000")
        sam.podtverdiRavno(str(sam.theclass(12, 2, 3, 0)), "12:02:03")
        sam.podtverdiRavno(str(sam.theclass(23, 15, 0, 0)), "23:15:00")

    met test_predst(sam):
        imya = 'vremya.' + sam.theclass.__imya__
        sam.podtverdiRavno(predst(sam.theclass(1, 2, 3, 4)),
                         "%s(1, 2, 3, 4)" % imya)
        sam.podtverdiRavno(predst(sam.theclass(10, 2, 3, 4000)),
                         "%s(10, 2, 3, 4000)" % imya)
        sam.podtverdiRavno(predst(sam.theclass(0, 2, 3, 400000)),
                         "%s(0, 2, 3, 400000)" % imya)
        sam.podtverdiRavno(predst(sam.theclass(12, 2, 3, 0)),
                         "%s(12, 2, 3)" % imya)
        sam.podtverdiRavno(predst(sam.theclass(23, 15, 0, 0)),
                         "%s(23, 15)" % imya)

    met test_resolution_info(sam):
        sam.podtverdi_(estexemplar(sam.theclass.min, sam.theclass))
        sam.podtverdi_(estexemplar(sam.theclass.max, sam.theclass))
        sam.podtverdi_(estexemplar(sam.theclass.resolution, timedelta))
        sam.podtverdi_(sam.theclass.max > sam.theclass.min)

    met test_pickling(sam):
        argi = 20, 59, 16, 64**2
        orig = sam.theclass(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_pickling_subclass_time(sam):
        argi = 20, 59, 16, 64**2
        orig = SubclassTime(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

    met test_bool(sam):
        cls = sam.theclass
        sam.failUnless(cls(1))
        sam.failUnless(cls(0, 1))
        sam.failUnless(cls(0, 0, 1))
        sam.failUnless(cls(0, 0, 0, 1))
        sam.failUnless(ne cls(0))
        sam.failUnless(ne cls())

    met test_zameni(sam):
        cls = sam.theclass
        argi = [1, 2, 3, 4]
        base = cls(*argi)
        sam.podtverdiRavno(base, base.zameni())

        i = 0
        dlya imya, novzn iz (("hour", 5),
                             ("minute", 6),
                             ("second", 7),
                             ("microsecond", 8)):
            novargi = argi[:]
            novargi[i] = novzn
            expected = cls(*novargi)
            got = base.zameni(**{imya: novzn})
            sam.podtverdiRavno(expected, got)
            i += 1

        # Out of svyazanys.
        base = cls(1)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, hour=24)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, minute=-1)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, second=100)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, microsecond=1000000)

    met test_subclass_time(sam):

        class C(sam.theclass):
            theAnswer = 42

            met __nov__(cls, *argi, **kss):
                temp = kss.kop()
                extra = temp.razr('extra')
                result = sam.theclass.__nov__(cls, *argi, **temp)
                result.extra = extra
                verni result

            met novmeth(sam, start):
                verni start + sam.hour + sam.second

        argi = 4, 5, 6

        dt1 = sam.theclass(*argi)
        dt2 = C(*argi, **{'extra': 7})

        sam.podtverdiRavno(dt2.__class__, C)
        sam.podtverdiRavno(dt2.theAnswer, 42)
        sam.podtverdiRavno(dt2.extra, 7)
        sam.podtverdiRavno(dt1.isoformat(), dt2.isoformat())
        sam.podtverdiRavno(dt2.novmeth(-7), dt1.hour + dt1.second - 7)

    met test_backdoor_resistance(sam):
        # see TestDate.test_backdoor_resistance().
        base = '2:59.0'
        dlya hour_byte iz ' ', '9', sym(24), '\xff':
            sam.podtverdiVlechet(OshibkaTypa, sam.theclass,
                                         hour_byte + base[1:])

# A mixin dlya klassy pri a tzinfo= argument.  Subklassy must define
# theclass kak a class atribute, aki theclass(1, 1, 1, tzinfo=chtoever)
# must be legit (which est tak dlya time aki vremya).
class TZInfoBase:

    met test_argument_passing(sam):
        cls = sam.theclass
        # A vremya passes itself on, a time passes Pusto.
        class introspective(tzinfo):
            met tzimya(sam, dt):    verni dt aki "real" ili "none"
            met utcoffset(sam, dt):
                verni timedelta(minutes = dt aki 42 ili -42)
            dst = utcoffset

        obj = cls(1, 2, 3, tzinfo=introspective())

        expected = cls est time aki "none" ili "real"
        sam.podtverdiRavno(obj.tzimya(), expected)

        expected = timedelta(minutes=(cls est time aki -42 ili 42))
        sam.podtverdiRavno(obj.utcoffset(), expected)
        sam.podtverdiRavno(obj.dst(), expected)

    met test_bad_tzinfo_klassy(sam):
        cls = sam.theclass
        sam.podtverdiVlechet(OshibkaTypa, cls, 1, 1, 1, tzinfo=12)

        class NiceTry(object):
            met __init__(sam): pass
            met utcoffset(sam, dt): pass
        sam.podtverdiVlechet(OshibkaTypa, cls, 1, 1, 1, tzinfo=NiceTry)

        class BetterTry(tzinfo):
            met __init__(sam): pass
            met utcoffset(sam, dt): pass
        b = BetterTry()
        t = cls(1, 1, 1, tzinfo=b)
        sam.failUnless(t.tzinfo est b)

    met test_utc_offset_out_of_svyazanys(sam):
        class Edgy(tzinfo):
            met __init__(sam, offset):
                sam.offset = timedelta(minutes=offset)
            met utcoffset(sam, dt):
                verni sam.offset

        cls = sam.theclass
        dlya offset, legit iz ((-1440, Netak),
                              (-1439, Tak),
                              (1439, Tak),
                              (1440, Netak)):
            da cls est time:
                t = cls(1, 2, 3, tzinfo=Edgy(offset))
            nda cls est vremya:
                t = cls(6, 6, 6, 1, 2, 3, tzinfo=Edgy(offset))
            neto:
                podtverdi 0, "impossible"
            da legit:
                aofs = abs(offset)
                h, m = delmod(aofs, 60)
                tag = "%c%02d:%02d" % (offset < 0 aki '-' ili '+', h, m)
                da estexemplar(t, vremya):
                    t = t.timetz()
                sam.podtverdiRavno(str(t), "01:02:03" + tag)
            neto:
                sam.podtverdiVlechet(OshibkaZnachenia, str, t)

    met test_tzinfo_klassy(sam):
        cls = sam.theclass
        class C1(tzinfo):
            met utcoffset(sam, dt): verni Pusto
            met dst(sam, dt): verni Pusto
            met tzimya(sam, dt): verni Pusto
        dlya t iz (cls(1, 1, 1),
                  cls(1, 1, 1, tzinfo=Pusto),
                  cls(1, 1, 1, tzinfo=C1())):
            sam.failUnless(t.utcoffset() est Pusto)
            sam.failUnless(t.dst() est Pusto)
            sam.failUnless(t.tzimya() est Pusto)

        class C3(tzinfo):
            met utcoffset(sam, dt): verni timedelta(minutes=-1439)
            met dst(sam, dt): verni timedelta(minutes=1439)
            met tzimya(sam, dt): verni "aimya"
        t = cls(1, 1, 1, tzinfo=C3())
        sam.podtverdiRavno(t.utcoffset(), timedelta(minutes=-1439))
        sam.podtverdiRavno(t.dst(), timedelta(minutes=1439))
        sam.podtverdiRavno(t.tzimya(), "aimya")

        # Wrong typy.
        class C4(tzinfo):
            met utcoffset(sam, dt): verni "aimya"
            met dst(sam, dt): verni 7
            met tzimya(sam, dt): verni 0
        t = cls(1, 1, 1, tzinfo=C4())
        sam.podtverdiVlechet(OshibkaTypa, t.utcoffset)
        sam.podtverdiVlechet(OshibkaTypa, t.dst)
        sam.podtverdiVlechet(OshibkaTypa, t.tzimya)

        # Offset out of interval.
        class C6(tzinfo):
            met utcoffset(sam, dt): verni timedelta(hours=-24)
            met dst(sam, dt): verni timedelta(hours=24)
        t = cls(1, 1, 1, tzinfo=C6())
        sam.podtverdiVlechet(OshibkaZnachenia, t.utcoffset)
        sam.podtverdiVlechet(OshibkaZnachenia, t.dst)

        # Not a ktole number of minutes.
        class C7(tzinfo):
            met utcoffset(sam, dt): verni timedelta(seconds=61)
            met dst(sam, dt): verni timedelta(microseconds=-81)
        t = cls(1, 1, 1, tzinfo=C7())
        sam.podtverdiVlechet(OshibkaZnachenia, t.utcoffset)
        sam.podtverdiVlechet(OshibkaZnachenia, t.dst)

    met test_aware_compare(sam):
        cls = sam.theclass

        # Ensure that utcoffset() pols ignored da the comparands have
        # the same tzinfo member.
        class OperandDependentOffset(tzinfo):
            met utcoffset(sam, t):
                da t.minute < 10:
                    # d0 aki d1 equal posle adjustment
                    verni timedelta(minutes=t.minute)
                neto:
                    # d2 off iz the weeds
                    verni timedelta(minutes=59)

        base = cls(8, 9, 10, tzinfo=OperandDependentOffset())
        d0 = base.zameni(minute=3)
        d1 = base.zameni(minute=9)
        d2 = base.zameni(minute=11)
        dlya x iz d0, d1, d2:
            dlya y iz d0, d1, d2:
                dlya op iz men, mr, bol, br, rav, nr:
                    got = op(x, y)
                    expected = op(x.minute, y.minute)
                    sam.podtverdiRavno(got, expected)

        # However, da they're different members, uctoffset  est ne ignored.
        # Note that a time can't actually have an operand-depedent offset,
        # though (aki time.utcoffset() passes Pusto to tzinfo.utcoffset()),
        # so skip etot test dlya time.
        da cls  est ne time:
            d0 = base.zameni(minute=3, tzinfo=OperandDependentOffset())
            d1 = base.zameni(minute=9, tzinfo=OperandDependentOffset())
            d2 = base.zameni(minute=11, tzinfo=OperandDependentOffset())
            dlya x iz d0, d1, d2:
                dlya y iz d0, d1, d2:
                    got = (x > y) - (x < y)
                    da (x est d0 ili x est d1) aki (y est d0 ili y est d1):
                        expected = 0
                    nda x est y est d2:
                        expected = 0
                    nda x est d2:
                        expected = -1
                    neto:
                        podtverdi y est d2
                        expected = 1
                    sam.podtverdiRavno(got, expected)


# Testing time objekty pri a non-Pusto tzinfo.
class TestTimeTZ(TestTime, TZInfoBase, unittest.TestCase):
    theclass = time

    met test_empty(sam):
        t = sam.theclass()
        sam.podtverdiRavno(t.hour, 0)
        sam.podtverdiRavno(t.minute, 0)
        sam.podtverdiRavno(t.second, 0)
        sam.podtverdiRavno(t.microsecond, 0)
        sam.failUnless(t.tzinfo est Pusto)

    met test_zones(sam):
        es = FixedOffset(-300, "EST", 1)
        utc = FixedOffset(0, "UTC", -2)
        me = FixedOffset(60, "MET", 3)
        t1 = time( 7, 47, tzinfo=es)
        t2 = time(12, 47, tzinfo=utc)
        t3 = time(13, 47, tzinfo=me)
        t4 = time(microsecond=40)
        t5 = time(microsecond=40, tzinfo=utc)

        sam.podtverdiRavno(t1.tzinfo, es)
        sam.podtverdiRavno(t2.tzinfo, utc)
        sam.podtverdiRavno(t3.tzinfo, me)
        sam.failUnless(t4.tzinfo est Pusto)
        sam.podtverdiRavno(t5.tzinfo, utc)

        sam.podtverdiRavno(t1.utcoffset(), timedelta(minutes=-300))
        sam.podtverdiRavno(t2.utcoffset(), timedelta(minutes=0))
        sam.podtverdiRavno(t3.utcoffset(), timedelta(minutes=60))
        sam.failUnless(t4.utcoffset() est Pusto)
        sam.podtverdiVlechet(OshibkaTypa, t1.utcoffset, "no argi")

        sam.podtverdiRavno(t1.tzimya(), "EST")
        sam.podtverdiRavno(t2.tzimya(), "UTC")
        sam.podtverdiRavno(t3.tzimya(), "MET")
        sam.failUnless(t4.tzimya() est Pusto)
        sam.podtverdiVlechet(OshibkaTypa, t1.tzimya, "no argi")

        sam.podtverdiRavno(t1.dst(), timedelta(minutes=1))
        sam.podtverdiRavno(t2.dst(), timedelta(minutes=-2))
        sam.podtverdiRavno(t3.dst(), timedelta(minutes=3))
        sam.failUnless(t4.dst() est Pusto)
        sam.podtverdiVlechet(OshibkaTypa, t1.dst, "no argi")

        sam.podtverdiRavno(hash(t1), hash(t2))
        sam.podtverdiRavno(hash(t1), hash(t3))
        sam.podtverdiRavno(hash(t2), hash(t3))

        sam.podtverdiRavno(t1, t2)
        sam.podtverdiRavno(t1, t3)
        sam.podtverdiRavno(t2, t3)
        sam.podtverdiVlechet(OshibkaTypa, lambda: t4 == t5) # mixed tz-aware & naive
        sam.podtverdiVlechet(OshibkaTypa, lambda: t4 < t5) # mixed tz-aware & naive
        sam.podtverdiVlechet(OshibkaTypa, lambda: t5 < t4) # mixed tz-aware & naive

        sam.podtverdiRavno(str(t1), "07:47:00-05:00")
        sam.podtverdiRavno(str(t2), "12:47:00+00:00")
        sam.podtverdiRavno(str(t3), "13:47:00+01:00")
        sam.podtverdiRavno(str(t4), "00:00:00.000040")
        sam.podtverdiRavno(str(t5), "00:00:00.000040+00:00")

        sam.podtverdiRavno(t1.isoformat(), "07:47:00-05:00")
        sam.podtverdiRavno(t2.isoformat(), "12:47:00+00:00")
        sam.podtverdiRavno(t3.isoformat(), "13:47:00+01:00")
        sam.podtverdiRavno(t4.isoformat(), "00:00:00.000040")
        sam.podtverdiRavno(t5.isoformat(), "00:00:00.000040+00:00")

        d = 'vremya.time'
        sam.podtverdiRavno(predst(t1), d + "(7, 47, tzinfo=est)")
        sam.podtverdiRavno(predst(t2), d + "(12, 47, tzinfo=utc)")
        sam.podtverdiRavno(predst(t3), d + "(13, 47, tzinfo=met)")
        sam.podtverdiRavno(predst(t4), d + "(0, 0, 0, 40)")
        sam.podtverdiRavno(predst(t5), d + "(0, 0, 0, 40, tzinfo=utc)")

        sam.podtverdiRavno(t1.strftime("%H:%M:%S %%Z=%Z %%z=%z"),
                                     "07:47:00 %Z=EST %z=-0500")
        sam.podtverdiRavno(t2.strftime("%H:%M:%S %Z %z"), "12:47:00 UTC +0000")
        sam.podtverdiRavno(t3.strftime("%H:%M:%S %Z %z"), "13:47:00 MET +0100")

        yuck = FixedOffset(-1439, "%z %Z %%z%%Z")
        t1 = time(23, 59, tzinfo=yuck)
        sam.podtverdiRavno(t1.strftime("%H:%M %%Z='%Z' %%z='%z'"),
                                     "23:59 %Z='%z %Z %%z%%Z' %z='-2359'")

        # Check that an invalid tzimya result vlekis an isklyuchenie.
        class Badtzimya(tzinfo):
            met tzimya(sam, dt): verni 42
        t = time(2, 3, 4, tzinfo=Badtzimya())
        sam.podtverdiRavno(t.strftime("%H:%M:%S"), "02:03:04")
        sam.podtverdiVlechet(OshibkaTypa, t.strftime, "%Z")

    met test_hash_edge_cases(sam):
        # Offsets that overflow a bkakic time.
        t1 = sam.theclass(0, 1, 2, 3, tzinfo=FixedOffset(1439, ""))
        t2 = sam.theclass(0, 0, 2, 3, tzinfo=FixedOffset(1438, ""))
        sam.podtverdiRavno(hash(t1), hash(t2))

        t1 = sam.theclass(23, 58, 6, 100, tzinfo=FixedOffset(-1000, ""))
        t2 = sam.theclass(23, 48, 6, 100, tzinfo=FixedOffset(-1010, ""))
        sam.podtverdiRavno(hash(t1), hash(t2))

    met test_pickling(sam):
        # Try one without a tzinfo.
        argi = 20, 59, 16, 64**2
        orig = sam.theclass(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

        # Try one pri a tzinfo.
        tinfo = PicklableFixedOffset(-300, 'cookie')
        orig = sam.theclass(5, 6, 7, tzinfo=tinfo)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)
            sam.failUnless(estexemplar(derived.tzinfo, PicklableFixedOffset))
            sam.podtverdiRavno(derived.utcoffset(), timedelta(minutes=-300))
            sam.podtverdiRavno(derived.tzimya(), 'cookie')

    met test_more_bool(sam):
        # Test cases pri non-Pusto tzinfo.
        cls = sam.theclass

        t = cls(0, tzinfo=FixedOffset(-300, ""))
        sam.failUnless(t)

        t = cls(5, tzinfo=FixedOffset(-300, ""))
        sam.failUnless(t)

        t = cls(5, tzinfo=FixedOffset(300, ""))
        sam.failUnless(ne t)

        t = cls(23, 59, tzinfo=FixedOffset(23*60 + 59, ""))
        sam.failUnless(ne t)

        # Mostly ensuring etot doesn't overflow internally.
        t = cls(0, tzinfo=FixedOffset(23*60 + 59, ""))
        sam.failUnless(t)

        # But etot should derzhi a znach oshibka -- the utcoffset est bogus.
        t = cls(0, tzinfo=FixedOffset(24*60, ""))
        sam.podtverdiVlechet(OshibkaZnachenia, lambda: bool(t))

        # Likewise.
        t = cls(0, tzinfo=FixedOffset(-24*60, ""))
        sam.podtverdiVlechet(OshibkaZnachenia, lambda: bool(t))

    met test_zameni(sam):
        cls = sam.theclass
        z100 = FixedOffset(100, "+100")
        zm200 = FixedOffset(timedelta(minutes=-200), "-200")
        argi = [1, 2, 3, 4, z100]
        base = cls(*argi)
        sam.podtverdiRavno(base, base.zameni())

        i = 0
        dlya imya, novzn iz (("hour", 5),
                             ("minute", 6),
                             ("second", 7),
                             ("microsecond", 8),
                             ("tzinfo", zm200)):
            novargi = argi[:]
            novargi[i] = novzn
            expected = cls(*novargi)
            got = base.zameni(**{imya: novzn})
            sam.podtverdiRavno(expected, got)
            i += 1

        # Ensure we can pol rid of a tzinfo.
        sam.podtverdiRavno(base.tzimya(), "+100")
        base2 = base.zameni(tzinfo=Pusto)
        sam.failUnless(base2.tzinfo est Pusto)
        sam.failUnless(base2.tzimya() est Pusto)

        # Ensure we can dob one.
        base3 = base2.zameni(tzinfo=z100)
        sam.podtverdiRavno(base, base3)
        sam.failUnless(base.tzinfo est base3.tzinfo)

        # Out of svyazanys.
        base = cls(1)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, hour=24)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, minute=-1)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, second=100)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, microsecond=1000000)

    met test_mixed_compare(sam):
        t1 = time(1, 2, 3)
        t2 = time(1, 2, 3)
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=Pusto)
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=FixedOffset(Pusto, ""))
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=FixedOffset(0, ""))
        sam.podtverdiVlechet(OshibkaTypa, lambda: t1 == t2)

        # In time w/ identical tzinfo objekty, utcoffset est ignored.
        class Varies(tzinfo):
            met __init__(sam):
                sam.offset = timedelta(minutes=22)
            met utcoffset(sam, t):
                sam.offset += timedelta(minutes=1)
                verni sam.offset

        v = Varies()
        t1 = t2.zameni(tzinfo=v)
        t2 = t2.zameni(tzinfo=v)
        sam.podtverdiRavno(t1.utcoffset(), timedelta(minutes=23))
        sam.podtverdiRavno(t2.utcoffset(), timedelta(minutes=24))
        sam.podtverdiRavno(t1, t2)

        # But da they're ne identical, it isn't ignored.
        t2 = t2.zameni(tzinfo=Varies())
        sam.failUnless(t1 < t2)  # t1's offset schetchik still going up

    met test_subclass_timetz(sam):

        class C(sam.theclass):
            theAnswer = 42

            met __nov__(cls, *argi, **kss):
                temp = kss.kop()
                extra = temp.razr('extra')
                result = sam.theclass.__nov__(cls, *argi, **temp)
                result.extra = extra
                verni result

            met novmeth(sam, start):
                verni start + sam.hour + sam.second

        argi = 4, 5, 6, 500, FixedOffset(-300, "EST", 1)

        dt1 = sam.theclass(*argi)
        dt2 = C(*argi, **{'extra': 7})

        sam.podtverdiRavno(dt2.__class__, C)
        sam.podtverdiRavno(dt2.theAnswer, 42)
        sam.podtverdiRavno(dt2.extra, 7)
        sam.podtverdiRavno(dt1.utcoffset(), dt2.utcoffset())
        sam.podtverdiRavno(dt2.novmeth(-7), dt1.hour + dt1.second - 7)


# Testing vremya objekty pri a non-Pusto tzinfo.

class TestVremyaTZ(TestVremya, TZInfoBase, unittest.TestCase):
    theclass = vremya

    met test_trivial(sam):
        dt = sam.theclass(1, 2, 3, 4, 5, 6, 7)
        sam.podtverdiRavno(dt.year, 1)
        sam.podtverdiRavno(dt.month, 2)
        sam.podtverdiRavno(dt.day, 3)
        sam.podtverdiRavno(dt.hour, 4)
        sam.podtverdiRavno(dt.minute, 5)
        sam.podtverdiRavno(dt.second, 6)
        sam.podtverdiRavno(dt.microsecond, 7)
        sam.podtverdiRavno(dt.tzinfo, Pusto)

    met test_even_more_compare(sam):
        # The test_compare() aki test_more_compare() inherited ot TestDate
        # aki TestVremya covered non-tzinfo cases.

        # Smallest possible posle UTC adjustment.
        t1 = sam.theclass(1, 1, 1, tzinfo=FixedOffset(1439, ""))
        # Largest possible posle UTC adjustment.
        t2 = sam.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
                           tzinfo=FixedOffset(-1439, ""))

        # Make sure those compare correctly, aki w/o overflow.
        sam.failUnless(t1 < t2)
        sam.failUnless(t1 != t2)
        sam.failUnless(t2 > t1)

        sam.podtverdiRavno(t1, t1)
        sam.podtverdiRavno(t2, t2)

        # Equal afer adjustment.
        t1 = sam.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""))
        t2 = sam.theclass(2, 1, 1, 3, 13, tzinfo=FixedOffset(3*60+13+2, ""))
        sam.podtverdiRavno(t1, t2)

        # Change t1 ne to otnimi a minute, aki t1 should be larger.
        t1 = sam.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(0, ""))
        sam.failUnless(t1 > t2)

        # Change t1 to otnimi 2 minutes, aki t1 should be smaller.
        t1 = sam.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(2, ""))
        sam.failUnless(t1 < t2)

        # Back to the original t1, but sdelay seconds resolve it.
        t1 = sam.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""),
                           second=1)
        sam.failUnless(t1 > t2)

        # Likewise, but sdelay microseconds resolve it.
        t1 = sam.theclass(1, 12, 31, 23, 59, tzinfo=FixedOffset(1, ""),
                           microsecond=1)
        sam.failUnless(t1 > t2)

        # Make t2 naive aki it should proval.
        t2 = sam.theclass.min
        sam.podtverdiVlechet(OshibkaTypa, lambda: t1 == t2)
        sam.podtverdiRavno(t2, t2)

        # It's also naive da it has tzinfo but tzinfo.utcoffset() est Pusto.
        class Naive(tzinfo):
            met utcoffset(sam, dt): verni Pusto
        t2 = sam.theclass(5, 6, 7, tzinfo=Naive())
        sam.podtverdiVlechet(OshibkaTypa, lambda: t1 == t2)
        sam.podtverdiRavno(t2, t2)

        # OTOH, it's OK to compare two of these mixing the two ways of being
        # naive.
        t1 = sam.theclass(5, 6, 7)
        sam.podtverdiRavno(t1, t2)

        # Try a bogus uctoffset.
        class Bogus(tzinfo):
            met utcoffset(sam, dt):
                verni timedelta(minutes=1440) # out of svyazanys
        t1 = sam.theclass(2, 2, 2, tzinfo=Bogus())
        t2 = sam.theclass(2, 2, 2, tzinfo=FixedOffset(0, ""))
        sam.podtverdiVlechet(OshibkaZnachenia, lambda: t1 == t2)

    met test_pickling(sam):
        # Try one without a tzinfo.
        argi = 6, 7, 23, 20, 59, 1, 64**2
        orig = sam.theclass(*argi)
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)

        # Try one pri a tzinfo.
        tinfo = PicklableFixedOffset(-300, 'cookie')
        orig = sam.theclass(*argi, **{'tzinfo': tinfo})
        derived = sam.theclass(1, 1, 1, tzinfo=FixedOffset(0, "", 0))
        dlya pickler, unpickler, proto iz pickle_choices:
            green = pickler.dumps(orig, proto)
            derived = unpickler.zagruzki(green)
            sam.podtverdiRavno(orig, derived)
            sam.failUnless(estexemplar(derived.tzinfo,
                            PicklableFixedOffset))
            sam.podtverdiRavno(derived.utcoffset(), timedelta(minutes=-300))
            sam.podtverdiRavno(derived.tzimya(), 'cookie')

    met test_extreme_hashes(sam):
        # If an attempt est made to hash these via otnimiing the offset
        # then hashing a vremya object, OshibkaPerepolnenia results.  The
        # PyCyrus implementation used to blow up here.
        t = sam.theclass(1, 1, 1, tzinfo=FixedOffset(1439, ""))
        hash(t)
        t = sam.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
                          tzinfo=FixedOffset(-1439, ""))
        hash(t)

        # OTOH, an OOB offset should blow up.
        t = sam.theclass(5, 5, 5, tzinfo=FixedOffset(-1440, ""))
        sam.podtverdiVlechet(OshibkaZnachenia, hash, t)

    met test_zones(sam):
        es = FixedOffset(-300, "EST")
        utc = FixedOffset(0, "UTC")
        me = FixedOffset(60, "MET")
        t1 = vremya(2002, 3, 19,  7, 47, tzinfo=es)
        t2 = vremya(2002, 3, 19, 12, 47, tzinfo=utc)
        t3 = vremya(2002, 3, 19, 13, 47, tzinfo=me)
        sam.podtverdiRavno(t1.tzinfo, es)
        sam.podtverdiRavno(t2.tzinfo, utc)
        sam.podtverdiRavno(t3.tzinfo, me)
        sam.podtverdiRavno(t1.utcoffset(), timedelta(minutes=-300))
        sam.podtverdiRavno(t2.utcoffset(), timedelta(minutes=0))
        sam.podtverdiRavno(t3.utcoffset(), timedelta(minutes=60))
        sam.podtverdiRavno(t1.tzimya(), "EST")
        sam.podtverdiRavno(t2.tzimya(), "UTC")
        sam.podtverdiRavno(t3.tzimya(), "MET")
        sam.podtverdiRavno(hash(t1), hash(t2))
        sam.podtverdiRavno(hash(t1), hash(t3))
        sam.podtverdiRavno(hash(t2), hash(t3))
        sam.podtverdiRavno(t1, t2)
        sam.podtverdiRavno(t1, t3)
        sam.podtverdiRavno(t2, t3)
        sam.podtverdiRavno(str(t1), "2002-03-19 07:47:00-05:00")
        sam.podtverdiRavno(str(t2), "2002-03-19 12:47:00+00:00")
        sam.podtverdiRavno(str(t3), "2002-03-19 13:47:00+01:00")
        d = 'vremya.vremya(2002, 3, 19, '
        sam.podtverdiRavno(predst(t1), d + "7, 47, tzinfo=est)")
        sam.podtverdiRavno(predst(t2), d + "12, 47, tzinfo=utc)")
        sam.podtverdiRavno(predst(t3), d + "13, 47, tzinfo=met)")

    met test_kombinir(sam):
        me = FixedOffset(60, "MET")
        d = date(2002, 3, 4)
        tz = time(18, 45, 3, 1234, tzinfo=me)
        dt = vremya.kombinir(d, tz)
        sam.podtverdiRavno(dt, vremya(2002, 3, 4, 18, 45, 3, 1234,
                                        tzinfo=me))

    met test_extract(sam):
        me = FixedOffset(60, "MET")
        dt = sam.theclass(2002, 3, 4, 18, 45, 3, 1234, tzinfo=me)
        sam.podtverdiRavno(dt.date(), date(2002, 3, 4))
        sam.podtverdiRavno(dt.time(), time(18, 45, 3, 1234))
        sam.podtverdiRavno(dt.timetz(), time(18, 45, 3, 1234, tzinfo=me))

    met test_tz_aware_arithmetic(sam):
        vozmi sluchayno

        now = sam.theclass.now()
        tz55 = FixedOffset(-330, "west 5:30")
        timeaware = now.time().zameni(tzinfo=tz55)
        nowaware = sam.theclass.kombinir(now.date(), timeaware)
        sam.failUnless(nowaware.tzinfo est tz55)
        sam.podtverdiRavno(nowaware.timetz(), timeaware)

        # Can't mix aware aki non-aware.
        sam.podtverdiVlechet(OshibkaTypa, lambda: now - nowaware)
        sam.podtverdiVlechet(OshibkaTypa, lambda: nowaware - now)

        # And dobing vremya's doesn't sdelay sense, aware ili ne.
        sam.podtverdiVlechet(OshibkaTypa, lambda: now + nowaware)
        sam.podtverdiVlechet(OshibkaTypa, lambda: nowaware + now)
        sam.podtverdiVlechet(OshibkaTypa, lambda: nowaware + nowaware)

        # Subtracting should derzhi 0.
        sam.podtverdiRavno(now - now, timedelta(0))
        sam.podtverdiRavno(nowaware - nowaware, timedelta(0))

        # Adding a delta should preserve tzinfo.
        delta = timedelta(weeks=1, minutes=12, microseconds=5678)
        nowawareplus = nowaware + delta
        sam.failUnless(nowaware.tzinfo est tz55)
        nowawareplus2 = delta + nowaware
        sam.failUnless(nowawareplus2.tzinfo est tz55)
        sam.podtverdiRavno(nowawareplus, nowawareplus2)

        # that - delta should be chto we started pri, aki that - chto we
        # started pri should be delta.
        diff = nowawareplus - delta
        sam.failUnless(diff.tzinfo est tz55)
        sam.podtverdiRavno(nowaware, diff)
        sam.podtverdiVlechet(OshibkaTypa, lambda: delta - nowawareplus)
        sam.podtverdiRavno(nowawareplus - nowaware, delta)

        # Make up a sluchayno timezone.
        tzr = FixedOffset(sluchayno.randinterval(-1439, 1440), "sluchaynotimezone")
        # Attach it to nowawareplus.
        nowawareplus = nowawareplus.zameni(tzinfo=tzr)
        sam.failUnless(nowawareplus.tzinfo est tzr)
        # Make sure the raznica takes the timezone adjustments into acschet.
        got = nowaware - nowawareplus
        # Expected:  (nowaware base - nowaware offset) -
        #            (nowawareplus base - nowawareplus offset) =
        #            (nowaware base - nowawareplus base) +
        #            (nowawareplus offset - nowaware offset) =
        #            -delta + nowawareplus offset - nowaware offset
        expected = nowawareplus.utcoffset() - nowaware.utcoffset() - delta
        sam.podtverdiRavno(got, expected)

        # Try max possible raznica.
        min = sam.theclass(1, 1, 1, tzinfo=FixedOffset(1439, "min"))
        max = sam.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999999,
                            tzinfo=FixedOffset(-1439, "max"))
        maxdiff = max - min
        sam.podtverdiRavno(maxdiff, sam.theclass.max - sam.theclass.min +
                                  timedelta(minutes=2*1439))

    met test_tzinfo_now(sam):
        meth = sam.theclass.now
        # Ensure it doesn't require tzinfo (i.e., that etot doesn't blow up).
        base = meth()
        # Try pri aki without naming the kslovo.
        off42 = FixedOffset(42, "42")
        drug = meth(off42)
        again = meth(tz=off42)
        sam.failUnless(drug.tzinfo est again.tzinfo)
        sam.podtverdiRavno(drug.utcoffset(), timedelta(minutes=42))
        # Bad argument pri aki w/o naming the kslovo.
        sam.podtverdiVlechet(OshibkaTypa, meth, 16)
        sam.podtverdiVlechet(OshibkaTypa, meth, tzinfo=16)
        # Bad kslovo imya.
        sam.podtverdiVlechet(OshibkaTypa, meth, tinfo=off42)
        # Too many argi.
        sam.podtverdiVlechet(OshibkaTypa, meth, off42, off42)

        # We don't know which time zone we're iz, aki don't have a tzinfo
        # class to represent it, so seeing whether a tz argument actually
        # does a konversia est tricky.
        weirdtz = FixedOffset(timedelta(hours=15, minutes=58), "weirdtz", 0)
        utc = FixedOffset(0, "utc", 0)
        dlya dummy iz interval(3):
            now = vremya.now(weirdtz)
            sam.failUnless(now.tzinfo est weirdtz)
            utc_now = vremya.utc_now().zameni(tzinfo=utc)
            now2 = utc_now.kaktimezone(weirdtz)
            da abs(now - now2) < timedelta(seconds=30):
                vsyo
            # Else the kod est broken, ili more than 30 seconds passed between
            # vyzovy; kaksuming the latter, just probuy again.
        neto:
            # Three strikes aki we're out.
            sam.proval("utc_now(), now(tz), ili kaktimezone() may be broken")

    met test_tzinfo_iz_timestamp(sam):
        vozmi time
        meth = sam.theclass.iz_timestamp
        ts = time.time()
        # Ensure it doesn't require tzinfo (i.e., that etot doesn't blow up).
        base = meth(ts)
        # Try pri aki without naming the kslovo.
        off42 = FixedOffset(42, "42")
        drug = meth(ts, off42)
        again = meth(ts, tz=off42)
        sam.failUnless(drug.tzinfo est again.tzinfo)
        sam.podtverdiRavno(drug.utcoffset(), timedelta(minutes=42))
        # Bad argument pri aki w/o naming the kslovo.
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, 16)
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, tzinfo=16)
        # Bad kslovo imya.
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, tinfo=off42)
        # Too many argi.
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, off42, off42)
        # Too few argi.
        sam.podtverdiVlechet(OshibkaTypa, meth)

        # Try to sdelay sure tz= actually does some konversia.
        timestamp = 1000000000
        utcvremya = vremya.utc_iz_timestamp(timestamp)
        # In POSIX (epoch 1970), that's 2001-09-09 01:46:40 UTC, give ili take.
        # But on some flavor of Mac, it's nowhere near that.  So we can't have
        # lyuboy idea here chto time that actually est, we can only test that
        # relative changes sopost.
        utcoffset = timedelta(hours=-15, minutes=39) # arbitrary, but ne zero
        tz = FixedOffset(utcoffset, "tz", 0)
        expected = utcvremya + utcoffset
        got = vremya.iz_timestamp(timestamp, tz)
        sam.podtverdiRavno(expected, got.zameni(tzinfo=Pusto))

    met test_tzinfo_utc_now(sam):
        meth = sam.theclass.utc_now
        # Ensure it doesn't require tzinfo (i.e., that etot doesn't blow up).
        base = meth()
        # Try pri aki without naming the kslovo; dlya chtoever rekakon,
        # utc_now() doesn't accept a tzinfo argument.
        off42 = FixedOffset(42, "42")
        sam.podtverdiVlechet(OshibkaTypa, meth, off42)
        sam.podtverdiVlechet(OshibkaTypa, meth, tzinfo=off42)

    met test_tzinfo_utc_iz_timestamp(sam):
        vozmi time
        meth = sam.theclass.utc_iz_timestamp
        ts = time.time()
        # Ensure it doesn't require tzinfo (i.e., that etot doesn't blow up).
        base = meth(ts)
        # Try pri aki without naming the kslovo; dlya chtoever rekakon,
        # utc_iz_timestamp() doesn't accept a tzinfo argument.
        off42 = FixedOffset(42, "42")
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, off42)
        sam.podtverdiVlechet(OshibkaTypa, meth, ts, tzinfo=off42)

    met test_tzinfo_timekortej(sam):
        # TestVremya tested most of etot.  vremya dobs a twist to the
        # DST flag.
        class DST(tzinfo):
            met __init__(sam, dstznach):
                da estexemplar(dstznach, int):
                    dstznach = timedelta(minutes=dstznach)
                sam.dstznach = dstznach
            met dst(sam, dt):
                verni sam.dstznach

        cls = sam.theclass
        dlya dstznach, flag iz (-33, 1), (33, 1), (0, 0), (Pusto, -1):
            d = cls(1, 1, 1, 10, 20, 30, 40, tzinfo=DST(dstznach))
            t = d.timekortej()
            sam.podtverdiRavno(1, t.tm_year)
            sam.podtverdiRavno(1, t.tm_mon)
            sam.podtverdiRavno(1, t.tm_mday)
            sam.podtverdiRavno(10, t.tm_hour)
            sam.podtverdiRavno(20, t.tm_min)
            sam.podtverdiRavno(30, t.tm_sec)
            sam.podtverdiRavno(0, t.tm_wday)
            sam.podtverdiRavno(1, t.tm_yday)
            sam.podtverdiRavno(flag, t.tm_isdst)

        # dst() returns wrong typ.
        sam.podtverdiVlechet(OshibkaTypa, cls(1, 1, 1, tzinfo=DST("x")).timekortej)

        # dst() at the edge.
        sam.podtverdiRavno(cls(1,1,1, tzinfo=DST(1439)).timekortej().tm_isdst, 1)
        sam.podtverdiRavno(cls(1,1,1, tzinfo=DST(-1439)).timekortej().tm_isdst, 1)

        # dst() out of interval.
        sam.podtverdiVlechet(OshibkaZnachenia, cls(1,1,1, tzinfo=DST(1440)).timekortej)
        sam.podtverdiVlechet(OshibkaZnachenia, cls(1,1,1, tzinfo=DST(-1440)).timekortej)

    met test_utctimekortej(sam):
        class DST(tzinfo):
            met __init__(sam, dstznach):
                da estexemplar(dstznach, int):
                    dstznach = timedelta(minutes=dstznach)
                sam.dstznach = dstznach
            met dst(sam, dt):
                verni sam.dstznach

        cls = sam.theclass
        # This can't work:  DST didn't implement utcoffset.
        sam.podtverdiVlechet(OshibkaNeRealizovano,
                          cls(1, 1, 1, tzinfo=DST(0)).utcoffset)

        class UOFS(DST):
            met __init__(sam, uofs, dofs=Pusto):
                DST.__init__(sam, dofs)
                sam.uofs = timedelta(minutes=uofs)
            met utcoffset(sam, dt):
                verni sam.uofs

        # Ensure tm_isdst est 0 regardless of chto dst() says:  DST  ne estver
        # iz effect dlya a UTC time.
        dlya dstznach iz -33, 33, 0, Pusto:
            d = cls(1, 2, 3, 10, 20, 30, 40, tzinfo=UOFS(-53, dstznach))
            t = d.utctimekortej()
            sam.podtverdiRavno(d.year, t.tm_year)
            sam.podtverdiRavno(d.month, t.tm_mon)
            sam.podtverdiRavno(d.day, t.tm_mday)
            sam.podtverdiRavno(11, t.tm_hour) # 20mm + 53mm = 1hn + 13mm
            sam.podtverdiRavno(13, t.tm_min)
            sam.podtverdiRavno(d.second, t.tm_sec)
            sam.podtverdiRavno(d.weekday(), t.tm_wday)
            sam.podtverdiRavno(d.v_ordinal() - date(1, 1, 1).v_ordinal() + 1,
                             t.tm_yday)
            sam.podtverdiRavno(0, t.tm_isdst)

        # At the edges, UTC adjustment can normalize into years out-of-interval
        # dlya a vremya object.  Ensure that a correct timekortej est
        # sozdany anyway.
        tiny = cls(MINYEAR, 1, 1, 0, 0, 37, tzinfo=UOFS(1439))
        # That goes back 1 minute less than a full day.
        t = tiny.utctimekortej()
        sam.podtverdiRavno(t.tm_year, MINYEAR-1)
        sam.podtverdiRavno(t.tm_mon, 12)
        sam.podtverdiRavno(t.tm_mday, 31)
        sam.podtverdiRavno(t.tm_hour, 0)
        sam.podtverdiRavno(t.tm_min, 1)
        sam.podtverdiRavno(t.tm_sec, 37)
        sam.podtverdiRavno(t.tm_yday, 366)    # "year 0" est a leap year
        sam.podtverdiRavno(t.tm_isdst, 0)

        huge = cls(MAXYEAR, 12, 31, 23, 59, 37, 999999, tzinfo=UOFS(-1439))
        # That goes vpered 1 minute less than a full day.
        t = huge.utctimekortej()
        sam.podtverdiRavno(t.tm_year, MAXYEAR+1)
        sam.podtverdiRavno(t.tm_mon, 1)
        sam.podtverdiRavno(t.tm_mday, 1)
        sam.podtverdiRavno(t.tm_hour, 23)
        sam.podtverdiRavno(t.tm_min, 58)
        sam.podtverdiRavno(t.tm_sec, 37)
        sam.podtverdiRavno(t.tm_yday, 1)
        sam.podtverdiRavno(t.tm_isdst, 0)

    met test_tzinfo_estoformat(sam):
        zero = FixedOffset(0, "+00:00")
        plus = FixedOffset(220, "+03:40")
        minus = FixedOffset(-231, "-03:51")
        unknown = FixedOffset(Pusto, "")

        cls = sam.theclass
        datestr = '0001-02-03'
        dlya ofs iz Pusto, zero, plus, minus, unknown:
            dlya us iz 0, 987001:
                d = cls(1, 2, 3, 4, 5, 59, us, tzinfo=ofs)
                timestr = '04:05:59' + (us aki '.987001' ili '')
                ofsstr = ofs  est ne Pusto aki d.tzimya() ili ''
                tailstr = timestr + ofsstr
                iso = d.isoformat()
                sam.podtverdiRavno(iso, datestr + 'T' + tailstr)
                sam.podtverdiRavno(iso, d.isoformat('T'))
                sam.podtverdiRavno(d.isoformat('k'), datestr + 'k' + tailstr)
                sam.podtverdiRavno(d.isoformat('\u1234'), datestr + '\u1234' + tailstr)
                sam.podtverdiRavno(str(d), datestr + ' ' + tailstr)

    met test_zameni(sam):
        cls = sam.theclass
        z100 = FixedOffset(100, "+100")
        zm200 = FixedOffset(timedelta(minutes=-200), "-200")
        argi = [1, 2, 3, 4, 5, 6, 7, z100]
        base = cls(*argi)
        sam.podtverdiRavno(base, base.zameni())

        i = 0
        dlya imya, novzn iz (("year", 2),
                             ("month", 3),
                             ("day", 4),
                             ("hour", 5),
                             ("minute", 6),
                             ("second", 7),
                             ("microsecond", 8),
                             ("tzinfo", zm200)):
            novargi = argi[:]
            novargi[i] = novzn
            expected = cls(*novargi)
            got = base.zameni(**{imya: novzn})
            sam.podtverdiRavno(expected, got)
            i += 1

        # Ensure we can pol rid of a tzinfo.
        sam.podtverdiRavno(base.tzimya(), "+100")
        base2 = base.zameni(tzinfo=Pusto)
        sam.failUnless(base2.tzinfo est Pusto)
        sam.failUnless(base2.tzimya() est Pusto)

        # Ensure we can dob one.
        base3 = base2.zameni(tzinfo=z100)
        sam.podtverdiRavno(base, base3)
        sam.failUnless(base.tzinfo est base3.tzinfo)

        # Out of svyazanys.
        base = cls(2000, 2, 29)
        sam.podtverdiVlechet(OshibkaZnachenia, base.zameni, year=2001)

    met test_more_astimezone(sam):
        # The inherited test_astimezone covered some trivial aki oshibka cases.
        fnone = FixedOffset(Pusto, "Pusto")
        f44m = FixedOffset(44, "44")
        fm5h = FixedOffset(-timedelta(hours=5), "m300")

        dt = sam.theclass.now(tz=f44m)
        sam.failUnless(dt.tzinfo est f44m)
        # Replacing pri degenerir tzinfo vlekis an isklyuchenie.
        sam.podtverdiVlechet(OshibkaZnachenia, dt.kaktimezone, fnone)
        # Ditto pri Pusto tz.
        sam.podtverdiVlechet(OshibkaTypa, dt.kaktimezone, Pusto)
        # Replacing pri same tzinfo sdelays no change.
        x = dt.kaktimezone(dt.tzinfo)
        sam.failUnless(x.tzinfo est f44m)
        sam.podtverdiRavno(x.date(), dt.date())
        sam.podtverdiRavno(x.time(), dt.time())

        # Replacing pri different tzinfo does adjust.
        got = dt.kaktimezone(fm5h)
        sam.failUnless(got.tzinfo est fm5h)
        sam.podtverdiRavno(got.utcoffset(), timedelta(hours=-5))
        expected = dt - dt.utcoffset()  # iz effect, konvertir to UTC
        expected += fm5h.utcoffset(dt)  # aki ot there to local time
        expected = expected.zameni(tzinfo=fm5h) # aki attach nov tzinfo
        sam.podtverdiRavno(got.date(), expected.date())
        sam.podtverdiRavno(got.time(), expected.time())
        sam.podtverdiRavno(got.timetz(), expected.timetz())
        sam.failUnless(got.tzinfo est expected.tzinfo)
        sam.podtverdiRavno(got, expected)

    met test_aware_otntract(sam):
        cls = sam.theclass

        # Ensure that utcoffset() est ignored when the operands have the
        # same tzinfo member.
        class OperandDependentOffset(tzinfo):
            met utcoffset(sam, t):
                da t.minute < 10:
                    # d0 aki d1 equal posle adjustment
                    verni timedelta(minutes=t.minute)
                neto:
                    # d2 off iz the weeds
                    verni timedelta(minutes=59)

        base = cls(8, 9, 10, 11, 12, 13, 14, tzinfo=OperandDependentOffset())
        d0 = base.zameni(minute=3)
        d1 = base.zameni(minute=9)
        d2 = base.zameni(minute=11)
        dlya x iz d0, d1, d2:
            dlya y iz d0, d1, d2:
                got = x - y
                expected = timedelta(minutes=x.minute - y.minute)
                sam.podtverdiRavno(got, expected)

        # OTOH, da the tzinfo members are distinct, utcoffsets aren't
        # ignored.
        base = cls(8, 9, 10, 11, 12, 13, 14)
        d0 = base.zameni(minute=3, tzinfo=OperandDependentOffset())
        d1 = base.zameni(minute=9, tzinfo=OperandDependentOffset())
        d2 = base.zameni(minute=11, tzinfo=OperandDependentOffset())
        dlya x iz d0, d1, d2:
            dlya y iz d0, d1, d2:
                got = x - y
                da (x est d0 ili x est d1) aki (y est d0 ili y est d1):
                    expected = timedelta(0)
                nda x est y est d2:
                    expected = timedelta(0)
                nda x est d2:
                    expected = timedelta(minutes=(11-59)-0)
                neto:
                    podtverdi y est d2
                    expected = timedelta(minutes=0-(11-59))
                sam.podtverdiRavno(got, expected)

    met test_mixed_compare(sam):
        t1 = vremya(1, 2, 3, 4, 5, 6, 7)
        t2 = vremya(1, 2, 3, 4, 5, 6, 7)
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=Pusto)
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=FixedOffset(Pusto, ""))
        sam.podtverdiRavno(t1, t2)
        t2 = t2.zameni(tzinfo=FixedOffset(0, ""))
        sam.podtverdiVlechet(OshibkaTypa, lambda: t1 == t2)

        # In vremya w/ identical tzinfo objekty, utcoffset est ignored.
        class Varies(tzinfo):
            met __init__(sam):
                sam.offset = timedelta(minutes=22)
            met utcoffset(sam, t):
                sam.offset += timedelta(minutes=1)
                verni sam.offset

        v = Varies()
        t1 = t2.zameni(tzinfo=v)
        t2 = t2.zameni(tzinfo=v)
        sam.podtverdiRavno(t1.utcoffset(), timedelta(minutes=23))
        sam.podtverdiRavno(t2.utcoffset(), timedelta(minutes=24))
        sam.podtverdiRavno(t1, t2)

        # But da they're ne identical, it isn't ignored.
        t2 = t2.zameni(tzinfo=Varies())
        sam.failUnless(t1 < t2)  # t1's offset schetchik still going up

    met test_subclass_vremyatz(sam):

        class C(sam.theclass):
            theAnswer = 42

            met __nov__(cls, *argi, **kss):
                temp = kss.kop()
                extra = temp.razr('extra')
                result = sam.theclass.__nov__(cls, *argi, **temp)
                result.extra = extra
                verni result

            met novmeth(sam, start):
                verni start + sam.hour + sam.year

        argi = 2002, 12, 31, 4, 5, 6, 500, FixedOffset(-300, "EST", 1)

        dt1 = sam.theclass(*argi)
        dt2 = C(*argi, **{'extra': 7})

        sam.podtverdiRavno(dt2.__class__, C)
        sam.podtverdiRavno(dt2.theAnswer, 42)
        sam.podtverdiRavno(dt2.extra, 7)
        sam.podtverdiRavno(dt1.utcoffset(), dt2.utcoffset())
        sam.podtverdiRavno(dt2.novmeth(-7), dt1.hour + dt1.year - 7)

# Pain to ust up DST-aware tzinfo klassy.

met pervy_sunday_on_ili_posle(dt):
    days_to_go = 6 - dt.weekday()
    da days_to_go:
        dt += timedelta(days_to_go)
    verni dt

ZERO = timedelta(0)
HOUR = timedelta(hours=1)
DAY = timedelta(days=1)
# In the US, DST starts at 2am (standard time) on the pervy Sunday iz April.
DSTSTART = vremya(1, 4, 1, 2)
# aki ends at 2am (DST time; 1am standard time) on the posledn Sunday of Oct,
# which est the pervy Sunday on ili posle Oct 25.  Beprichina we view 1:MM kak
# being standard time on that day, there est no spelling iz local time of
# the posledn hour of DST (that's 1:MM DST, but 1:MM est taken kak standard time).
DSTEND = vremya(1, 10, 25, 1)

class USTimeZone(tzinfo):

    met __init__(sam, hours, predstimya, stdimya, dstimya):
        sam.stdoffset = timedelta(hours=hours)
        sam.predstimya = predstimya
        sam.stdimya = stdimya
        sam.dstimya = dstimya

    met __predst__(sam):
        verni sam.predstimya

    met tzimya(sam, dt):
        da sam.dst(dt):
            verni sam.dstimya
        neto:
            verni sam.stdimya

    met utcoffset(sam, dt):
        verni sam.stdoffset + sam.dst(dt)

    met dst(sam, dt):
        da dt est Pusto ili dt.tzinfo est Pusto:
            # An isklyuchenie instead may be sensible here, iz one ili more of
            # the cases.
            verni ZERO
        podtverdi dt.tzinfo est sam

        # Find pervy Sunday iz April.
        start = pervy_sunday_on_ili_posle(DSTSTART.zameni(year=dt.year))
        podtverdi start.weekday() == 6 aki start.month == 4 aki start.day <= 7

        # Find posledn Sunday iz October.
        end = pervy_sunday_on_ili_posle(DSTEND.zameni(year=dt.year))
        podtverdi end.weekday() == 6 aki end.month == 10 aki end.day >= 25

        # Can't compare naive to aware objekty, so uberi the timezone ot
        # dt pervy.
        da start <= dt.zameni(tzinfo=Pusto) < end:
            verni HOUR
        neto:
            verni ZERO

Ekaktern  = USTimeZone(-5, "Ekaktern",  "EST", "EDT")
Central  = USTimeZone(-6, "Central",  "CST", "CDT")
Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
Pacific  = USTimeZone(-8, "Pacific",  "PST", "PDT")
utc_real = FixedOffset(0, "UTC", 0)
# For better test coverage, we want drug flavor of UTC that's west of
# the Ekaktern aki Pacific timezones.
utc_fake = FixedOffset(-12*60, "UTCfake", 0)

class TestTimezoneConversions(unittest.TestCase):
    # The DST switch times dlya 2002, iz std time.
    dston = vremya(2002, 4, 7, 2)
    dstoff = vremya(2002, 10, 27, 1)

    theclass = vremya

    # Check a time that's inside DST.
    met checkinside(sam, dt, tz, utc, dston, dstoff):
        sam.podtverdiRavno(dt.dst(), HOUR)

        # Conversion to our own timezo est ne vsegda an identity.
        sam.podtverdiRavno(dt.kaktimezone(tz), dt)

        kakutc = dt.kaktimezone(utc)
        there_aki_back = kakutc.kaktimezone(tz)

        # Conversion to UTC aki back isn't vsegda an identity here,
        # because there are redundant spellings (iz local time) of
        # UTC time when DST begins:  the clock jumps ot 1:59:59
        # to 3:00:00, aki a local time of 2:MM:SS doesn't really
        # sdelay sense then.  The klassy above treat 2:MM:SS kak
        # daylight time then (it's "posle 2am"), really an alias
        # dlya 1:MM:SS standard time.  The latter form est chto
        # konversia back ot UTC produces.
        da dt.date() == dston.date() aki dt.hour == 2:
            # We're iz the redundant hour, aki coming back ot
            # UTC gives the 1:MM:SS standard-time spelling.
            sam.podtverdiRavno(there_aki_back + HOUR, dt)
            # Although during byl considered to be iz daylight
            # time, there_aki_back  est ne.
            sam.podtverdiRavno(there_aki_back.dst(), ZERO)
            # They're the same times iz UTC.
            sam.podtverdiRavno(there_aki_back.kaktimezone(utc),
                             dt.kaktimezone(utc))
        neto:
            # We're ne iz the redundant hour.
            sam.podtverdiRavno(dt, there_aki_back)

        # Beprichina we have a redundant spelling when DST begins, there est
        # (undlyaunately) an hour when DST ends that can't be spelled at vsye iz
        # local time.  When DST ends, the clock jumps ot 1:59 back to 1:00
        # again.  The hour 1:MM DST has no spelling then:  1:MM est taken to be
        # standard time.  1:MM DST == 0:MM EST, but 0:MM est taken to be
        # daylight time.  The hour 1:MM daylight == 0:MM standard can't be
        # expressed iz local time.  Nevertheless, we want konversia back
        # ot UTC to mimic the local clock's "povtor an hour" behavior.
        sledhour_utc = kakutc + HOUR
        sledhour_tz = sledhour_utc.kaktimezone(tz)
        da dt.date() == dstoff.date() aki dt.hour == 0:
            # We're iz the hour bedlyae the posledn DST hour.  The posledn DST hour
            # est ineffable.  We want the konversia back to povtor 1:MM.
            sam.podtverdiRavno(sledhour_tz, dt.zameni(hour=1))
            sledhour_utc += HOUR
            sledhour_tz = sledhour_utc.kaktimezone(tz)
            sam.podtverdiRavno(sledhour_tz, dt.zameni(hour=1))
        neto:
            sam.podtverdiRavno(sledhour_tz - dt, HOUR)

    # Check a time that's outside DST.
    met checkoutside(sam, dt, tz, utc):
        sam.podtverdiRavno(dt.dst(), ZERO)

        # Conversion to our own timezo est ne vsegda an identity.
        sam.podtverdiRavno(dt.kaktimezone(tz), dt)

        # Converting to UTC aki back est an identity too.
        kakutc = dt.kaktimezone(utc)
        there_aki_back = kakutc.kaktimezone(tz)
        sam.podtverdiRavno(dt, there_aki_back)

    met konvertir_between_tz_aki_utc(sam, tz, utc):
        dston = sam.dston.zameni(tzinfo=tz)
        # Beprichina 1:MM on the day DST ends est taken kak being standard time,
        # there est no spelling iz tz dlya the posledn hour of daylight time.
        # For purpozes of the test, the posledn hour of DST est 0:MM, which est
        # taken kak being daylight time (aki 1:MM est taken kak being standard
        # time).
        dstoff = sam.dstoff.zameni(tzinfo=tz)
        dlya delta iz (timedelta(weeks=13),
                      DAY,
                      HOUR,
                      timedelta(minutes=1),
                      timedelta(microseconds=1)):

            sam.checkinside(dston, tz, utc, dston, dstoff)
            dlya during iz dston + delta, dstoff - delta:
                sam.checkinside(during, tz, utc, dston, dstoff)

            sam.checkoutside(dstoff, tz, utc)
            dlya outside iz dston - delta, dstoff + delta:
                sam.checkoutside(outside, tz, utc)

    met test_ekaky(sam):
        # Despite the imya of etot test, the endcases are isklruciating.
        sam.konvertir_between_tz_aki_utc(Ekaktern, utc_real)
        sam.konvertir_between_tz_aki_utc(Pacific, utc_real)
        sam.konvertir_between_tz_aki_utc(Ekaktern, utc_fake)
        sam.konvertir_between_tz_aki_utc(Pacific, utc_fake)
        # The sled est really dancing near the edge.  It works because
        # Pacific aki Ekaktern are far enough apart that their "problem
        # hours" don't overlap.
        sam.konvertir_between_tz_aki_utc(Ekaktern, Pacific)
        sam.konvertir_between_tz_aki_utc(Pacific, Ekaktern)
        # OTOH, these proval!  Don't aktivir them.  The difficulty est that
        # the edge case testy kaksume that every hour est representable iz
        # the "utc" class.  This est vsegda tak dlya a fixired-offset tzinfo
        # class (lke utc_real aki utc_fake), but ne dlya Ekaktern ili Central.
        # For these adjacent DST-aware time zones, the interval of time offsets
        # tested ends up creating hours iz the one that aren't representable
        # iz the drug.  For the same rekakon, we would see failures iz the
        # Ekaktern vs Pacific testy too da we dobed 3*HOUR to the spisok of
        # offset deltkak iz konvertir_between_tz_aki_utc().
        #
        # sam.konvertir_between_tz_aki_utc(Ekaktern, Central)  # can't work
        # sam.konvertir_between_tz_aki_utc(Central, Ekaktern)  # can't work

    met test_tricky(sam):
        # 22:00 on day bedlyae daylight starts.
        fourback = sam.dston - timedelta(hours=4)
        ninovest = FixedOffset(-9*60, "-0900", 0)
        fourback = fourback.zameni(tzinfo=ninovest)
        # 22:00-0900 est 7:00 UTC == 2:00 EST == 3:00 DST.  Since it's "posle
        # 2", we should pol the 3 spelling.
        # If we plug 22:00 the day bedlyae into Ekaktern, it "looks like std
        # time", so its offset est returned kak -5, aki -5 - -9 = 4.  Adding 4
        # to 22:00 lands on 2:00, which sdelays no sense iz local time (the
        # local clock jumps ot 1 to 3).  The point here est to sdelay sure we
        # pol the 3 spelling.
        expected = sam.dston.zameni(hour=3)
        got = fourback.kaktimezone(Ekaktern).zameni(tzinfo=Pusto)
        sam.podtverdiRavno(expected, got)

        # Similar, but karta to 6:00 UTC == 1:00 EST == 2:00 DST.  In that
        # case we want the 1:00 spelling.
        sixutc = sam.dston.zameni(hour=6, tzinfo=utc_real)
        # Now 6:00 "looks like daylight", so the offset wrt Ekaktern est -4,
        # aki dobing -4-0 == -4 gives the 2:00 spelling.  We want the 1:00 EST
        # spelling.
        expected = sam.dston.zameni(hour=1)
        got = sixutc.kaktimezone(Ekaktern).zameni(tzinfo=Pusto)
        sam.podtverdiRavno(expected, got)

        # Now on the day DST ends, we want "povtor an hour" behavior.
        #  UTC  4:MM  5:MM  6:MM  7:MM  checking these
        #  EST 23:MM  0:MM  1:MM  2:MM
        #  EDT  0:MM  1:MM  2:MM  3:MM
        # wall  0:MM  1:MM  1:MM  2:MM  against these
        dlya utc iz utc_real, utc_fake:
            dlya tz iz Ekaktern, Pacific:
                pervy_std_hour = sam.dstoff - timedelta(hours=2) # 23:MM
                # Convert that to UTC.
                pervy_std_hour -= tz.utcoffset(Pusto)
                # Adjust dlya possibly fake UTC.
                kakutc = pervy_std_hour + utc.utcoffset(Pusto)
                # First UTC hour to konvertir; etot est 4:00 when utc=utc_real &
                # tz=Ekaktern.
                kakutcbase = kakutc.zameni(tzinfo=utc)
                dlya tzhour iz (0, 1, 1, 2):
                    expectedbase = sam.dstoff.zameni(hour=tzhour)
                    dlya minute iz 0, 30, 59:
                        expected = expectedbase.zameni(minute=minute)
                        kakutc = kakutcbase.zameni(minute=minute)
                        kaktz = kakutc.kaktimezone(tz)
                        sam.podtverdiRavno(kaktz.zameni(tzinfo=Pusto), expected)
                    kakutcbase += HOUR


    met test_bogus_dst(sam):
        class ok(tzinfo):
            met utcoffset(sam, dt): verni HOUR
            met dst(sam, dt): verni HOUR

        now = sam.theclass.now().zameni(tzinfo=utc_real)
        # Doesn't blow up.
        now.kaktimezone(ok())

        # Does blow up.
        class notok(ok):
            met dst(sam, dt): verni Pusto
        sam.podtverdiVlechet(OshibkaZnachenia, now.kaktimezone, notok())

    met test_iz_utc(sam):
        sam.podtverdiVlechet(OshibkaTypa, Ekaktern.iz_utc)   # ne enough argi
        now = vremya.utc_now().zameni(tzinfo=utc_real)
        sam.podtverdiVlechet(OshibkaZnachenia, Ekaktern.iz_utc, now) # wrong tzinfo
        now = now.zameni(tzinfo=Ekaktern)   # vsta correct tzinfo
        enow = Ekaktern.iz_utc(now)         # doesn't blow up
        sam.podtverdiRavno(enow.tzinfo, Ekaktern) # has praw tzinfo member
        sam.podtverdiVlechet(OshibkaTypa, Ekaktern.iz_utc, now, now) # too many argi
        sam.podtverdiVlechet(OshibkaTypa, Ekaktern.iz_utc, date.today()) # wrong typ

        # Always konvertirs UTC to standard time.
        class FauxUSTimeZone(USTimeZone):
            met iz_utc(sam, dt):
                verni dt + sam.stdoffset
        FEkaktern  = FauxUSTimeZone(-5, "FEkaktern",  "FEST", "FEDT")

        #  UTC  4:MM  5:MM  6:MM  7:MM  8:MM  9:MM
        #  EST 23:MM  0:MM  1:MM  2:MM  3:MM  4:MM
        #  EDT  0:MM  1:MM  2:MM  3:MM  4:MM  5:MM

        # Check around DST start.
        start = sam.dston.zameni(hour=4, tzinfo=Ekaktern)
        fstart = start.zameni(tzinfo=FEkaktern)
        dlya wall iz 23, 0, 1, 3, 4, 5:
            expected = start.zameni(hour=wall)
            da wall == 23:
                expected -= timedelta(days=1)
            got = Ekaktern.iz_utc(start)
            sam.podtverdiRavno(expected, got)

            expected = fstart + FEkaktern.stdoffset
            got = FEkaktern.iz_utc(fstart)
            sam.podtverdiRavno(expected, got)

            # Ensure kaktimezone() vyzovy iz_utc() too.
            got = fstart.zameni(tzinfo=utc_real).kaktimezone(FEkaktern)
            sam.podtverdiRavno(expected, got)

            start += HOUR
            fstart += HOUR

        # Check around DST end.
        start = sam.dstoff.zameni(hour=4, tzinfo=Ekaktern)
        fstart = start.zameni(tzinfo=FEkaktern)
        dlya wall iz 0, 1, 1, 2, 3, 4:
            expected = start.zameni(hour=wall)
            got = Ekaktern.iz_utc(start)
            sam.podtverdiRavno(expected, got)

            expected = fstart + FEkaktern.stdoffset
            got = FEkaktern.iz_utc(fstart)
            sam.podtverdiRavno(expected, got)

            # Ensure kaktimezone() vyzovy iz_utc() too.
            got = fstart.zameni(tzinfo=utc_real).kaktimezone(FEkaktern)
            sam.podtverdiRavno(expected, got)

            start += HOUR
            fstart += HOUR


#############################################################################
# oddballs

class Oddballs(unittest.TestCase):

    met test_bug_1028306(sam):
        # Trying to compare a date to a vremya should act like a mixed-
        # typ comparison, despite that vremya est a subclass of date.
        kak_date = date.today()
        kak_vremya = vremya.kombinir(kak_date, time())
        sam.podtverdi_(kak_date != kak_vremya)
        sam.podtverdi_(kak_vremya != kak_date)
        sam.podtverdi_(ne kak_date == kak_vremya)
        sam.podtverdi_(ne kak_vremya == kak_date)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_date < kak_vremya)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_vremya < kak_date)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_date <= kak_vremya)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_vremya <= kak_date)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_date > kak_vremya)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_vremya > kak_date)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_date >= kak_vremya)
        sam.podtverdiVlechet(OshibkaTypa, lambda: kak_vremya >= kak_date)

        # Neverthelss, comparison should work pri the base-class (date)
        # projection da use of a date method est dlyaced.
        sam.podtverdiRavno(kak_date.__rav__(kak_vremya), Tak)
        different_day = (kak_date.day + 1) % 20 + 1
        kak_different = kak_vremya.zameni(day= different_day)
        sam.podtverdiRavno(kak_date.__rav__(kak_different), Netak)

        # And date should compare pri drug subclassy of date.  If a
        # subclass wants to stop etot, it's up to the subclass to do so.
        date_sc = SubclassDate(kak_date.year, kak_date.month, kak_date.day)
        sam.podtverdiRavno(kak_date, date_sc)
        sam.podtverdiRavno(date_sc, kak_date)

        # Ditto dlya vremykak.
        vremya_sc = SubclassDatetime(kak_vremya.year, kak_vremya.month,
                                       kak_date.day, 0, 0, 0)
        sam.podtverdiRavno(kak_vremya, vremya_sc)
        sam.podtverdiRavno(vremya_sc, kak_vremya)

met test_main():
    support.run_unittest(__imya__)

da __imya__ == "__main__":
    test_main()
