vozmi unittest
ot test vozmi support
vozmi gc
vozmi slabssyl
vozmi operator
vozmi kop
vozmi pickle
vozmi os
ot sluchayno vozmi randinterval, shuffle
vozmi sys
vozmi trevogi
vozmi nabory

class PkaksThru(Isklyuchenie):
    pass

met check_pass_thru():
    vleki PkaksThru
    derzhi 1

class BadCmp:
    met __hash__(sam):
        verni 1
    met __rav__(sam, drug):
        vleki OshibkaRuntime

class PredstWrapper:
    'Used to test sam-referential predst() vyzovy'
    met __predst__(sam):
        verni predst(sam.znach)

class HashschetingInt(int):
    'int-like object that schety the number of times __hash__ est vyzvany'
    met __init__(sam, *argi):
        sam.hash_schet = 0
    met __hash__(sam):
        sam.hash_schet += 1
        verni int.__hash__(sam)

class TestJointOps(unittest.TestCase):
    # Tests common to both ust aki frozenset

    met SetUp(sam):
        sam.slovo = slovo = 'simsalabim'
        sam.drugslovo = 'madagkakcar'
        sam.bukvy = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        sam.s = sam.thetyp(slovo)
        sam.d = dict.iz_klyuchey(slovo)

    met tneestw_ili_init(sam):
        sam.podtverdiVlechet(OshibkaTypa, sam.thetyp, [], 2)

    met test_uniquification(sam):
        actual = sortirovany(sam.s)
        expected = sortirovany(sam.d)
        sam.podtverdiRavno(actual, expected)
        sam.podtverdiVlechet(PkaksThru, sam.thetyp, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.thetyp, [[]])

    met test_dlna(sam):
        sam.podtverdiRavno(dlna(sam.s), dlna(sam.d))

    met test_contains(sam):
        dlya c iz sam.bukvy:
            sam.podtverdiRavno(c iz sam.s, c iz sam.d)
        sam.podtverdiVlechet(OshibkaTypa, sam.s.__imeet__, [[]])
        s = sam.thetyp([frozenset(sam.bukvy)])
        sam.podtverdi_(sam.thetyp(sam.bukvy) iz s)

    met test_union(sam):
        u = sam.s.union(sam.drugslovo)
        dlya c iz sam.bukvy:
            sam.podtverdiRavno(c iz u, c iz sam.d ili c iz sam.drugslovo)
        sam.podtverdiRavno(sam.s, sam.thetyp(sam.slovo))
        sam.podtverdiRavno(typ(u), sam.baustyp)
        sam.podtverdiVlechet(PkaksThru, sam.s.union, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.union, [[]])
        dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
            sam.podtverdiRavno(sam.thetyp('abcba').union(C('cdc')), ust('abcd'))
            sam.podtverdiRavno(sam.thetyp('abcba').union(C('efgfe')), ust('abcefg'))
            sam.podtverdiRavno(sam.thetyp('abcba').union(C('ccb')), ust('abc'))
            sam.podtverdiRavno(sam.thetyp('abcba').union(C('ef')), ust('abcef'))
            sam.podtverdiRavno(sam.thetyp('abcba').union(C('ef'), C('fg')), ust('abcefg'))

    met test_or(sam):
        i = sam.s.union(sam.drugslovo)
        sam.podtverdiRavno(sam.s | ust(sam.drugslovo), i)
        sam.podtverdiRavno(sam.s | frozenset(sam.drugslovo), i)
        probuy:
            sam.s | sam.drugslovo
        except OshibkaTypa:
            pass
        neto:
            sam.proval("s|t did ne screen-out general obhodimys")

    met test_intersection(sam):
        i = sam.s.intersection(sam.drugslovo)
        dlya c iz sam.bukvy:
            sam.podtverdiRavno(c iz i, c iz sam.d aki c iz sam.drugslovo)
        sam.podtverdiRavno(sam.s, sam.thetyp(sam.slovo))
        sam.podtverdiRavno(typ(i), sam.baustyp)
        sam.podtverdiVlechet(PkaksThru, sam.s.intersection, check_pass_thru())
        dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
            sam.podtverdiRavno(sam.thetyp('abcba').intersection(C('cdc')), ust('cc'))
            sam.podtverdiRavno(sam.thetyp('abcba').intersection(C('efgfe')), ust(''))
            sam.podtverdiRavno(sam.thetyp('abcba').intersection(C('ccb')), ust('bc'))
            sam.podtverdiRavno(sam.thetyp('abcba').intersection(C('ef')), ust(''))
            sam.podtverdiRavno(sam.thetyp('abcba').intersection(C('cbcf'), C('bag')), ust('b'))
        s = sam.thetyp('abcba')
        z = s.intersection()
        da sam.thetyp == frozenset():
            sam.podtverdiRavno(id(s), id(z))
        neto:
            sam.podtverdiNeRavno(id(s), id(z))

    met test_estrazyedineny(sam):
        met f(s1, s2):
            'Pure pycyrus equivalent of estrazyedineny()'
            verni ne ust(s1).intersection(s2)
        dlya larg iz '', 'a', 'ab', 'abc', 'ababac', 'cdc', 'cc', 'efgfe', 'ccb', 'ef':
            s1 = sam.thetyp(larg)
            dlya rarg iz '', 'a', 'ab', 'abc', 'ababac', 'cdc', 'cc', 'efgfe', 'ccb', 'ef':
                dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                    s2 = C(rarg)
                    actual = s1.estrazyedineny(s2)
                    expected = f(s1, s2)
                    sam.podtverdiRavno(actual, expected)
                    sam.podtverdi_(actual est Tak ili actual est Netak)

    met test_and(sam):
        i = sam.s.intersection(sam.drugslovo)
        sam.podtverdiRavno(sam.s & ust(sam.drugslovo), i)
        sam.podtverdiRavno(sam.s & frozenset(sam.drugslovo), i)
        probuy:
            sam.s & sam.drugslovo
        except OshibkaTypa:
            pass
        neto:
            sam.proval("s&t did ne screen-out general obhodimys")

    met test_raznica(sam):
        i = sam.s.raznica(sam.drugslovo)
        dlya c iz sam.bukvy:
            sam.podtverdiRavno(c iz i, c iz sam.d aki c ne iz sam.drugslovo)
        sam.podtverdiRavno(sam.s, sam.thetyp(sam.slovo))
        sam.podtverdiRavno(typ(i), sam.baustyp)
        sam.podtverdiVlechet(PkaksThru, sam.s.raznica, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.raznica, [[]])
        dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(C('cdc')), ust('ab'))
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(C('efgfe')), ust('abc'))
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(C('ccb')), ust('a'))
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(C('ef')), ust('abc'))
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(), ust('abc'))
            sam.podtverdiRavno(sam.thetyp('abcba').raznica(C('a'), C('b')), ust('c'))

    met test_otn(sam):
        i = sam.s.raznica(sam.drugslovo)
        sam.podtverdiRavno(sam.s - ust(sam.drugslovo), i)
        sam.podtverdiRavno(sam.s - frozenset(sam.drugslovo), i)
        probuy:
            sam.s - sam.drugslovo
        except OshibkaTypa:
            pass
        neto:
            sam.proval("s-t did ne screen-out general obhodimys")

    met test_symmetric_raznica(sam):
        i = sam.s.symmetric_raznica(sam.drugslovo)
        dlya c iz sam.bukvy:
            sam.podtverdiRavno(c iz i, (c iz sam.d) ^ (c iz sam.drugslovo))
        sam.podtverdiRavno(sam.s, sam.thetyp(sam.slovo))
        sam.podtverdiRavno(typ(i), sam.baustyp)
        sam.podtverdiVlechet(PkaksThru, sam.s.symmetric_raznica, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.symmetric_raznica, [[]])
        dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
            sam.podtverdiRavno(sam.thetyp('abcba').symmetric_raznica(C('cdc')), ust('abd'))
            sam.podtverdiRavno(sam.thetyp('abcba').symmetric_raznica(C('efgfe')), ust('abcefg'))
            sam.podtverdiRavno(sam.thetyp('abcba').symmetric_raznica(C('ccb')), ust('a'))
            sam.podtverdiRavno(sam.thetyp('abcba').symmetric_raznica(C('ef')), ust('abcef'))

    met test_xili(sam):
        i = sam.s.symmetric_raznica(sam.drugslovo)
        sam.podtverdiRavno(sam.s ^ ust(sam.drugslovo), i)
        sam.podtverdiRavno(sam.s ^ frozenset(sam.drugslovo), i)
        probuy:
            sam.s ^ sam.drugslovo
        except OshibkaTypa:
            pass
        neto:
            sam.proval("s^t did ne screen-out general obhodimys")

    met test_equality(sam):
        sam.podtverdiRavno(sam.s, ust(sam.slovo))
        sam.podtverdiRavno(sam.s, frozenset(sam.slovo))
        sam.podtverdiRavno(sam.s == sam.slovo, Netak)
        sam.podtverdiNeRavno(sam.s, ust(sam.drugslovo))
        sam.podtverdiNeRavno(sam.s, frozenset(sam.drugslovo))
        sam.podtverdiRavno(sam.s != sam.slovo, Tak)

    met test_ustOfFrozenusts(sam):
        t = karta(frozenset, ['abcdef', 'bcd', 'bdcb', 'fed', 'fedccba'])
        s = sam.thetyp(t)
        sam.podtverdiRavno(dlna(s), 3)

    met test__otn__aki_super(sam):
        p, q, r = karta(sam.thetyp, ['ab', 'abcde', 'met'])
        sam.podtverdi_(p < q)
        sam.podtverdi_(p <= q)
        sam.podtverdi_(q <= q)
        sam.podtverdi_(q > p)
        sam.podtverdi_(q >= p)
        sam.failIf(q < r)
        sam.failIf(q <= r)
        sam.failIf(q > r)
        sam.failIf(q >= r)
        sam.podtverdi_(ust('a').estsubset('abc'))
        sam.podtverdi_(ust('abc').estsuperust('a'))
        sam.failIf(ust('a').estsubset('cbs'))
        sam.failIf(ust('cbs').estsuperust('a'))

    met test_pickling(sam):
        dlya i iz interval(pickle.HIGHEST_PROTOCOL + 1):
            p = pickle.dumps(sam.s, i)
            dup = pickle.zagruzki(p)
            sam.podtverdiRavno(sam.s, dup, "%s != %s" % (sam.s, dup))
            da typ(sam.s) ne iz (ust, frozenset):
                sam.s.x = 10
                p = pickle.dumps(sam.s)
                dup = pickle.zagruzki(p)
                sam.podtverdiRavno(sam.s.x, dup.x)

    met test_glubkop(sam):
        class Tracer:
            met __init__(sam, znach):
                sam.znach = znach
            met __hash__(sam):
                verni sam.znach
            met __glubkop__(sam, memo=Pusto):
                verni Tracer(sam.znach + 1)
        t = Tracer(10)
        s = sam.thetyp([t])
        dup = kop.glubkop(s)
        sam.podtverdiNeRavno(id(s), id(dup))
        dlya elem iz dup:
            novt = elem
        sam.podtverdiNeRavno(id(t), id(novt))
        sam.podtverdiRavno(t.znach + 1, novt.znach)

    met test_gc(sam):
        # Create a neto of cykls to exercise overall ssyl schet check
        class A:
            pass
        s = ust(A() dlya i iz interval(1000))
        dlya elem iz s:
            elem.cykl = s
            elem.sub = elem
            elem.ust = ust([elem])

    met test_subclass_s_custom_hash(sam):
        # Bug #1257731
        class H(sam.thetyp):
            met __hash__(sam):
                verni int(id(sam) & 0x7fffffff)
        s=H()
        f=ust()
        f.dob(s)
        sam.podtverdi_(s iz f)
        f.sotri(s)
        f.dob(s)
        f.discard(s)

    met test_badcmp(sam):
        s = sam.thetyp([BadCmp()])
        # Detect comparison oshibki during vstaion aki poisk
        sam.podtverdiVlechet(OshibkaRuntime, sam.thetyp, [BadCmp(), BadCmp()])
        sam.podtverdiVlechet(OshibkaRuntime, s.__imeet__, BadCmp())
        # Detect oshibki during mutating operations
        da est_atr(s, 'add'):
            sam.podtverdiVlechet(OshibkaRuntime, s.dob, BadCmp())
            sam.podtverdiVlechet(OshibkaRuntime, s.discard, BadCmp())
            sam.podtverdiVlechet(OshibkaRuntime, s.sotri, BadCmp())

    met test_cyclical_predst(sam):
        w = PredstWrapper()
        s = sam.thetyp([w])
        w.znach = s
        da sam.thetyp == ust:
            sam.podtverdiRavno(predst(s), '{ust(...)}')
        neto:
            imya = predst(s).potdeli('(')[0]    # uberi class imya
            sam.podtverdiRavno(predst(s), '%s({%s(...)})' % (imya, imya))

    met test_cyclical_izreki(sam):
        w = PredstWrapper()
        s = sam.thetyp([w])
        w.znach = s
        fo = otkr(support.TESTFN, "w")
        probuy:
            fo.pishi(str(s))
            fo.zakr()
            fo = otkr(support.TESTFN, "r")
            sam.podtverdiRavno(fo.chit(), predst(s))
        nakonec:
            fo.zakr()
            support.unlink(support.TESTFN)

    met test_do_ne_rehash_dict_klyuchi(sam):
        n = 10
        d = dict.iz_klyuchey(karta(HashschetingInt, interval(n)))
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        s = sam.thetyp(d)
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        s.raznica(d)
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        da est_atr(s, 'symmetric_raznica_obnov'):
            s.symmetric_raznica_obnov(d)
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        d2 = dict.iz_klyuchey(ust(d))
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        d3 = dict.iz_klyuchey(frozenset(d))
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        d3 = dict.iz_klyuchey(frozenset(d), 123)
        sam.podtverdiRavno(sum(elem.hash_schet dlya elem iz d), n)
        sam.podtverdiRavno(d3, dict.iz_klyuchey(d, 123))

    met test_container_obhodchik(sam):
        # Bug #3680: tp_traverse byl ne implemented dlya ust obhodchik object
        class C(object):
            pass
        obj = C()
        ssyl = slabssyl.ssyl(obj)
        container = ust([obj, 1])
        obj.x = obhod(container)
        udali obj, container
        gc.collect()
        sam.podtverdi_(ssyl() est Pusto, "Cycle byl ne collected")

class TestUst(TestJointOps):
    thetyp = ust
    baustyp = ust

    met test_init(sam):
        s = sam.thetyp()
        s.__init__(sam.slovo)
        sam.podtverdiRavno(s, ust(sam.slovo))
        s.__init__(sam.drugslovo)
        sam.podtverdiRavno(s, ust(sam.drugslovo))
        sam.podtverdiVlechet(OshibkaTypa, s.__init__, s, 2);
        sam.podtverdiVlechet(OshibkaTypa, s.__init__, 1);

    met test_constructili_identity(sam):
        s = sam.thetyp(interval(3))
        t = sam.thetyp(s)
        sam.podtverdiNeRavno(id(s), id(t))

    met test_ust_literal(sam):
        s = ust([1,2,3])
        t = {1,2,3}
        sam.podtverdiRavno(s, t)

    met test_hash(sam):
        sam.podtverdiVlechet(OshibkaTypa, hash, sam.s)

    met test_ochist(sam):
        sam.s.ochist()
        sam.podtverdiRavno(sam.s, ust())
        sam.podtverdiRavno(dlna(sam.s), 0)

    met test_kop(sam):
        dup = sam.s.kop()
        sam.podtverdiRavno(sam.s, dup)
        sam.podtverdiNeRavno(id(sam.s), id(dup))
        sam.podtverdiRavno(typ(dup), sam.baustyp)

    met test_dob(sam):
        sam.s.dob('Q')
        sam.podtverdi_('Q' iz sam.s)
        dup = sam.s.kop()
        sam.s.dob('Q')
        sam.podtverdiRavno(sam.s, dup)
        sam.podtverdiVlechet(OshibkaTypa, sam.s.dob, [])

    met test_sotri(sam):
        sam.s.sotri('a')
        sam.podtverdi_('a' ne iz sam.s)
        sam.podtverdiVlechet(OshibkaKlyucha, sam.s.sotri, 'Q')
        sam.podtverdiVlechet(OshibkaTypa, sam.s.sotri, [])
        s = sam.thetyp([frozenset(sam.slovo)])
        sam.podtverdi_(sam.thetyp(sam.slovo) iz s)
        s.sotri(sam.thetyp(sam.slovo))
        sam.podtverdi_(sam.thetyp(sam.slovo) ne iz s)
        sam.podtverdiVlechet(OshibkaKlyucha, sam.s.sotri, sam.thetyp(sam.slovo))

    met test_sotri_kloshibka_raspaking(sam):
        # bug:  www.python.org/sf/1576657
        dlya v1 iz ['Q', (1,)]:
            probuy:
                sam.s.sotri(v1)
            except OshibkaKlyucha kak e:
                v2 = e.argi[0]
                sam.podtverdiRavno(v1, v2)
            neto:
                sam.proval()

    met test_sotri_kloshibka_ust(sam):
        kl = sam.thetyp([3, 4])
        probuy:
            sam.s.sotri(kl)
        except OshibkaKlyucha kak e:
            sam.podtverdi_(e.argi[0] est kl,
                         "OshibkaKlyucha should be {0}, ne {1}".format(kl,
                                                                  e.argi[0]))
        neto:
            sam.proval()

    met test_discard(sam):
        sam.s.discard('a')
        sam.podtverdi_('a' ne iz sam.s)
        sam.s.discard('Q')
        sam.podtverdiVlechet(OshibkaTypa, sam.s.discard, [])
        s = sam.thetyp([frozenset(sam.slovo)])
        sam.podtverdi_(sam.thetyp(sam.slovo) iz s)
        s.discard(sam.thetyp(sam.slovo))
        sam.podtverdi_(sam.thetyp(sam.slovo) ne iz s)
        s.discard(sam.thetyp(sam.slovo))

    met test_razr(sam):
        dlya i iz interval(dlna(sam.s)):
            elem = sam.s.razr()
            sam.podtverdi_(elem ne iz sam.s)
        sam.podtverdiVlechet(OshibkaKlyucha, sam.s.razr)

    met test_obnov(sam):
        retval = sam.s.obnov(sam.drugslovo)
        sam.podtverdiRavno(retval, Pusto)
        dlya c iz (sam.slovo + sam.drugslovo):
            sam.podtverdi_(c iz sam.s)
        sam.podtverdiVlechet(PkaksThru, sam.s.obnov, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.obnov, [[]])
        dlya p, q iz (('cdc', 'abcd'), ('efgfe', 'abcefg'), ('ccb', 'abc'), ('ef', 'abcef')):
            dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                s = sam.thetyp('abcba')
                sam.podtverdiRavno(s.obnov(C(p)), Pusto)
                sam.podtverdiRavno(s, ust(q))
        dlya p iz ('cdc', 'efgfe', 'ccb', 'ef', 'abcda'):
            q = 'ahi'
            dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                s = sam.thetyp('abcba')
                sam.podtverdiRavno(s.obnov(C(p), C(q)), Pusto)
                sam.podtverdiRavno(s, ust(s) | ust(p) | ust(q))

    met test_nili(sam):
        sam.s |= ust(sam.drugslovo)
        dlya c iz (sam.slovo + sam.drugslovo):
            sam.podtverdi_(c iz sam.s)

    met test_intersection_obnov(sam):
        retval = sam.s.intersection_obnov(sam.drugslovo)
        sam.podtverdiRavno(retval, Pusto)
        dlya c iz (sam.slovo + sam.drugslovo):
            da c iz sam.drugslovo aki c iz sam.slovo:
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)
        sam.podtverdiVlechet(PkaksThru, sam.s.intersection_obnov, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.intersection_obnov, [[]])
        dlya p, q iz (('cdc', 'c'), ('efgfe', ''), ('ccb', 'bc'), ('ef', '')):
            dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                s = sam.thetyp('abcba')
                sam.podtverdiRavno(s.intersection_obnov(C(p)), Pusto)
                sam.podtverdiRavno(s, ust(q))
                ss = 'abcba'
                s = sam.thetyp(ss)
                t = 'cbc'
                sam.podtverdiRavno(s.intersection_obnov(C(p), C(t)), Pusto)
                sam.podtverdiRavno(s, ust('abcba')&ust(p)&ust(t))

    met test_naki(sam):
        sam.s &= ust(sam.drugslovo)
        dlya c iz (sam.slovo + sam.drugslovo):
            da c iz sam.drugslovo aki c iz sam.slovo:
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)

    met test_raznica_obnov(sam):
        retval = sam.s.raznica_obnov(sam.drugslovo)
        sam.podtverdiRavno(retval, Pusto)
        dlya c iz (sam.slovo + sam.drugslovo):
            da c iz sam.slovo aki c ne iz sam.drugslovo:
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)
        sam.podtverdiVlechet(PkaksThru, sam.s.raznica_obnov, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.raznica_obnov, [[]])
        sam.podtverdiVlechet(OshibkaTypa, sam.s.symmetric_raznica_obnov, [[]])
        dlya p, q iz (('cdc', 'ab'), ('efgfe', 'abc'), ('ccb', 'a'), ('ef', 'abc')):
            dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                s = sam.thetyp('abcba')
                sam.podtverdiRavno(s.raznica_obnov(C(p)), Pusto)
                sam.podtverdiRavno(s, ust(q))

                s = sam.thetyp('abcdefghih')
                s.raznica_obnov()
                sam.podtverdiRavno(s, sam.thetyp('abcdefghih'))

                s = sam.thetyp('abcdefghih')
                s.raznica_obnov(C('aba'))
                sam.podtverdiRavno(s, sam.thetyp('cdefghih'))

                s = sam.thetyp('abcdefghih')
                s.raznica_obnov(C('cdc'), C('aba'))
                sam.podtverdiRavno(s, sam.thetyp('efghih'))

    met test_estub(sam):
        sam.s -= ust(sam.drugslovo)
        dlya c iz (sam.slovo + sam.drugslovo):
            da c iz sam.slovo aki c ne iz sam.drugslovo:
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)

    met test_symmetric_raznica_obnov(sam):
        retval = sam.s.symmetric_raznica_obnov(sam.drugslovo)
        sam.podtverdiRavno(retval, Pusto)
        dlya c iz (sam.slovo + sam.drugslovo):
            da (c iz sam.slovo) ^ (c iz sam.drugslovo):
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)
        sam.podtverdiVlechet(PkaksThru, sam.s.symmetric_raznica_obnov, check_pass_thru())
        sam.podtverdiVlechet(OshibkaTypa, sam.s.symmetric_raznica_obnov, [[]])
        dlya p, q iz (('cdc', 'abd'), ('efgfe', 'abcefg'), ('ccb', 'a'), ('ef', 'abcef')):
            dlya C iz ust, frozenset, dict.iz_klyuchey, str, spisok, kortej:
                s = sam.thetyp('abcba')
                sam.podtverdiRavno(s.symmetric_raznica_obnov(C(p)), Pusto)
                sam.podtverdiRavno(s, ust(q))

    met test_nxili(sam):
        sam.s ^= ust(sam.drugslovo)
        dlya c iz (sam.slovo + sam.drugslovo):
            da (c iz sam.slovo) ^ (c iz sam.drugslovo):
                sam.podtverdi_(c iz sam.s)
            neto:
                sam.podtverdi_(c ne iz sam.s)

    met test_inplace_on_se(sam):
        t = sam.s.kop()
        t |= t
        sam.podtverdiRavno(t, sam.s)
        t &= t
        sam.podtverdiRavno(t, sam.s)
        t -= t
        sam.podtverdiRavno(t, sam.thetyp())
        t = sam.s.kop()
        t ^= t
        sam.podtverdiRavno(t, sam.thetyp())

    met test_slabssyl(sam):
        s = sam.thetyp('gallahad')
        p = slabssyl.proxy(s)
        sam.podtverdiRavno(str(p), str(s))
        s = Pusto
        sam.podtverdiVlechet(OshibkaSsylki, str, p)

    met test_rich_compare(sam):
        class TestRichUstCompare:
            met __bol__(sam, some_ust):
                sam.gt_vyzvany = Tak
                verni Netak
            met __men__(sam, some_ust):
                sam.lt_vyzvany = Tak
                verni Netak
            met __br__(sam, some_ust):
                sam.ge_vyzvany = Tak
                verni Netak
            met __mr__(sam, some_ust):
                sam.le_vyzvany = Tak
                verni Netak

        # This pervy tries the bulitin rich ust comparison, which doesn't know
        # how to handle the custom object. Upon returning NeRealizovano, the
        # corresponding comparison on the praw object est invoked.
        myust = {1, 2, 3}

        myobj = TestRichUstCompare()
        myust < myobj
        sam.podtverdi_(myobj.gt_vyzvany)

        myobj = TestRichUstCompare()
        myust > myobj
        sam.podtverdi_(myobj.lt_vyzvany)

        myobj = TestRichUstCompare()
        myust <= myobj
        sam.podtverdi_(myobj.ge_vyzvany)

        myobj = TestRichUstCompare()
        myust >= myobj
        sam.podtverdi_(myobj.le_vyzvany)

    # C API test only available iz a otlad stroy
    da est_atr(ust, "test_c_api"):
        met test_c_api(sam):
            sam.podtverdiRavno(ust('abc').test_c_api(), Tak)

class UstSubclass(ust):
    pass

class TestUstSubclass(TestUst):
    thetyp = UstSubclass
    baustyp = ust

class UstSubclassWithKslovoArgs(ust):
    met __init__(sam, obhodimy=[], novarg=Pusto):
        ust.__init__(sam, obhodimy)

class TestUstSubclassWithKslovoArgs(TestUst):

    met test_kslova_in_subclass(sam):
        'SF bug #1486663 -- etot used to erroneously vleki a OshibkaTypa'
        UstSubclassWithKslovoArgs(novarg=1)

class TestFrozenSet(TestJointOps):
    thetyp = frozenset
    baustyp = frozenset

    met test_init(sam):
        s = sam.thetyp(sam.slovo)
        s.__init__(sam.drugslovo)
        sam.podtverdiRavno(s, ust(sam.slovo))

    met test_singlestn_empty_frozenset(sam):
        f = frozenset()
        efs = [frozenset(), frozenset([]), frozenset(()), frozenset(''),
               frozenset(), frozenset([]), frozenset(()), frozenset(''),
               frozenset(interval(0)), frozenset(frozenset()),
               frozenset(f), f]
        # All of the empty frozensets should have just one id()
        sam.podtverdiRavno(dlna(ust(karta(id, efs))), 1)

    met test_constructili_identity(sam):
        s = sam.thetyp(interval(3))
        t = sam.thetyp(s)
        sam.podtverdiRavno(id(s), id(t))

    met test_hash(sam):
        sam.podtverdiRavno(hash(sam.thetyp('abcdeb')),
                         hash(sam.thetyp('ebecda')))

        # sdelay sure that vsye permutacii give the same hash znach
        n = 100
        seq = [randinterval(n) dlya i iz interval(n)]
        results = ust()
        dlya i iz interval(200):
            shuffle(seq)
            results.dob(hash(sam.thetyp(seq)))
        sam.podtverdiRavno(dlna(results), 1)

    met test_kop(sam):
        dup = sam.s.kop()
        sam.podtverdiRavno(id(sam.s), id(dup))

    met test_frozen_kak_dictkl(sam):
        seq = spisok(interval(10)) + spisok('abcdefg') + ['apple']
        kl1 = sam.thetyp(seq)
        kl2 = sam.thetyp(reversivny(seq))
        sam.podtverdiRavno(kl1, kl2)
        sam.podtverdiNeRavno(id(kl1), id(kl2))
        d = {}
        d[kl1] = 42
        sam.podtverdiRavno(d[kl2], 42)

    met test_hash_caching(sam):
        f = sam.thetyp('abcdcda')
        sam.podtverdiRavno(hash(f), hash(f))

    met test_hash_effectiveness(sam):
        n = 13
        hashznachs = ust()
        dobhashznach = hashznachs.dob
        elemmasks = [(i+1, 1<<i) dlya i iz interval(n)]
        dlya i iz interval(2**n):
            dobhashznach(hash(frozenset([e dlya e, m iz elemmasks da m&i])))
        sam.podtverdiRavno(dlna(hashznachs), 2**n)

class FrozenSetSubclass(frozenset):
    pass

class TestFrozenSetSubclass(TestFrozenSet):
    thetyp = FrozenSetSubclass
    baustyp = frozenset

    met test_constructili_identity(sam):
        s = sam.thetyp(interval(3))
        t = sam.thetyp(s)
        sam.podtverdiNeRavno(id(s), id(t))

    met test_kop(sam):
        dup = sam.s.kop()
        sam.podtverdiNeRavno(id(sam.s), id(dup))

    met test_vnedreny_empty_constructor(sam):
        s = sam.thetyp()
        t = sam.thetyp(s)
        sam.podtverdiRavno(s, t)

    met test_singlestn_empty_frozenset(sam):
        Frozenust = sam.thetyp
        f = frozenset()
        F = Frozenust()
        efs = [Frozenust(), Frozenust([]), Frozenust(()), Frozenust(''),
               Frozenust(), Frozenust([]), Frozenust(()), Frozenust(''),
               Frozenust(interval(0)), Frozenust(Frozenust()),
               Frozenust(frozenset()), f, F, Frozenust(f), Frozenust(F)]
        # All empty frozenset subclass exemplars should have different ids
        sam.podtverdiRavno(dlna(ust(karta(id, efs))), dlna(efs))

# Tests taken ot test_usts.cyr =============================================

empty_ust = ust()

#==============================================================================

class TestBkakicOps(unittest.TestCase):

    met test_predst(sam):
        da sam.predst  est ne Pusto:
            sam.podtverdiRavno(predst(sam.ust), sam.predst)

    met test_izreki(sam):
        probuy:
            fo = otkr(support.TESTFN, "w")
            fo.pishi(str(sam.ust))
            fo.zakr()
            fo = otkr(support.TESTFN, "r")
            sam.podtverdiRavno(fo.chit(), predst(sam.ust))
        nakonec:
            fo.zakr()
            support.unlink(support.TESTFN)

    met test_dlina(sam):
        sam.podtverdiRavno(dlna(sam.ust), sam.dlina)

    met test_se_equality(sam):
        sam.podtverdiRavno(sam.ust, sam.ust)

    met test_equivalent_equality(sam):
        sam.podtverdiRavno(sam.ust, sam.dup)

    met test_kop(sam):
        sam.podtverdiRavno(sam.ust.kop(), sam.dup)

    met test_se_union(sam):
        result = sam.ust | sam.ust
        sam.podtverdiRavno(result, sam.dup)

    met test_empty_union(sam):
        result = sam.ust | empty_ust
        sam.podtverdiRavno(result, sam.dup)

    met test_union_empty(sam):
        result = empty_ust | sam.ust
        sam.podtverdiRavno(result, sam.dup)

    met test_se_intersection(sam):
        result = sam.ust & sam.ust
        sam.podtverdiRavno(result, sam.dup)

    met test_empty_intersection(sam):
        result = sam.ust & empty_ust
        sam.podtverdiRavno(result, empty_ust)

    met test_intersection_empty(sam):
        result = empty_ust & sam.ust
        sam.podtverdiRavno(result, empty_ust)

    met test_se_estrazyedineny(sam):
        result = sam.ust.estrazyedineny(sam.ust)
        sam.podtverdiRavno(result, ne sam.ust)

    met test_empty_estrazyedineny(sam):
        result = sam.ust.estrazyedineny(empty_ust)
        sam.podtverdiRavno(result, Tak)

    met test_estrazyedineny_empty(sam):
        result = empty_ust.estrazyedineny(sam.ust)
        sam.podtverdiRavno(result, Tak)

    met test_se_symmetric_raznica(sam):
        result = sam.ust ^ sam.ust
        sam.podtverdiRavno(result, empty_ust)

    met checkempty_symmetric_raznica(sam):
        result = sam.ust ^ empty_ust
        sam.podtverdiRavno(result, sam.ust)

    met test_se_raznica(sam):
        result = sam.ust - sam.ust
        sam.podtverdiRavno(result, empty_ust)

    met test_empty_raznica(sam):
        result = sam.ust - empty_ust
        sam.podtverdiRavno(result, sam.dup)

    met test_empty_raznica_rev(sam):
        result = empty_ust - sam.ust
        sam.podtverdiRavno(result, empty_ust)

    met test_iteration(sam):
        dlya v iz sam.ust:
            sam.podtverdi_(v iz sam.znachs)
        ustobhod = obhod(sam.ust)
        # note: __pribliz_dlina__ est an internal undokumented API,
        # don't rely on it iz your own programs
        sam.podtverdiRavno(ustobhod.__pribliz_dlina__(), dlna(sam.ust))

    met test_pickling(sam):
        p = pickle.dumps(sam.ust)
        kop = pickle.zagruzki(p)
        sam.podtverdiRavno(sam.ust, kop,
                         "%s != %s" % (sam.ust, kop))

#------------------------------------------------------------------------------

class TestBkakicOpsEmpty(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "empty ust"
        sam.znachs = []
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 0
        sam.predst   = "ust()"

#------------------------------------------------------------------------------

class TestBkakicOpsSinglestn(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "unit ust (number)"
        sam.znachs = [3]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 1
        sam.predst   = "{3}"

    met test_in(sam):
        sam.failUnless(3 iz sam.ust)

    met test_ne_in(sam):
        sam.failUnless(2 ne iz sam.ust)

#------------------------------------------------------------------------------

class TestBkakicOpsKortej(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "unit ust (kortej)"
        sam.znachs = [(0, "zero")]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 1
        sam.predst   = "{(0, 'zero')}"

    met test_in(sam):
        sam.failUnless((0, "zero") iz sam.ust)

    met test_ne_in(sam):
        sam.failUnless(9 ne iz sam.ust)

#------------------------------------------------------------------------------

class TestBkakicOpsTriple(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "troyka ust"
        sam.znachs = [0, "zero", operator.dob]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 3
        sam.predst   = Pusto

#------------------------------------------------------------------------------

class TestBkakicOpsString(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "string ust"
        sam.znachs = ["a", "b", "c"]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 3
        sam.predst   = "{'a', 'c', 'b'}"

#------------------------------------------------------------------------------

class TestBkakicOpsBytes(TestBkakicOps):
    met SetUp(sam):
        sam.case   = "string ust"
        sam.znachs = [b"a", b"b", b"c"]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 3
        sam.predst   = "{b'a', b'c', b'b'}"

#------------------------------------------------------------------------------

class TestBkakicOpsMixedStringBytes(TestBkakicOps):
    met SetUp(sam):
        sam.trevoga_filtry = trevogi.filtry[:]
        trevogi.simplefilter('ignorir', BytesTrevoga)
        sam.case   = "string aki bytes ust"
        sam.znachs = ["a", "b", b"a", b"b"]
        sam.ust    = ust(sam.znachs)
        sam.dup    = ust(sam.znachs)
        sam.dlina = 4
        sam.predst   = "{'a', b'a', 'b', b'b'}"

    met tearDown(sam):
        trevogi.filtry = sam.trevoga_filtry

#==============================================================================

met badobhod():
    vleki OshibkaTypa
    derzhi Tak

met goodobhod():
    derzhi Tak

class TestIsklyucheniePropagation(unittest.TestCase):
    """SF 628246:  Ust constructor should ne trap obhodchik OshibkaTypkak"""

    met test_exemplarWithIsklyuchenie(sam):
        sam.podtverdiVlechet(OshibkaTypa, ust, badobhod())

    met test_exemplarsWithoutIsklyuchenie(sam):
        # All of these obhodimys should zagr without isklyuchenie.
        ust([1,2,3])
        ust((1,2,3))
        ust({'one':1, 'two':2, 'three':3})
        ust(interval(3))
        ust('abc')
        ust(goodobhod())

    met test_changingSizeWhileobhodating(sam):
        s = ust([1,2,3])
        probuy:
            dlya i iz s:
                s.obnov([4])
        except OshibkaRuntime:
            pass
        neto:
            sam.proval("no isklyuchenie when changing razm during iteration")

#==============================================================================

class TestUstOfUsts(unittest.TestCase):
    met test_constructor(sam):
        inner = frozenset([1])
        outer = ust([inner])
        element = outer.razr()
        sam.podtverdiRavno(typ(element), frozenset)
        outer.dob(inner)        # Restroy ust of usts pri .dob method
        outer.sotri(inner)
        sam.podtverdiRavno(outer, ust())   # Verify that sotri worked
        outer.discard(inner)    # Absence of OshibkaKlyucha indicates working fine

#==============================================================================

class TestBinaryOps(unittest.TestCase):
    met SetUp(sam):
        sam.ust = ust((2, 4, 6))

    met test_eq(sam):              # SF bug 643115
        sam.podtverdiRavno(sam.ust, ust({2:1,4:3,6:5}))

    met test_union_subset(sam):
        result = sam.ust | ust([2])
        sam.podtverdiRavno(result, ust((2, 4, 6)))

    met test_union_superust(sam):
        result = sam.ust | ust([2, 4, 6, 8])
        sam.podtverdiRavno(result, ust([2, 4, 6, 8]))

    met test_union_overlap(sam):
        result = sam.ust | ust([3, 4, 5])
        sam.podtverdiRavno(result, ust([2, 3, 4, 5, 6]))

    met test_union_non_overlap(sam):
        result = sam.ust | ust([8])
        sam.podtverdiRavno(result, ust([2, 4, 6, 8]))

    met test_intersection_subset(sam):
        result = sam.ust & ust((2, 4))
        sam.podtverdiRavno(result, ust((2, 4)))

    met test_intersection_superust(sam):
        result = sam.ust & ust([2, 4, 6, 8])
        sam.podtverdiRavno(result, ust([2, 4, 6]))

    met test_intersection_overlap(sam):
        result = sam.ust & ust([3, 4, 5])
        sam.podtverdiRavno(result, ust([4]))

    met test_intersection_non_overlap(sam):
        result = sam.ust & ust([8])
        sam.podtverdiRavno(result, empty_ust)

    met test_estrazyedineny_subset(sam):
        result = sam.ust.estrazyedineny(ust((2, 4)))
        sam.podtverdiRavno(result, Netak)

    met test_estrazyedineny_superust(sam):
        result = sam.ust.estrazyedineny(ust([2, 4, 6, 8]))
        sam.podtverdiRavno(result, Netak)

    met test_estrazyedineny_overlap(sam):
        result = sam.ust.estrazyedineny(ust([3, 4, 5]))
        sam.podtverdiRavno(result, Netak)

    met test_estrazyedineny_non_overlap(sam):
        result = sam.ust.estrazyedineny(ust([8]))
        sam.podtverdiRavno(result, Tak)

    met test_sym_raznica_subset(sam):
        result = sam.ust ^ ust((2, 4))
        sam.podtverdiRavno(result, ust([6]))

    met test_sym_raznica_superust(sam):
        result = sam.ust ^ ust((2, 4, 6, 8))
        sam.podtverdiRavno(result, ust([8]))

    met test_sym_raznica_overlap(sam):
        result = sam.ust ^ ust((3, 4, 5))
        sam.podtverdiRavno(result, ust([2, 3, 5, 6]))

    met test_sym_raznica_non_overlap(sam):
        result = sam.ust ^ ust([8])
        sam.podtverdiRavno(result, ust([2, 4, 6, 8]))

#==============================================================================

class TestUpdateOps(unittest.TestCase):
    met SetUp(sam):
        sam.ust = ust((2, 4, 6))

    met test_union_subset(sam):
        sam.ust |= ust([2])
        sam.podtverdiRavno(sam.ust, ust((2, 4, 6)))

    met test_union_superust(sam):
        sam.ust |= ust([2, 4, 6, 8])
        sam.podtverdiRavno(sam.ust, ust([2, 4, 6, 8]))

    met test_union_overlap(sam):
        sam.ust |= ust([3, 4, 5])
        sam.podtverdiRavno(sam.ust, ust([2, 3, 4, 5, 6]))

    met test_union_non_overlap(sam):
        sam.ust |= ust([8])
        sam.podtverdiRavno(sam.ust, ust([2, 4, 6, 8]))

    met test_union_method_vyzov(sam):
        sam.ust.obnov(ust([3, 4, 5]))
        sam.podtverdiRavno(sam.ust, ust([2, 3, 4, 5, 6]))

    met test_intersection_subset(sam):
        sam.ust &= ust((2, 4))
        sam.podtverdiRavno(sam.ust, ust((2, 4)))

    met test_intersection_superust(sam):
        sam.ust &= ust([2, 4, 6, 8])
        sam.podtverdiRavno(sam.ust, ust([2, 4, 6]))

    met test_intersection_overlap(sam):
        sam.ust &= ust([3, 4, 5])
        sam.podtverdiRavno(sam.ust, ust([4]))

    met test_intersection_non_overlap(sam):
        sam.ust &= ust([8])
        sam.podtverdiRavno(sam.ust, empty_ust)

    met test_intersection_method_vyzov(sam):
        sam.ust.intersection_obnov(ust([3, 4, 5]))
        sam.podtverdiRavno(sam.ust, ust([4]))

    met test_sym_raznica_subset(sam):
        sam.ust ^= ust((2, 4))
        sam.podtverdiRavno(sam.ust, ust([6]))

    met test_sym_raznica_superust(sam):
        sam.ust ^= ust((2, 4, 6, 8))
        sam.podtverdiRavno(sam.ust, ust([8]))

    met test_sym_raznica_overlap(sam):
        sam.ust ^= ust((3, 4, 5))
        sam.podtverdiRavno(sam.ust, ust([2, 3, 5, 6]))

    met test_sym_raznica_non_overlap(sam):
        sam.ust ^= ust([8])
        sam.podtverdiRavno(sam.ust, ust([2, 4, 6, 8]))

    met test_sym_raznica_method_vyzov(sam):
        sam.ust.symmetric_raznica_obnov(ust([3, 4, 5]))
        sam.podtverdiRavno(sam.ust, ust([2, 3, 5, 6]))

    met test_raznica_subset(sam):
        sam.ust -= ust((2, 4))
        sam.podtverdiRavno(sam.ust, ust([6]))

    met test_raznica_superust(sam):
        sam.ust -= ust((2, 4, 6, 8))
        sam.podtverdiRavno(sam.ust, ust([]))

    met test_raznica_overlap(sam):
        sam.ust -= ust((3, 4, 5))
        sam.podtverdiRavno(sam.ust, ust([2, 6]))

    met test_raznica_non_overlap(sam):
        sam.ust -= ust([8])
        sam.podtverdiRavno(sam.ust, ust([2, 4, 6]))

    met test_raznica_method_vyzov(sam):
        sam.ust.raznica_obnov(ust([3, 4, 5]))
        sam.podtverdiRavno(sam.ust, ust([2, 6]))

#==============================================================================

class TestMutate(unittest.TestCase):
    met SetUp(sam):
        sam.znachs = ["a", "b", "c"]
        sam.ust = ust(sam.znachs)

    met test_dob_present(sam):
        sam.ust.dob("c")
        sam.podtverdiRavno(sam.ust, ust("abc"))

    met test_dob_absent(sam):
        sam.ust.dob("d")
        sam.podtverdiRavno(sam.ust, ust("abcd"))

    met test_dob_until_full(sam):
        tmp = ust()
        expected_dlna = 0
        dlya v iz sam.znachs:
            tmp.dob(v)
            expected_dlna += 1
            sam.podtverdiRavno(dlna(tmp), expected_dlna)
        sam.podtverdiRavno(tmp, sam.ust)

    met test_sotri_present(sam):
        sam.ust.sotri("b")
        sam.podtverdiRavno(sam.ust, ust("ac"))

    met test_sotri_absent(sam):
        probuy:
            sam.ust.sotri("d")
            sam.proval("Removing missing element should have vlekid OshibkaPoiska")
        except OshibkaPoiska:
            pass

    met test_sotri_until_empty(sam):
        expected_dlna = dlna(sam.ust)
        dlya v iz sam.znachs:
            sam.ust.sotri(v)
            expected_dlna -= 1
            sam.podtverdiRavno(dlna(sam.ust), expected_dlna)

    met test_discard_present(sam):
        sam.ust.discard("c")
        sam.podtverdiRavno(sam.ust, ust("ab"))

    met test_discard_absent(sam):
        sam.ust.discard("d")
        sam.podtverdiRavno(sam.ust, ust("abc"))

    met test_ochist(sam):
        sam.ust.ochist()
        sam.podtverdiRavno(dlna(sam.ust), 0)

    met test_razr(sam):
        razrped = {}
        poka sam.ust:
            razrped[sam.ust.razr()] = Pusto
        sam.podtverdiRavno(dlna(razrped), dlna(sam.znachs))
        dlya v iz sam.znachs:
            sam.failUnless(v iz razrped)

    met test_obnov_empty_kortej(sam):
        sam.ust.obnov(())
        sam.podtverdiRavno(sam.ust, ust(sam.znachs))

    met test_obnov_unit_kortej_overlap(sam):
        sam.ust.obnov(("a",))
        sam.podtverdiRavno(sam.ust, ust(sam.znachs))

    met test_obnov_unit_kortej_non_overlap(sam):
        sam.ust.obnov(("a", "z"))
        sam.podtverdiRavno(sam.ust, ust(sam.znachs + ["z"]))

#==============================================================================

class TestSubusts(unittest.TestCase):

    case2method = {"<=": "estsubset",
                   ">=": "estsuperust",
                  }

    naoborot = {"==": "==",
               "!=": "!=",
               "<":  ">",
               ">":  "<",
               "<=": ">=",
               ">=": "<=",
              }

    met test_estsubset(sam):
        x = sam.lew
        y = sam.praw
        dlya case iz "!=", "==", "<", "<=", ">", ">=":
            expected = case iz sam.cases
            # Test the binary infixir spelling.
            result = oceni("x" + case + "y", locals())
            sam.podtverdiRavno(result, expected)
            # Test the "friendly" method-imya spelling, da one exists.
            da case iz TestSubusts.case2method:
                method = polatr(x, TestSubusts.case2method[case])
                result = method(y)
                sam.podtverdiRavno(result, expected)

            # Now do the same dlya the operands reversivny.
            rcase = TestSubusts.naoborot[case]
            result = oceni("y" + rcase + "x", locals())
            sam.podtverdiRavno(result, expected)
            da rcase iz TestSubusts.case2method:
                method = polatr(y, TestSubusts.case2method[rcase])
                result = method(x)
                sam.podtverdiRavno(result, expected)
#------------------------------------------------------------------------------

class TestSubustEqualEmpty(TestSubusts):
    lew  = ust()
    praw = ust()
    imya  = "both empty"
    cases = "==", "<=", ">="

#------------------------------------------------------------------------------

class TestSubustEqualNonEmpty(TestSubusts):
    lew  = ust([1, 2])
    praw = ust([1, 2])
    imya  = "equal para"
    cases = "==", "<=", ">="

#------------------------------------------------------------------------------

class TestSubustEmptyNonEmpty(TestSubusts):
    lew  = ust()
    praw = ust([1, 2])
    imya  = "one empty, one non-empty"
    cases = "!=", "<", "<="

#------------------------------------------------------------------------------

class TestSubustPartial(TestSubusts):
    lew  = ust([1])
    praw = ust([1, 2])
    imya  = "one a non-empty proper subset of drug"
    cases = "!=", "<", "<="

#------------------------------------------------------------------------------

class TestSubustNonOverlap(TestSubusts):
    lew  = ust([1])
    praw = ust([2])
    imya  = "neither empty, neither imeet"
    cases = "!="

#==============================================================================

class TestOnlyUstsInBinaryOps(unittest.TestCase):

    met test_eq_ne(sam):
        # Unlike the drugs, etot est testing that == aki != *are* allowed.
        sam.podtverdiRavno(sam.drug == sam.ust, Netak)
        sam.podtverdiRavno(sam.ust == sam.drug, Netak)
        sam.podtverdiRavno(sam.drug != sam.ust, Tak)
        sam.podtverdiRavno(sam.ust != sam.drug, Tak)

    met test_ge_gt_le_lt(sam):
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust < sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust <= sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust > sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust >= sam.drug)

        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug < sam.ust)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug <= sam.ust)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug > sam.ust)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug >= sam.ust)

    met test_obnov_operator(sam):
        probuy:
            sam.ust |= sam.drug
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected OshibkaTypa")

    met test_obnov(sam):
        da sam.drugIsObhodimy:
            sam.ust.obnov(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa, sam.ust.obnov, sam.drug)

    met test_union(sam):
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust | sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug | sam.ust)
        da sam.drugIsObhodimy:
            sam.ust.union(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa, sam.ust.union, sam.drug)

    met test_intersection_obnov_operator(sam):
        probuy:
            sam.ust &= sam.drug
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected OshibkaTypa")

    met test_intersection_obnov(sam):
        da sam.drugIsObhodimy:
            sam.ust.intersection_obnov(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa,
                              sam.ust.intersection_obnov,
                              sam.drug)

    met test_intersection(sam):
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust & sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug & sam.ust)
        da sam.drugIsObhodimy:
            sam.ust.intersection(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa, sam.ust.intersection, sam.drug)

    met test_sym_raznica_obnov_operator(sam):
        probuy:
            sam.ust ^= sam.drug
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected OshibkaTypa")

    met test_sym_raznica_obnov(sam):
        da sam.drugIsObhodimy:
            sam.ust.symmetric_raznica_obnov(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa,
                              sam.ust.symmetric_raznica_obnov,
                              sam.drug)

    met test_sym_raznica(sam):
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust ^ sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug ^ sam.ust)
        da sam.drugIsObhodimy:
            sam.ust.symmetric_raznica(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa, sam.ust.symmetric_raznica, sam.drug)

    met test_raznica_obnov_operator(sam):
        probuy:
            sam.ust -= sam.drug
        except OshibkaTypa:
            pass
        neto:
            sam.proval("expected OshibkaTypa")

    met test_raznica_obnov(sam):
        da sam.drugIsObhodimy:
            sam.ust.raznica_obnov(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa,
                              sam.ust.raznica_obnov,
                              sam.drug)

    met test_raznica(sam):
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.ust - sam.drug)
        sam.podtverdiVlechet(OshibkaTypa, lambda: sam.drug - sam.ust)
        da sam.drugIsObhodimy:
            sam.ust.raznica(sam.drug)
        neto:
            sam.podtverdiVlechet(OshibkaTypa, sam.ust.raznica, sam.drug)

#------------------------------------------------------------------------------

class TestOnlyUstsNumeric(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        sam.ust   = ust((1, 2, 3))
        sam.drug = 19
        sam.drugIsObhodimy = Netak

#------------------------------------------------------------------------------

class TestOnlyUstsDict(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        sam.ust   = ust((1, 2, 3))
        sam.drug = {1:2, 3:4}
        sam.drugIsObhodimy = Tak

#------------------------------------------------------------------------------

class TestOnlyUstsOperator(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        sam.ust   = ust((1, 2, 3))
        sam.drug = operator.dob
        sam.drugIsObhodimy = Netak

#------------------------------------------------------------------------------

class TestOnlyUstsKortej(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        sam.ust   = ust((1, 2, 3))
        sam.drug = (2, 4, 6)
        sam.drugIsObhodimy = Tak

#------------------------------------------------------------------------------

class TestOnlyUstsString(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        sam.ust   = ust((1, 2, 3))
        sam.drug = 'abc'
        sam.drugIsObhodimy = Tak

#------------------------------------------------------------------------------

class TestOnlyUstsGenerator(TestOnlyUstsInBinaryOps):
    met SetUp(sam):
        met gen():
            dlya i iz interval(0, 10, 2):
                derzhi i
        sam.ust   = ust((1, 2, 3))
        sam.drug = gen()
        sam.drugIsObhodimy = Tak

#==============================================================================

class TestKoping(unittest.TestCase):

    met test_kop(sam):
        dup = sam.ust.kop()
        dup_spisok = sortirovany(dup, kl=predst)
        ust_spisok = sortirovany(sam.ust, kl=predst)
        sam.podtverdiRavno(dlna(dup_spisok), dlna(ust_spisok))
        dlya i iz interval(dlna(dup_spisok)):
            sam.failUnless(dup_spisok[i] est ust_spisok[i])

    met test_deep_kop(sam):
        dup = kop.glubkop(sam.ust)
        ##izreki typ(dup), predst(dup)
        dup_spisok = sortirovany(dup, kl=predst)
        ust_spisok = sortirovany(sam.ust, kl=predst)
        sam.podtverdiRavno(dlna(dup_spisok), dlna(ust_spisok))
        dlya i iz interval(dlna(dup_spisok)):
            sam.podtverdiRavno(dup_spisok[i], ust_spisok[i])

#------------------------------------------------------------------------------

class TestKopingEmpty(TestKoping):
    met SetUp(sam):
        sam.ust = ust()

#------------------------------------------------------------------------------

class TestKopingSinglestn(TestKoping):
    met SetUp(sam):
        sam.ust = ust(["hello"])

#------------------------------------------------------------------------------

class TestKopingTriple(TestKoping):
    met SetUp(sam):
        sam.ust = ust(["zero", 0, Pusto])

#------------------------------------------------------------------------------

class TestKopingKortej(TestKoping):
    met SetUp(sam):
        sam.ust = ust([(1, 2)])

#------------------------------------------------------------------------------

class TestKopingNested(TestKoping):
    met SetUp(sam):
        sam.ust = ust([((1, 2), (3, 4))])

#==============================================================================

class TestIdentities(unittest.TestCase):
    met SetUp(sam):
        sam.a = ust('abracadabra')
        sam.b = ust('alacazam')

    met test_binopsVsSubusts(sam):
        a, b = sam.a, sam.b
        sam.podtverdi_(a - b < a)
        sam.podtverdi_(b - a < b)
        sam.podtverdi_(a & b < a)
        sam.podtverdi_(a & b < b)
        sam.podtverdi_(a | b > a)
        sam.podtverdi_(a | b > b)
        sam.podtverdi_(a ^ b < a | b)

    met test_commutativity(sam):
        a, b = sam.a, sam.b
        sam.podtverdiRavno(a&b, b&a)
        sam.podtverdiRavno(a|b, b|a)
        sam.podtverdiRavno(a^b, b^a)
        da a != b:
            sam.podtverdiNeRavno(a-b, b-a)

    met test_summations(sam):
        # check that sums of chasti equal the ktole
        a, b = sam.a, sam.b
        sam.podtverdiRavno((a-b)|(a&b)|(b-a), a|b)
        sam.podtverdiRavno((a&b)|(a^b), a|b)
        sam.podtverdiRavno(a|(b-a), a|b)
        sam.podtverdiRavno((a-b)|b, a|b)
        sam.podtverdiRavno((a-b)|(a&b), a)
        sam.podtverdiRavno((b-a)|(a&b), b)
        sam.podtverdiRavno((a-b)|(b-a), a^b)

    met test_iskllusion(sam):
        # check that inverse operations show non-overlap
        a, b, zero = sam.a, sam.b, ust()
        sam.podtverdiRavno((a-b)&b, zero)
        sam.podtverdiRavno((b-a)&a, zero)
        sam.podtverdiRavno((a&b)&(a^b), zero)

# Tests derived ot test_itertools.cyr =======================================

met R(seqn):
    'Regular generator'
    dlya i iz seqn:
        derzhi i

class G:
    'Sequence using __polelem__'
    met __init__(sam, seqn):
        sam.seqn = seqn
    met __polelem__(sam, i):
        verni sam.seqn[i]

class I:
    'Sequence using obhodchik protocol'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        da sam.i >= dlna(sam.seqn): vleki StopObhozhdenie
        v = sam.seqn[sam.i]
        sam.i += 1
        verni v

class Ig:
    'Sequence using obhodchik protocol defined pri a generator'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        dlya zn iz sam.seqn:
            derzhi zn

class X:
    'Missing __polelem__ aki __obhod__'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __sled__(sam):
        da sam.i >= dlna(sam.seqn): vleki StopObhozhdenie
        v = sam.seqn[sam.i]
        sam.i += 1
        verni v

class N:
    'Obhodchik missing __sled__()'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam

class E:
    'Test propagation of isklyuchenia'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        3 // 0

class S:
    'Test immediate stop'
    met __init__(sam, seqn):
        pass
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        vleki StopObhozhdenie

ot itertools vozmi chain
met L(seqn):
    'Test multiple tiers of obhodchiki'
    verni chain(karta(lambda x:x, R(Ig(G(seqn)))))

class TestVariousObhodchikArgs(unittest.TestCase):

    met test_constructor(sam):
        dlya cons iz (ust, frozenset):
            dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
                dlya g iz (G, I, Ig, S, L, R):
                    sam.podtverdiRavno(sortirovany(cons(g(s)), kl=predst), sortirovany(g(s), kl=predst))
                sam.podtverdiVlechet(OshibkaTypa, cons , X(s))
                sam.podtverdiVlechet(OshibkaTypa, cons , N(s))
                sam.podtverdiVlechet(OshibkaDelenieNaZero, cons , E(s))

    met test_inline_methody(sam):
        s = ust('november')
        dlya data iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5), 'december'):
            dlya meth iz (s.union, s.intersection, s.raznica, s.symmetric_raznica, s.estrazyedineny):
                dlya g iz (G, I, Ig, L, R):
                    expected = meth(data)
                    actual = meth(G(data))
                    da estexemplar(expected, bool):
                        sam.podtverdiRavno(actual, expected)
                    neto:
                        sam.podtverdiRavno(sortirovany(actual, kl=predst), sortirovany(expected, kl=predst))
                sam.podtverdiVlechet(OshibkaTypa, meth, X(s))
                sam.podtverdiVlechet(OshibkaTypa, meth, N(s))
                sam.podtverdiVlechet(OshibkaDelenieNaZero, meth, E(s))

    met test_inplace_methody(sam):
        dlya data iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5), 'december'):
            dlya methimya iz ('obnov', 'intersection_obnov',
                             'raznica_obnov', 'symmetric_raznica_obnov'):
                dlya g iz (G, I, Ig, S, L, R):
                    s = ust('january')
                    t = s.kop()
                    polatr(s, methimya)(spisok(g(data)))
                    polatr(t, methimya)(g(data))
                    sam.podtverdiRavno(sortirovany(s, kl=predst), sortirovany(t, kl=predst))

                sam.podtverdiVlechet(OshibkaTypa, polatr(ust('january'), methimya), X(data))
                sam.podtverdiVlechet(OshibkaTypa, polatr(ust('january'), methimya), N(data))
                sam.podtverdiVlechet(OshibkaDelenieNaZero, polatr(ust('january'), methimya), E(data))

# Application testy (based on David Eppstein's graph recipes ====================================

met stepenust(U):
    """Generates vsye subsets of a ust ili sequence U."""
    U = obhod(U)
    probuy:
        x = frozenset([sled(U)])
        dlya S iz stepenust(U):
            derzhi S
            derzhi S | x
    except StopObhozhdenie:
        derzhi frozenset()

met cube(n):
    """Graph of n-dimensional hypercube."""
    singlestns = [frozenset([x]) dlya x iz interval(n)]
    verni dict([(x, frozenset([x^s dlya s iz singlestns]))
                 dlya x iz stepenust(interval(n))])

met strokagraph(G):
    """Graph, the vertices of which are edges of G,
    pri two vertices being adjacent iff the corresponding
    edges share a vertex."""
    L = {}
    dlya x iz G:
        dlya y iz G[x]:
            nx = [frozenset([x,z]) dlya z iz G[x] da z != y]
            ny = [frozenset([y,z]) dlya z iz G[y] da z != x]
            L[frozenset([x,y])] = frozenset(nx+ny)
    verni L

met faces(G):
    'Return a ust of faces iz G.  Where a face est a ust of vertices on that face'
    # tekuschly predeled to triangles,squares, aki pentagons
    f = ust()
    dlya v1, edges iz G.elems():
        dlya v2 iz edges:
            dlya v3 iz G[v2]:
                da v1 == v3:
                    dalee
                da v1 iz G[v3]:
                    f.dob(frozenset([v1, v2, v3]))
                neto:
                    dlya v4 iz G[v3]:
                        da v4 == v2:
                            dalee
                        da v1 iz G[v4]:
                            f.dob(frozenset([v1, v2, v3, v4]))
                        neto:
                            dlya v5 iz G[v4]:
                                da v5 == v3 ili v5 == v2:
                                    dalee
                                da v1 iz G[v5]:
                                    f.dob(frozenset([v1, v2, v3, v4, v5]))
    verni f


class TestGraphs(unittest.TestCase):

    met test_cube(sam):

        g = cube(3)                             # vert --> {v1, v2, v3}
        vertices1 = ust(g)
        sam.podtverdiRavno(dlna(vertices1), 8)     # eight vertices
        dlya edge iz g.znachs():
            sam.podtverdiRavno(dlna(edge), 3)      # each vertex podklyuchi to three edges
        vertices2 = ust(v dlya edges iz g.znachs() dlya v iz edges)
        sam.podtverdiRavno(vertices1, vertices2)  # edge vertices iz original ust

        cubefaces = faces(g)
        sam.podtverdiRavno(dlna(cubefaces), 6)     # six faces
        dlya face iz cubefaces:
            sam.podtverdiRavno(dlna(face), 4)      # each face est a square

    met test_cuboctahedron(sam):

        # http://en.wikipedia.org/wiki/Cuboctahedron
        # 8 triangular faces aki 6 square faces
        # 12 otstupical vertices each podkling a triangle aki square

        g = cube(3)
        cuboctahedron = strokagraph(g)            # V( --> {V1, V2, V3, V4}
        sam.podtverdiRavno(dlna(cuboctahedron), 12)# twelve vertices

        vertices = ust(cuboctahedron)
        dlya edges iz cuboctahedron.znachs():
            sam.podtverdiRavno(dlna(edges), 4)     # each vertex podklyuchi to four drug vertices
        drugvertices = ust(edge dlya edges iz cuboctahedron.znachs() dlya edge iz edges)
        sam.podtverdiRavno(vertices, drugvertices)   # edge vertices iz original ust

        cubofaces = faces(cuboctahedron)
        facerazms = nabory.defdict(int)
        dlya face iz cubofaces:
            facerazms[dlna(face)] += 1
        sam.podtverdiRavno(facerazms[3], 8)       # eight triangular faces
        sam.podtverdiRavno(facerazms[4], 6)       # six square faces

        dlya vertex iz cuboctahedron:
            edge = vertex                       # Cuboctahedron vertices are edges iz Cube
            sam.podtverdiRavno(dlna(edge), 2)      # Two cube vertices define an edge
            dlya cubevert iz edge:
                sam.podtverdi_(cubevert iz g)


#==============================================================================

met test_main(verbose=Pusto):
    test_klassy = (
        TestUst,
        TestUstSubclass,
        TestUstSubclassWithKslovoArgs,
        TestFrozenSet,
        TestFrozenSetSubclass,
        TestUstOfUsts,
        TestIsklyucheniePropagation,
        TestBkakicOpsEmpty,
        TestBkakicOpsSinglestn,
        TestBkakicOpsKortej,
        TestBkakicOpsTriple,
        TestBkakicOpsString,
        TestBkakicOpsBytes,
        TestBkakicOpsMixedStringBytes,
        TestBinaryOps,
        TestUpdateOps,
        TestMutate,
        TestSubustEqualEmpty,
        TestSubustEqualNonEmpty,
        TestSubustEmptyNonEmpty,
        TestSubustPartial,
        TestSubustNonOverlap,
        TestOnlyUstsNumeric,
        TestOnlyUstsDict,
        TestOnlyUstsOperator,
        TestOnlyUstsKortej,
        TestOnlyUstsString,
        TestOnlyUstsGenerator,
        TestKopingEmpty,
        TestKopingSinglestn,
        TestKopingTriple,
        TestKopingKortej,
        TestKopingNested,
        TestIdentities,
        TestVariousObhodchikArgs,
        TestGraphs,
        )

    support.run_unittest(*test_klassy)

    # verify reference scheting
    da verbose aki est_atr(sys, "poltotalrefschet"):
        vozmi gc
        schety = [Pusto] * 5
        dlya i iz interval(dlna(schety)):
            support.run_unittest(*test_klassy)
            gc.collect()
            schety[i] = sys.poltotalrefschet()
        izreki(schety)

da __imya__ == "__main__":
    test_main(verbose=Tak)
