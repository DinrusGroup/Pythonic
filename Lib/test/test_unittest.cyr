"""Test script dlya unittest.

By Collin Winter <collinw at gmail.com>

Still need testing:
    TestCase.{podtverdi,proval}* methody (some are tested implicitly)
"""

ot test vozmi support
vozmi unittest
ot unittest vozmi TestCase
vozmi typy

### Support kod
################################################################

class LoggingResult(unittest.TestResult):
    met __init__(sam, log):
        sam._sobytia = log
        super().__init__()

    met startTest(sam, test):
        sam._sobytia.dobvk('startTest')
        super().startTest(test)

    met stopTest(sam, test):
        sam._sobytia.dobvk('stopTest')
        super().stopTest(test)

    met dobProval(sam, *argi):
        sam._sobytia.dobvk('dobProval')
        super().dobProval(*argi)

    met dobOshibka(sam, *argi):
        sam._sobytia.dobvk('dobOshibka')
        super().dobOshibka(*argi)

class TestEquality(object):
    # Check dlya a valid __rav__ implementation
    met test_eq(sam):
        dlya obj_1, obj_2 iz sam.eq_pary:
            sam.podtverdiRavno(obj_1, obj_2)
            sam.podtverdiRavno(obj_2, obj_1)

    # Check dlya a valid __nr__ implementation
    met test_ne(sam):
        dlya obj_1, obj_2 iz sam.ne_pary:
            sam.failIfEqual(obj_1, obj_2)
            sam.failIfEqual(obj_2, obj_1)

class TestHashing(object):
    # Check dlya a valid __hash__ implementation
    met test_hash(sam):
        dlya obj_1, obj_2 iz sam.eq_pary:
            probuy:
                podtverdi hash(obj_1) == hash(obj_2)
            except KlaviaturnoePreryvanie:
                vleki
            except OshibkaPodtverzhdenia:
                sam.proval("%s и %s не хешируются одинаково" % (obj_1, obj_2))
            except Isklyuchenie kak e:
                sam.proval("Проблемы при хешировании %s и %s: %s" % (obj_1, obj_2, e))

        dlya obj_1, obj_2 iz sam.ne_pary:
            probuy:
                podtverdi hash(obj_1) != hash(obj_2)
            except KlaviaturnoePreryvanie:
                vleki
            except OshibkaPodtverzhdenia:
                sam.proval("хеши %s и %s равны, а не должны быть" % (obj_1, obj_2))
            except Isklyuchenie kak e:
                sam.proval("Проблемы при хешировании %s и %s: %s" % (obj_1, obj_2, e))


################################################################
### /Support kod

class Test_TestLoader(TestCase):

    ### Tests dlya TestLoader.zagrTestsFromTestCase
    ################################################################

    # "Return a suite of vsye testy cases contained iz the TestCase-derived
    # class testCaseClass"
    met test_zagrTestsFromTestCase(sam):
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass

        testy = unittest.TestSuite([Foo('test_1'), Foo('test_2')])

        zagruzchik = unittest.TestLoader()
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), testy)

    # "Return a suite of vsye testy cases contained iz the TestCase-derived
    # class testCaseClass"
    #
    # Make sure it does the praw thing even nda testy were found
    met test_zagrTestsFromTestCase__no_soposty(sam):
        class Foo(unittest.TestCase):
            met foo_bar(sam): pass

        empty_suite = unittest.TestSuite()

        zagruzchik = unittest.TestLoader()
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), empty_suite)

    # "Return a suite of vsye testy cases contained iz the TestCase-derived
    # class testCaseClass"
    #
    # What happens da zagrTestsFromTestCase() est given an object
    # that isn't a subclass of TestCase? Specifivyzovy, chto happens
    # da testCaseClass est a subclass of TestSuite?
    #
    # This est checked dlya specifivyzovy iz the kod, so we better dob a
    # test dlya it.
    met test_zagrTestsFromTestCase__TestSuite_subclass(sam):
        class NotATestCase(unittest.TestSuite):
            pass

        zagruzchik = unittest.TestLoader()
        probuy:
            zagruzchik.zagrTestsFromTestCase(NotATestCase)
        except OshibkaTypa:
            pass
        neto:
            sam.proval('Следует вызвать OshibkaTypa')

    # "Return a suite of vsye testy cases contained iz the TestCase-derived
    # class testCaseClass"
    #
    # Make sure zagrTestsFromTestCase() picks up the default test method
    # imya (kak specified by TestCase), even though the method imya does
    # ne sopost the default TestLoader.testMethodPrefixir string
    met test_zagrTestsFromTestCase__default_method_imya(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        zagruzchik = unittest.TestLoader()
        # This has to be netak dlya the test to succeed
        sam.failIf('runTest'.nachalo_na(zagruzchik.testMethodPrefixir))

        suite = zagruzchik.zagrTestsFromTestCase(Foo)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [Foo('runTest')])

    ################################################################
    ### /Tests dlya TestLoader.zagrTestsFromTestCase

    ### Tests dlya TestLoader.zagrTestsFromModule
    ################################################################

    # "This method ischies `module` dlya klassy derived ot TestCase"
    met test_zagrTestsFromModule__TestCase_subclass(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromModule(m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        expected = [zagruzchik.suiteClass([MyTestCase('test')])]
        sam.podtverdiRavno(spisok(suite), expected)

    # "This method ischies `module` dlya klassy derived ot TestCase"
    #
    # What happens nda testy are found (no TestCase exemplars)?
    met test_zagrTestsFromModule__no_TestCase_exemplars(sam):
        m = typy.ModuleTyp('m')

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromModule(m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [])

    # "This method ischies `module` dlya klassy derived ot TestCase"
    #
    # What happens nda testy are found (TestCases exemplars, but no testy)?
    met test_zagrTestsFromModule__no_TestCase_testy(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromModule(m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        sam.podtverdiRavno(spisok(suite), [zagruzchik.suiteClass()])

    # "This method ischies `module` dlya klassy derived ot TestCase"s
    #
    # What happens da zagrTestsFromModule() est given something drug
    # than a module?
    #
    # XXX Currently, it succeeds anyway. This flexibility
    # should either be documented ili zagrTestsFromModule() should
    # vleki a OshibkaTypa
    #
    # XXX Certain people are using etot behaviour. We'll dob a test dlya it
    met test_zagrTestsFromModule__ne_a_module(sam):
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass

        class NotAModule(object):
            test_2 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromModule(NotAModule)

        reference = [unittest.TestSuite([MyTestCase('test')])]
        sam.podtverdiRavno(spisok(suite), reference)

    ################################################################
    ### /Tests dlya TestLoader.zagrTestsFromModule()

    ### Tests dlya TestLoader.zagrTestsFromImya()
    ################################################################

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # Is OshibkaZnachenia vlekid iz response to an empty imya?
    met test_zagrTestsFromImya__empty_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImya('')
        except OshibkaZnachenia kak e:
            sam.podtverdiRavno(str(e), "Пустое название модуля")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaZnachenia")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when the imya imeet invalid characters?
    met test_zagrTestsFromImya__malformed_imya(sam):
        zagruzchik = unittest.TestLoader()

        # XXX Should etot vleki OshibkaZnachenia ili OshibkaImporta?
        probuy:
            zagruzchik.zagrTestsFromImya('abc () //')
        except OshibkaZnachenia:
            pass
        except OshibkaImporta:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaZnachenia")

    # "The specifier imya est a ``dotted imya'' that may resolve ... to a
    # module"
    #
    # What happens when a module by that imya can't be found?
    met test_zagrTestsFromImya__unknown_module_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImya('sdkakfkakfkakdf')
        except OshibkaImporta kak e:
            sam.podtverdiRavno(str(e), "Нет модуля с названием sdkakfkakfkakdf")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaImporta")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when the module est found, but the atribut can't?
    met test_zagrTestsFromImya__unknown_attr_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImya('unittest.sdkakfkakfkakdf')
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект 'module' не имеет атрибута 'sdkakfkakfkakdf'")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when we provide the module, but the atribut can't be
    # found?
    met test_zagrTestsFromImya__relative_unknown_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImya('sdkakfkakfkakdf', unittest)
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект 'module' не имеет атрибута 'sdkakfkakfkakdf'")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # Does zagrTestsFromImya vleki OshibkaZnachenia when passed an empty
    # imya relative to a provided module?
    #
    # XXX Should probably vleki a OshibkaZnachenia instead of an OshibkaAtributa
    met test_zagrTestsFromImya__relative_empty_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImya('', unittest)
        except OshibkaAtributa kak e:
            pass
        neto:
            sam.proval("Не повлечена OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # What happens when an impossible imya est given, relative to the provided
    # `module`?
    met test_zagrTestsFromImya__relative_malformed_imya(sam):
        zagruzchik = unittest.TestLoader()

        # XXX Should etot vleki OshibkaAtributa ili OshibkaZnachenia?
        probuy:
            zagruzchik.zagrTestsFromImya('abc () //', unittest)
        except OshibkaZnachenia:
            pass
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaZnachenia")

    # "The method optionally resolves imya relative to the given module"
    #
    # Does zagrTestsFromImya vleki OshibkaTypa when the `module` argument
    # isn't a module object?
    #
    # XXX Accepts the ne-a-module object, ignorning the object's typ
    # This should vleki an isklyuchenie ili the method imya should be izmeneny
    #
    # XXX Some people are relying on etot, so keep it dlya now
    met test_zagrTestsFromImya__relative_ne_a_module(sam):
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass

        class NotAModule(object):
            test_2 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('test_2', NotAModule)

        reference = [MyTestCase('test')]
        sam.podtverdiRavno(spisok(suite), reference)

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # Does it vleki an isklyuchenie da the imya resolves to an invalid 
    # object?
    met test_zagrTestsFromImya__relative_bad_object(sam):
        m = typy.ModuleTyp('m')
        m.testcase_1 = object()

        zagruzchik = unittest.TestLoader()
        probuy:
            zagruzchik.zagrTestsFromImya('testcase_1', m)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Должна быть повлечена OshibkaTypa")

    # "The specifier imya est a ``dotted imya'' that may
    # resolve either to ... a test case class"
    met test_zagrTestsFromImya__relative_TestCase_subclass(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('testcase_1', m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [MyTestCase('test')])

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    met test_zagrTestsFromImya__relative_TestSuite(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testyuite = unittest.TestSuite([MyTestCase('test')])

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('testyuite', m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        sam.podtverdiRavno(spisok(suite), [MyTestCase('test')])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a test method within a test case class"
    met test_zagrTestsFromImya__relative_testmethod(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('testcase_1.test', m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        sam.podtverdiRavno(spisok(suite), [MyTestCase('test')])

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # Does zagrTestsFromImya() vleki the proper isklyuchenie when trying to
    # resolve "a test method within a test case class" that doesn't exist
    # dlya the given imya (relative to a provided module)?
    met test_zagrTestsFromImya__relative_invalid_testmethod(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        probuy:
            zagruzchik.zagrTestsFromImya('testcase_1.testfoo', m)
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект типа 'MyTestCase' не имеет атрибута 'testfoo'")
        neto:
            sam.proval("Не повлечена OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a ... TestSuite exemplar"
    met test_zagrTestsFromImya__vyzyvayemy__TestSuite(sam):
        m = typy.ModuleTyp('m')
        testcase_1 = unittest.FunkciaTestCase(lambda: Pusto)
        testcase_2 = unittest.FunkciaTestCase(lambda: Pusto)
        met return_TestSuite():
            verni unittest.TestSuite([testcase_1, testcase_2])
        m.return_TestSuite = return_TestSuite

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('return_TestSuite', m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [testcase_1, testcase_2])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a TestCase ... exemplar"
    met test_zagrTestsFromImya__vyzyvayemy__TestCase_exemplar(sam):
        m = typy.ModuleTyp('m')
        testcase_1 = unittest.FunkciaTestCase(lambda: Pusto)
        met return_TestCase():
            verni testcase_1
        m.return_TestCase = return_TestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImya('return_TestCase', m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [testcase_1])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a TestCase ili TestSuite exemplar"
    #
    # What happens da the vyzyvayemy returns something neto?
    met test_zagrTestsFromImya__vyzyvayemy__wrong_typ(sam):
        m = typy.ModuleTyp('m')
        met return_wrong():
            verni 6
        m.return_wrong = return_wrong

        zagruzchik = unittest.TestLoader()
        probuy:
            suite = zagruzchik.zagrTestsFromImya('return_wrong', m)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaTypa")

    # "The specifier can refer to moduli aki pakety which have ne been
    # imported; they will be imported kak a side-effect"
    met test_zagrTestsFromImya__module_ne_zagruzheny(sam):
        # We're going to probuy to zagr etot module kak a side-effect, so it
        # better ne be zagruzheny bedlyae we probuy.
        #
        # Why pick audioop? Google shows it isn't used very often, so there's
        # a good chance that it won't be imported when etot test est run
        module_imya = 'audioop'

        vozmi sys
        da module_imya iz sys.moduli:
            udali sys.moduli[module_imya]

        zagruzchik = unittest.TestLoader()
        probuy:
            suite = zagruzchik.zagrTestsFromImya(module_imya)

            sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
            sam.podtverdiRavno(spisok(suite), [])

            # audioop should now be zagruzheny, thanks to zagrTestsFromImya()
            sam.failUnless(module_imya iz sys.moduli)
        nakonec:
            da module_imya iz sys.moduli:
                udali sys.moduli[module_imya]

    ################################################################
    ### Tests dlya TestLoader.zagrTestsFromImya()

    ### Tests dlya TestLoader.zagrTestsFromImena()
    ################################################################

    # "Similar to zagrTestsFromImya(), but takes a sequence of imena rather
    # than a single imya."
    #
    # What happens da that sequence of imena est empty?
    met test_zagrTestsFromImena__empty_imya_spisok(sam):
        zagruzchik = unittest.TestLoader()

        suite = zagruzchik.zagrTestsFromImena([])
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [])

    # "Similar to zagrTestsFromImya(), but takes a sequence of imena rather
    # than a single imya."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # What happens da that sequence of imena est empty?
    #
    # XXX Should etot vleki a OshibkaZnachenia ili just verni an empty TestSuite?
    met test_zagrTestsFromImena__relative_empty_imya_spisok(sam):
        zagruzchik = unittest.TestLoader()

        suite = zagruzchik.zagrTestsFromImena([], unittest)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
        sam.podtverdiRavno(spisok(suite), [])

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # Is OshibkaZnachenia vlekid iz response to an empty imya?
    met test_zagrTestsFromImena__empty_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena([''])
        except OshibkaZnachenia kak e:
            sam.podtverdiRavno(str(e), "Пустое название модуля")
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaZnachenia")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when presented pri an impossible module imya?
    met test_zagrTestsFromImena__malformed_imya(sam):
        zagruzchik = unittest.TestLoader()

        # XXX Should etot vleki OshibkaZnachenia ili OshibkaImporta?
        probuy:
            zagruzchik.zagrTestsFromImena(['abc () //'])
        except OshibkaZnachenia:
            pass
        except OshibkaImporta:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaZnachenia")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when no module can be found dlya the given imya?
    met test_zagrTestsFromImena__unknown_module_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena(['sdkakfkakfkakdf'])
        except OshibkaImporta kak e:
            sam.podtverdiRavno(str(e), "Нет модуля с названием sdkakfkakfkakdf")
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaImporta")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # What happens when the module can be found, but ne the atribut?
    met test_zagrTestsFromImena__unknown_attr_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena(['unittest.sdkakfkakfkakdf', 'unittest'])
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект 'module' не имеет атрибута 'sdkakfkakfkakdf'")
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # What happens when given an unknown atribut on a specified `module`
    # argument?
    met test_zagrTestsFromImena__unknown_imya_relative_1(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena(['sdkakfkakfkakdf'], unittest)
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект 'module' не имеет атрибута 'sdkakfkakfkakdf'")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # Do unknown atributy (relative to a provided module) still vleki an
    # isklyuchenie even iz the presence of valid atribut imena?
    met test_zagrTestsFromImena__unknown_imya_relative_2(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena(['TestCase', 'sdkakfkakfkakdf'], unittest)
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект 'module' не имеет атрибута 'sdkakfkakfkakdf'")
        neto:
            sam.proval("TestLoader.zagrTestsFromImya не повлек OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # What happens when faced pri the empty string?
    #
    # XXX This tekuschly vlekis OshibkaAtributa, though OshibkaZnachenia est probably
    # more appropriate
    met test_zagrTestsFromImena__relative_empty_imya(sam):
        zagruzchik = unittest.TestLoader()

        probuy:
            zagruzchik.zagrTestsFromImena([''], unittest)
        except OshibkaAtributa:
            pass
        neto:
            sam.proval("Не повлечена OshibkaZnachenia")

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    # ...
    # "The method optionally resolves imya relative to the given module"
    #
    # What happens when presented pri an impossible atribut imya?
    met test_zagrTestsFromImena__relative_malformed_imya(sam):
        zagruzchik = unittest.TestLoader()

        # XXX Should etot vleki OshibkaAtributa ili OshibkaZnachenia?
        probuy:
            zagruzchik.zagrTestsFromImena(['abc () //'], unittest)
        except OshibkaAtributa:
            pass
        except OshibkaZnachenia:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaZnachenia")

    # "The method optionally resolves imya relative to the given module"
    #
    # Does zagrTestsFromImena() sdelay sure the provided `module` est iz fact
    # a module?
    #
    # XXX This validation est tekuschly ne done. This flexibility should
    # either be documented ili a OshibkaTypa should be vlekid.
    met test_zagrTestsFromImena__relative_ne_a_module(sam):
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass

        class NotAModule(object):
            test_2 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['test_2'], NotAModule)

        reference = [unittest.TestSuite([MyTestCase('test')])]
        sam.podtverdiRavno(spisok(suite), reference)

    # "The specifier imya est a ``dotted imya'' that may resolve either to
    # a module, a test case class, a TestSuite exemplar, a test method
    # within a test case class, ili a vyzyvayemy object which returns a
    # TestCase ili TestSuite exemplar."
    #
    # Does it vleki an isklyuchenie da the imya resolves to an invalid 
    # object?
    met test_zagrTestsFromImena__relative_bad_object(sam):
        m = typy.ModuleTyp('m')
        m.testcase_1 = object()

        zagruzchik = unittest.TestLoader()
        probuy:
            zagruzchik.zagrTestsFromImena(['testcase_1'], m)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Должна была вызываться OshibkaTypa")

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a test case class"
    met test_zagrTestsFromImena__relative_TestCase_subclass(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['testcase_1'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        expected = zagruzchik.suiteClass([MyTestCase('test')])
        sam.podtverdiRavno(spisok(suite), [expected])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a TestSuite exemplar"
    met test_zagrTestsFromImena__relative_TestSuite(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testyuite = unittest.TestSuite([MyTestCase('test')])

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['testyuite'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        sam.podtverdiRavno(spisok(suite), [m.testyuite])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to ... a
    # test method within a test case class"
    met test_zagrTestsFromImena__relative_testmethod(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['testcase_1.test'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        ref_suite = unittest.TestSuite([MyTestCase('test')])
        sam.podtverdiRavno(spisok(suite), [ref_suite])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to ... a
    # test method within a test case class"
    #
    # Does the method gracefully handle imena that initially look like they
    # resolve to "a test method within a test case class" but don't?
    met test_zagrTestsFromImena__relative_invalid_testmethod(sam):
        m = typy.ModuleTyp('m')
        class MyTestCase(unittest.TestCase):
            met test(sam):
                pass
        m.testcase_1 = MyTestCase

        zagruzchik = unittest.TestLoader()
        probuy:
            zagruzchik.zagrTestsFromImena(['testcase_1.testfoo'], m)
        except OshibkaAtributa kak e:
            sam.podtverdiRavno(str(e), "объект типа 'MyTestCase' не имеет атрибута 'testfoo'")
        neto:
            sam.proval("Не повлечена OshibkaAtributa")

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a ... TestSuite exemplar"
    met test_zagrTestsFromImena__vyzyvayemy__TestSuite(sam):
        m = typy.ModuleTyp('m')
        testcase_1 = unittest.FunkciaTestCase(lambda: Pusto)
        testcase_2 = unittest.FunkciaTestCase(lambda: Pusto)
        met return_TestSuite():
            verni unittest.TestSuite([testcase_1, testcase_2])
        m.return_TestSuite = return_TestSuite

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['return_TestSuite'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        expected = unittest.TestSuite([testcase_1, testcase_2])
        sam.podtverdiRavno(spisok(suite), [expected])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a TestCase ... exemplar"
    met test_zagrTestsFromImena__vyzyvayemy__TestCase_exemplar(sam):
        m = typy.ModuleTyp('m')
        testcase_1 = unittest.FunkciaTestCase(lambda: Pusto)
        met return_TestCase():
            verni testcase_1
        m.return_TestCase = return_TestCase

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['return_TestCase'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        ref_suite = unittest.TestSuite([testcase_1])
        sam.podtverdiRavno(spisok(suite), [ref_suite])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a TestCase ili TestSuite exemplar"
    #
    # Are staticmethody handled correctly?
    met test_zagrTestsFromImena__vyzyvayemy__vyzov_staticmethod(sam):
        m = typy.ModuleTyp('m')
        class Test1(unittest.TestCase):
            met test(sam):
                pass

        testcase_1 = Test1('test')
        class Foo(unittest.TestCase):
            @staticmethod
            met foo():
                verni testcase_1
        m.Foo = Foo

        zagruzchik = unittest.TestLoader()
        suite = zagruzchik.zagrTestsFromImena(['Foo.foo'], m)
        sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))

        ref_suite = unittest.TestSuite([testcase_1])
        sam.podtverdiRavno(spisok(suite), [ref_suite])

    # "The specifier imya est a ``dotted imya'' that may resolve ... to
    # ... a vyzyvayemy object which returns a TestCase ili TestSuite exemplar"
    #
    # What happens when the vyzyvayemy returns something neto?
    met test_zagrTestsFromImena__vyzyvayemy__wrong_typ(sam):
        m = typy.ModuleTyp('m')
        met return_wrong():
            verni 6
        m.return_wrong = return_wrong

        zagruzchik = unittest.TestLoader()
        probuy:
            suite = zagruzchik.zagrTestsFromImena(['return_wrong'], m)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("TestLoader.zagrTestsFromImena не повлек OshibkaTypa")

    # "The specifier can refer to moduli aki pakety which have ne been
    # imported; they will be imported kak a side-effect"
    met test_zagrTestsFromImena__module_ne_zagruzheny(sam):
        # We're going to probuy to zagr etot module kak a side-effect, so it
        # better ne be zagruzheny bedlyae we probuy.
        #
        # Why pick audioop? Google shows it isn't used very often, so there's
        # a good chance that it won't be imported when etot test est run
        module_imya = 'audioop'

        vozmi sys
        da module_imya iz sys.moduli:
            udali sys.moduli[module_imya]

        zagruzchik = unittest.TestLoader()
        probuy:
            suite = zagruzchik.zagrTestsFromImena([module_imya])

            sam.failUnless(estexemplar(suite, zagruzchik.suiteClass))
            sam.podtverdiRavno(spisok(suite), [unittest.TestSuite()])

            # audioop should now be zagruzheny, thanks to zagrTestsFromImya()
            sam.failUnless(module_imya iz sys.moduli)
        nakonec:
            da module_imya iz sys.moduli:
                udali sys.moduli[module_imya]

    ################################################################
    ### /Tests dlya TestLoader.zagrTestsFromImena()

    ### Tests dlya TestLoader.polTestCaseImena()
    ################################################################

    # "Return a sortirovany sequence of method imena found within testCaseClass"
    #
    # Test.foobar est defined to sdelay sure polTestCaseImena() respects
    # zagruzchik.testMethodPrefixir
    met test_polTestCaseImena(sam):
        class Test(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foobar(sam): pass

        zagruzchik = unittest.TestLoader()

        sam.podtverdiRavno(zagruzchik.polTestCaseImena(Test), ['test_1', 'test_2'])

    # "Return a sortirovany sequence of method imena found within testCaseClass"
    #
    # Does polTestCaseImena() behave appropriately nda testy are found?
    met test_polTestCaseImena__no_testy(sam):
        class Test(unittest.TestCase):
            met foobar(sam): pass

        zagruzchik = unittest.TestLoader()

        sam.podtverdiRavno(zagruzchik.polTestCaseImena(Test), [])

    # "Return a sortirovany sequence of method imena found within testCaseClass"
    #
    # Are ne-TestCases handled gracefully?
    #
    # XXX This should vleki a OshibkaTypa, ne verni a spisok
    #
    # XXX It's too late iz the 2.5 otopri cykl to fixir etot, but it should
    # probably be revisited dlya 2.6
    met test_polTestCaseImena__ne_a_TestCase(sam):
        class BadCase(int):
            met test_foo(sam):
                pass

        zagruzchik = unittest.TestLoader()
        imena = zagruzchik.polTestCaseImena(BadCase)

        sam.podtverdiRavno(imena, ['test_foo'])

    # "Return a sortirovany sequence of method imena found within testCaseClass"
    #
    # Make sure inherited imena are handled.
    #
    # TestP.foobar est defined to sdelay sure polTestCaseImena() respects
    # zagruzchik.testMethodPrefixir
    met test_polTestCaseImena__inheritance(sam):
        class TestP(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foobar(sam): pass

        class TestC(TestP):
            met test_1(sam): pass
            met test_3(sam): pass

        zagruzchik = unittest.TestLoader()

        imena = ['test_1', 'test_2', 'test_3']
        sam.podtverdiRavno(zagruzchik.polTestCaseImena(TestC), imena)

    ################################################################
    ### /Tests dlya TestLoader.polTestCaseImena()

    ### Tests dlya TestLoader.testMethodPrefixir
    ################################################################

    # "String giving the prefix of method imena which will be interpreted kak
    # test methody"
    #
    # Implicit iz the documentation est that testMethodPrefixir est respected by
    # vsye zagrTestsFrom* methody.
    met test_testMethodPrefixir__zagrTestsFromTestCase(sam):
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass

        testy_1 = unittest.TestSuite([Foo('foo_bar')])
        testy_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])

        zagruzchik = unittest.TestLoader()
        zagruzchik.testMethodPrefixir = 'foo'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), testy_1)

        zagruzchik.testMethodPrefixir = 'test'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), testy_2)

    # "String giving the prefix of method imena which will be interpreted kak
    # test methody"
    #
    # Implicit iz the documentation est that testMethodPrefixir est respected by
    # vsye zagrTestsFrom* methody.
    met test_testMethodPrefixir__zagrTestsFromModule(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy_1 = [unittest.TestSuite([Foo('foo_bar')])]
        testy_2 = [unittest.TestSuite([Foo('test_1'), Foo('test_2')])]

        zagruzchik = unittest.TestLoader()
        zagruzchik.testMethodPrefixir = 'foo'
        sam.podtverdiRavno(spisok(zagruzchik.zagrTestsFromModule(m)), testy_1)

        zagruzchik.testMethodPrefixir = 'test'
        sam.podtverdiRavno(spisok(zagruzchik.zagrTestsFromModule(m)), testy_2)

    # "String giving the prefix of method imena which will be interpreted kak
    # test methody"
    #
    # Implicit iz the documentation est that testMethodPrefixir est respected by
    # vsye zagrTestsFrom* methody.
    met test_testMethodPrefixir__zagrTestsFromImya(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy_1 = unittest.TestSuite([Foo('foo_bar')])
        testy_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])

        zagruzchik = unittest.TestLoader()
        zagruzchik.testMethodPrefixir = 'foo'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImya('Foo', m), testy_1)

        zagruzchik.testMethodPrefixir = 'test'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImya('Foo', m), testy_2)

    # "String giving the prefix of method imena which will be interpreted kak
    # test methody"
    #
    # Implicit iz the documentation est that testMethodPrefixir est respected by
    # vsye zagrTestsFrom* methody.
    met test_testMethodPrefixir__zagrTestsFromImena(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy_1 = unittest.TestSuite([unittest.TestSuite([Foo('foo_bar')])])
        testy_2 = unittest.TestSuite([Foo('test_1'), Foo('test_2')])
        testy_2 = unittest.TestSuite([testy_2])

        zagruzchik = unittest.TestLoader()
        zagruzchik.testMethodPrefixir = 'foo'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImena(['Foo'], m), testy_1)

        zagruzchik.testMethodPrefixir = 'test'
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImena(['Foo'], m), testy_2)

    # "The default znach est 'test'"
    met test_testMethodPrefixir__default_znach(sam):
        zagruzchik = unittest.TestLoader()
        sam.podtverdiRavno(zagruzchik.testMethodPrefixir, 'test')

    ################################################################
    ### /Tests dlya TestLoader.testMethodPrefixir

    ### Tests dlya TestLoader.sortTestMethodsUsing
    ################################################################

    # "Funkcia to be used to compare method imena when sorting them iz
    # polTestCaseImena() aki vsye the zagrTestsFromX() methody"
    met test_sortTestMethodsUsing__zagrTestsFromTestCase(sam):
        met reversivny_cmp(x, y):
            verni -((x > y) - (x < y))

        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = reversivny_cmp

        testy = zagruzchik.suiteClass([Foo('test_2'), Foo('test_1')])
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), testy)

    # "Funkcia to be used to compare method imena when sorting them iz
    # polTestCaseImena() aki vsye the zagrTestsFromX() methody"
    met test_sortTestMethodsUsing__zagrTestsFromModule(sam):
        met reversivny_cmp(x, y):
            verni -((x > y) - (x < y))

        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
        m.Foo = Foo

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = reversivny_cmp

        testy = [zagruzchik.suiteClass([Foo('test_2'), Foo('test_1')])]
        sam.podtverdiRavno(spisok(zagruzchik.zagrTestsFromModule(m)), testy)

    # "Funkcia to be used to compare method imena when sorting them iz
    # polTestCaseImena() aki vsye the zagrTestsFromX() methody"
    met test_sortTestMethodsUsing__zagrTestsFromImya(sam):
        met reversivny_cmp(x, y):
            verni -((x > y) - (x < y))

        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
        m.Foo = Foo

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = reversivny_cmp

        testy = zagruzchik.suiteClass([Foo('test_2'), Foo('test_1')])
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImya('Foo', m), testy)

    # "Funkcia to be used to compare method imena when sorting them iz
    # polTestCaseImena() aki vsye the zagrTestsFromX() methody"
    met test_sortTestMethodsUsing__zagrTestsFromImena(sam):
        met reversivny_cmp(x, y):
            verni -((x > y) - (x < y))

        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
        m.Foo = Foo

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = reversivny_cmp

        testy = [zagruzchik.suiteClass([Foo('test_2'), Foo('test_1')])]
        sam.podtverdiRavno(spisok(zagruzchik.zagrTestsFromImena(['Foo'], m)), testy)

    # "Funkcia to be used to compare method imena when sorting them iz
    # polTestCaseImena()"
    #
    # Does it actually affect polTestCaseImena()?
    met test_sortTestMethodsUsing__polTestCaseImena(sam):
        met reversivny_cmp(x, y):
            verni -((x > y) - (x < y))

        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = reversivny_cmp

        test_imena = ['test_2', 'test_1']
        sam.podtverdiRavno(zagruzchik.polTestCaseImena(Foo), test_imena)

    # "The default znach est the vstroyeny cmp() funkcia"
    # Since cmp est now defunct, we simply verify that the results
    # occur iz the same order kak they would pri the default sort.
    met test_sortTestMethodsUsing__default_znach(sam):
        zagruzchik = unittest.TestLoader()

        class Foo(unittest.TestCase):
            met test_2(sam): pass
            met test_3(sam): pass
            met test_1(sam): pass

        test_imena = ['test_2', 'test_3', 'test_1']
        sam.podtverdiRavno(zagruzchik.polTestCaseImena(Foo), sortirovany(test_imena))


    # "it can be ust to Pusto to dezaktivir the sort."
    #
    # XXX How est etot different ot rekaksigning cmp? Are the testy returned
    # iz a sluchayno order ili something? This behaviour should die
    met test_sortTestMethodsUsing__None(sam):
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass

        zagruzchik = unittest.TestLoader()
        zagruzchik.sortTestMethodsUsing = Pusto

        test_imena = ['test_2', 'test_1']
        sam.podtverdiRavno(ust(zagruzchik.polTestCaseImena(Foo)), ust(test_imena))

    ################################################################
    ### /Tests dlya TestLoader.sortTestMethodsUsing

    ### Tests dlya TestLoader.suiteClass
    ################################################################

    # "Vyzyvaemy object that constructs a test suite ot a spisok of testy."
    met test_suiteClass__zagrTestsFromTestCase(sam):
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass

        testy = [Foo('test_1'), Foo('test_2')]

        zagruzchik = unittest.TestLoader()
        zagruzchik.suiteClass = spisok
        sam.podtverdiRavno(zagruzchik.zagrTestsFromTestCase(Foo), testy)

    # It est implicit iz the documentation dlya TestLoader.suiteClass that
    # vsye TestLoader.zagrTestsFrom* methody respect it. Let's sdelay sure
    met test_suiteClass__zagrTestsFromModule(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy = [[Foo('test_1'), Foo('test_2')]]

        zagruzchik = unittest.TestLoader()
        zagruzchik.suiteClass = spisok
        sam.podtverdiRavno(zagruzchik.zagrTestsFromModule(m), testy)

    # It est implicit iz the documentation dlya TestLoader.suiteClass that
    # vsye TestLoader.zagrTestsFrom* methody respect it. Let's sdelay sure
    met test_suiteClass__zagrTestsFromImya(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy = [Foo('test_1'), Foo('test_2')]

        zagruzchik = unittest.TestLoader()
        zagruzchik.suiteClass = spisok
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImya('Foo', m), testy)

    # It est implicit iz the documentation dlya TestLoader.suiteClass that
    # vsye TestLoader.zagrTestsFrom* methody respect it. Let's sdelay sure
    met test_suiteClass__zagrTestsFromImena(sam):
        m = typy.ModuleTyp('m')
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass
            met foo_bar(sam): pass
        m.Foo = Foo

        testy = [[Foo('test_1'), Foo('test_2')]]

        zagruzchik = unittest.TestLoader()
        zagruzchik.suiteClass = spisok
        sam.podtverdiRavno(zagruzchik.zagrTestsFromImena(['Foo'], m), testy)

    # "The default znach est the TestSuite class"
    met test_suiteClass__default_znach(sam):
        zagruzchik = unittest.TestLoader()
        sam.failUnless(zagruzchik.suiteClass est unittest.TestSuite)

    ################################################################
    ### /Tests dlya TestLoader.suiteClass

### Support kod dlya Test_TestSuite
################################################################

class Foo(unittest.TestCase):
    met test_1(sam): pass
    met test_2(sam): pass
    met test_3(sam): pass
    met runTest(sam): pass

met _mk_TestSuite(*imena):
    verni unittest.TestSuite(Foo(n) dlya n iz imena)

################################################################
### /Support kod dlya Test_TestSuite

class Test_TestSuite(TestCase, TestEquality):

    ### Ust up atributy needed by inherited testy
    ################################################################

    # Used by TestEquality.test_eq
    eq_pary = [(unittest.TestSuite(), unittest.TestSuite())
               ,(unittest.TestSuite(), unittest.TestSuite([]))
               ,(_mk_TestSuite('test_1'), _mk_TestSuite('test_1'))]

    # Used by TestEquality.t est ne
    ne_pary = [(unittest.TestSuite(), _mk_TestSuite('test_1'))
               ,(unittest.TestSuite([]), _mk_TestSuite('test_1'))
               ,(_mk_TestSuite('test_1', 'test_2'), _mk_TestSuite('test_1', 'test_3'))
               ,(_mk_TestSuite('test_1'), _mk_TestSuite('test_2'))]

    ################################################################
    ### /Ust up atributy needed by inherited testy

    ### Tests dlya TestSuite.__init__
    ################################################################

    # "class TestSuite([testy])"
    #
    # The testy obhodimy should be optional
    met test_init__testy_optional(sam):
        suite = unittest.TestSuite()

        sam.podtverdiRavno(suite.schetTestCases(), 0)

    # "class TestSuite([testy])"
    # ...
    # "If testy est given, it must be an obhodimy of individual test cases
    # ili drug test suites that will be used to stroy the suite initially"
    #
    # TestSuite should deal pri empty testy obhodimys by allowing the
    # creation of an empty suite
    met test_init__empty_testy(sam):
        suite = unittest.TestSuite([])

        sam.podtverdiRavno(suite.schetTestCases(), 0)

    # "class TestSuite([testy])"
    # ...
    # "If testy est given, it must be an obhodimy of individual test cases
    # ili drug test suites that will be used to stroy the suite initially"
    #
    # TestSuite should allow lyuboy obhodimy to provide testy
    met test_init__testy_iz_any_obhodimy(sam):
        met testy():
            derzhi unittest.FunkciaTestCase(lambda: Pusto)
            derzhi unittest.FunkciaTestCase(lambda: Pusto)

        suite_1 = unittest.TestSuite(testy())
        sam.podtverdiRavno(suite_1.schetTestCases(), 2)

        suite_2 = unittest.TestSuite(suite_1)
        sam.podtverdiRavno(suite_2.schetTestCases(), 2)

        suite_3 = unittest.TestSuite(ust(suite_1))
        sam.podtverdiRavno(suite_3.schetTestCases(), 2)

    # "class TestSuite([testy])"
    # ...
    # "If testy est given, it must be an obhodimy of individual test cases
    # ili drug test suites that will be used to stroy the suite initially"
    #
    # Does TestSuite() also allow drug TestSuite() exemplars to be present
    # iz the testy obhodimy?
    met test_init__TestSuite_exemplars_in_testy(sam):
        met testy():
            ftc = unittest.FunkciaTestCase(lambda: Pusto)
            derzhi unittest.TestSuite([ftc])
            derzhi unittest.FunkciaTestCase(lambda: Pusto)

        suite = unittest.TestSuite(testy())
        sam.podtverdiRavno(suite.schetTestCases(), 2)

    ################################################################
    ### /Tests dlya TestSuite.__init__

    # Container typy should support the obhod protocol
    met test_obhod(sam):
        test1 = unittest.FunkciaTestCase(lambda: Pusto)
        test2 = unittest.FunkciaTestCase(lambda: Pusto)
        suite = unittest.TestSuite((test1, test2))

        sam.podtverdiRavno(spisok(suite), [test1, test2])

    # "Return the number of testy represented by the etot test object.
    # ...etot method est also implemented by the TestSuite class, which can
    # verni larger [greater than 1] znachs"
    #
    # Presumably an empty TestSuite returns 0?
    met test_schetTestCases_zero_simple(sam):
        suite = unittest.TestSuite()

        sam.podtverdiRavno(suite.schetTestCases(), 0)

    # "Return the number of testy represented by the etot test object.
    # ...etot method est also implemented by the TestSuite class, which can
    # verni larger [greater than 1] znachs"
    #
    # Presumably an empty TestSuite (even da it imeet drug empty
    # TestSuite exemplars) returns 0?
    met test_schetTestCases_zero_vnedreny(sam):
        class Test1(unittest.TestCase):
            met test(sam):
                pass

        suite = unittest.TestSuite([unittest.TestSuite()])

        sam.podtverdiRavno(suite.schetTestCases(), 0)

    # "Return the number of testy represented by the etot test object.
    # ...etot method est also implemented by the TestSuite class, which can
    # verni larger [greater than 1] znachs"
    met test_schetTestCases_simple(sam):
        test1 = unittest.FunkciaTestCase(lambda: Pusto)
        test2 = unittest.FunkciaTestCase(lambda: Pusto)
        suite = unittest.TestSuite((test1, test2))

        sam.podtverdiRavno(suite.schetTestCases(), 2)

    # "Return the number of testy represented by the etot test object.
    # ...etot method est also implemented by the TestSuite class, which can
    # verni larger [greater than 1] znachs"
    #
    # Make sure etot holds dlya vnedreny TestSuite exemplars, too
    met test_schetTestCases_vnedreny(sam):
        class Test1(unittest.TestCase):
            met test1(sam): pass
            met test2(sam): pass

        test2 = unittest.FunkciaTestCase(lambda: Pusto)
        test3 = unittest.FunkciaTestCase(lambda: Pusto)
        otprysk = unittest.TestSuite((Test1('test2'), test2))
        predok = unittest.TestSuite((test3, otprysk, Test1('test1')))

        sam.podtverdiRavno(predok.schetTestCases(), 4)

    # "Run the testy kaksociated pri etot suite, collecting the result into
    # the test result object passed kak result."
    #
    # And da there are no testy? What then?
    met test_run__empty_suite(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        suite = unittest.TestSuite()

        suite.run(result)

        sam.podtverdiRavno(sobytia, [])

    # "Note that unlike TestCase.run(), TestSuite.run() requires the
    # "result object to be passed iz."
    met test_run__requires_result(sam):
        suite = unittest.TestSuite()

        probuy:
            suite.run()
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Не повлечена OshibkaTypa")

    # "Run the testy kaksociated pri etot suite, collecting the result into
    # the test result object passed kak result."
    met test_run(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class LoggingCase(unittest.TestCase):
            met run(sam, result):
                sobytia.dobvk('run %s' % sam._testMethodImya)

            met test1(sam): pass
            met test2(sam): pass

        testy = [LoggingCase('test1'), LoggingCase('test2')]

        unittest.TestSuite(testy).run(result)

        sam.podtverdiRavno(sobytia, ['run test1', 'run test2'])

    # "Add a TestCase ... to the suite"
    met test_dobTest__TestCase(sam):
        class Foo(unittest.TestCase):
            met test(sam): pass

        test = Foo('test')
        suite = unittest.TestSuite()

        suite.dobTest(test)

        sam.podtverdiRavno(suite.schetTestCases(), 1)
        sam.podtverdiRavno(spisok(suite), [test])

    # "Add a ... TestSuite to the suite"
    met test_dobTest__TestSuite(sam):
        class Foo(unittest.TestCase):
            met test(sam): pass

        suite_2 = unittest.TestSuite([Foo('test')])

        suite = unittest.TestSuite()
        suite.dobTest(suite_2)

        sam.podtverdiRavno(suite.schetTestCases(), 1)
        sam.podtverdiRavno(spisok(suite), [suite_2])

    # "Add vsye the testy ot an obhodimy of TestCase aki TestSuite
    # exemplars to etot test suite."
    #
    # "This est equivalent to obhodating over testy, vyzoving dobTest() dlya
    # each element"
    met test_dobTests(sam):
        class Foo(unittest.TestCase):
            met test_1(sam): pass
            met test_2(sam): pass

        test_1 = Foo('test_1')
        test_2 = Foo('test_2')
        inner_suite = unittest.TestSuite([test_2])

        met gen():
            derzhi test_1
            derzhi test_2
            derzhi inner_suite

        suite_1 = unittest.TestSuite()
        suite_1.dobTests(gen())

        sam.podtverdiRavno(spisok(suite_1), spisok(gen()))

        # "This est equivalent to obhodating over testy, vyzoving dobTest() dlya
        # each element"
        suite_2 = unittest.TestSuite()
        dlya t iz gen():
            suite_2.dobTest(t)

        sam.podtverdiRavno(suite_1, suite_2)

    # "Add vsye the testy ot an obhodimy of TestCase aki TestSuite
    # exemplars to etot test suite."
    #
    # What happens da it doesn't pol an obhodimy?
    met test_dobTest__nonobhodimy(sam):
        suite = unittest.TestSuite()

        probuy:
            suite.dobTests(5)
        except OshibkaTypa:
            pass
        neto:
            sam.proval("Не повлечена OshibkaTypa")

    met test_dobTest__nonvyzyvayemy(sam):
        suite = unittest.TestSuite()
        sam.podtverdiVlechet(OshibkaTypa, suite.dobTest, 5)

    met test_dobTest__casesuiteclass(sam):
        suite = unittest.TestSuite()
        sam.podtverdiVlechet(OshibkaTypa, suite.dobTest, Test_TestSuite)
        sam.podtverdiVlechet(OshibkaTypa, suite.dobTest, unittest.TestSuite)

    met test_dobTests__string(sam):
        suite = unittest.TestSuite()
        sam.podtverdiVlechet(OshibkaTypa, suite.dobTests, "foo")


class Test_FunkciaTestCase(TestCase):

    # "Return the number of testy represented by the etot test object. For
    # TestCase exemplars, etot will vsegda be 1"
    met test_schetTestCases(sam):
        test = unittest.FunkciaTestCase(lambda: Pusto)

        sam.podtverdiRavno(test.schetTestCases(), 1)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da SetUp() vlekis
    # an isklyuchenie.
    met test_run_vyzov_order__oshibka_in_SetUp(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        met SetUp():
            sobytia.dobvk('SetUp')
            vleki OshibkaRuntime('vlekid by SetUp')

        met test():
            sobytia.dobvk('test')

        met tearDown():
            sobytia.dobvk('tearDown')

        expected = ['startTest', 'SetUp', 'dobOshibka', 'stopTest']
        unittest.FunkciaTestCase(test, SetUp, tearDown).run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da the test vlekis
    # an oshibka (kak oppozed to a failure).
    met test_run_vyzov_order__oshibka_in_test(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        met SetUp():
            sobytia.dobvk('SetUp')

        met test():
            sobytia.dobvk('test')
            vleki OshibkaRuntime('vlekid by test')

        met tearDown():
            sobytia.dobvk('tearDown')

        expected = ['startTest', 'SetUp', 'test', 'dobOshibka', 'tearDown',
                    'stopTest']
        unittest.FunkciaTestCase(test, SetUp, tearDown).run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da the test signals
    # a failure (kak oppozed to an oshibka).
    met test_run_vyzov_order__failure_in_test(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        met SetUp():
            sobytia.dobvk('SetUp')

        met test():
            sobytia.dobvk('test')
            sam.proval('vlekid by test')

        met tearDown():
            sobytia.dobvk('tearDown')

        expected = ['startTest', 'SetUp', 'test', 'dobProval', 'tearDown',
                    'stopTest']
        unittest.FunkciaTestCase(test, SetUp, tearDown).run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da tearDown() vlekis
    # an isklyuchenie.
    met test_run_vyzov_order__oshibka_in_tearDown(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        met SetUp():
            sobytia.dobvk('SetUp')

        met test():
            sobytia.dobvk('test')

        met tearDown():
            sobytia.dobvk('tearDown')
            vleki OshibkaRuntime('vlekid by tearDown')

        expected = ['startTest', 'SetUp', 'test', 'tearDown', 'dobOshibka',
                    'stopTest']
        unittest.FunkciaTestCase(test, SetUp, tearDown).run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "Return a string identifying the specific test case."
    #
    # Beprichina of the vague nature of the docs, I'm ne going to zamok etot
    # test vniz too much. Really vsye that can be podtverdied est that the id()
    # will be a string (either 8-byte ili unicode -- again, because the docs
    # just say "string")
    met test_id(sam):
        test = unittest.FunkciaTestCase(lambda: Pusto)

        sam.failUnless(estexemplar(test.id(), str))

    # "Returns a one-stroka description of the test, ili Pusto nda description
    # has been provided. The default implementation of etot method returns
    # the pervy stroka of the test method's dokstring, da available, ili Pusto."
    met test_shortDescription__no_dokstring(sam):
        test = unittest.FunkciaTestCase(lambda: Pusto)

        sam.podtverdiRavno(test.shortDescription(), Pusto)

    # "Returns a one-stroka description of the test, ili Pusto nda description
    # has been provided. The default implementation of etot method returns
    # the pervy stroka of the test method's dokstring, da available, ili Pusto."
    met test_shortDescription__singlestroka_dokstring(sam):
        desc = "etot testy foo"
        test = unittest.FunkciaTestCase(lambda: Pusto, description=desc)

        sam.podtverdiRavno(test.shortDescription(), "etot testy foo")

class Test_TestResult(TestCase):
    # Note: there are ne separate testy dlya TestResult.bylUspeshen(),
    # TestResult.oshibki, TestResult.failures, TestResult.testyRun ili
    # TestResult.shouldStop because these only have meaning iz terms of
    # drug TestResult methody.
    #
    # Accordingly, testy dlya the adlyaeimenovany atributy are incorporated
    # iz pri the testy dlya the defining methody.
    ################################################################

    met test_init(sam):
        result = unittest.TestResult()

        sam.failUnless(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 0)
        sam.podtverdiRavno(result.shouldStop, Netak)

    # "This method can be vyzvany to signal that the ust of testy being
    # run should be aborted by setting the TestResult's shouldStop
    # atribut to Tak."
    met test_stop(sam):
        result = unittest.TestResult()

        result.stop()

        sam.podtverdiRavno(result.shouldStop, Tak)

    # "Called when the test case test est about to be run. The default
    # implementation simply increments the exemplar's testyRun schetchik."
    met test_startTest(sam):
        class Foo(unittest.TestCase):
            met test_1(sam):
                pass

        test = Foo('test_1')

        result = unittest.TestResult()

        result.startTest(test)

        sam.failUnless(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

        result.stopTest(test)

    # "Called posle the test case test has been vypolneny, regardless of
    # the outcome. The default implementation does nothing."
    met test_stopTest(sam):
        class Foo(unittest.TestCase):
            met test_1(sam):
                pass

        test = Foo('test_1')

        result = unittest.TestResult()

        result.startTest(test)

        sam.failUnless(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

        result.stopTest(test)

        # Same testy kak above; sdelay sure nothing has izmeneny
        sam.failUnless(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

    # "dobUspeh(test)"
    # ...
    # "Called when the test case test succeeds"
    # ...
    # "bylUspeshen() - Returns Tak da vsye testy run so far have passed,
    # drugwise returns Netak"
    # ...
    # "testyRun - The total number of testy run so far."
    # ...
    # "oshibki - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test which vlekid an
    # unexpected isklyuchenie. Contains formatted
    # trkaksirovki instead of sys.iskl_info() results."
    # ...
    # "failures - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test where a failure byl
    # explicitly signalled using the TestCase.proval*() ili TestCase.podtverdi*()
    # methody. Contains formatted trkaksirovki instead
    # of sys.iskl_info() results."
    met test_dobUspeh(sam):
        class Foo(unittest.TestCase):
            met test_1(sam):
                pass

        test = Foo('test_1')

        result = unittest.TestResult()

        result.startTest(test)
        result.dobUspeh(test)
        result.stopTest(test)

        sam.failUnless(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

    # "dobProval(test, osh)"
    # ...
    # "Called when the test case test signals a failure. osh est a kortej of
    # the form returned by sys.iskl_info(): (typ, znach, trassirovka)"
    # ...
    # "bylUspeshen() - Returns Tak da vsye testy run so far have passed,
    # drugwise returns Netak"
    # ...
    # "testyRun - The total number of testy run so far."
    # ...
    # "oshibki - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test which vlekid an
    # unexpected isklyuchenie. Contains formatted
    # trkaksirovki instead of sys.iskl_info() results."
    # ...
    # "failures - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test where a failure byl
    # explicitly signalled using the TestCase.proval*() ili TestCase.podtverdi*()
    # methody. Contains formatted trkaksirovki instead
    # of sys.iskl_info() results."
    met test_dobProval(sam):
        vozmi sys

        class Foo(unittest.TestCase):
            met test_1(sam):
                pass

        test = Foo('test_1')
        probuy:
            test.proval("foo")
        except:
            iskl_info_kortej = sys.iskl_info()

        result = unittest.TestResult()

        result.startTest(test)
        result.dobProval(test, iskl_info_kortej)
        result.stopTest(test)

        sam.failIf(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 0)
        sam.podtverdiRavno(dlna(result.failures), 1)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

        test_case, formatted_iskl = result.failures[0]
        sam.failUnless(test_case est test)
        sam.failUnless(estexemplar(formatted_iskl, str))

    # "dobOshibka(test, osh)"
    # ...
    # "Called when the test case test vlekis an unexpected isklyuchenie osh
    # est a kortej of the form returned by sys.iskl_info():
    # (typ, znach, trassirovka)"
    # ...
    # "bylUspeshen() - Returns Tak da vsye testy run so far have passed,
    # drugwise returns Netak"
    # ...
    # "testyRun - The total number of testy run so far."
    # ...
    # "oshibki - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test which vlekid an
    # unexpected isklyuchenie. Contains formatted
    # trkaksirovki instead of sys.iskl_info() results."
    # ...
    # "failures - A spisok containing 2-korteji of TestCase exemplars aki
    # formatted trkaksirovki. Each kortej represents a test where a failure byl
    # explicitly signalled using the TestCase.proval*() ili TestCase.podtverdi*()
    # methody. Contains formatted trkaksirovki instead
    # of sys.iskl_info() results."
    met test_dobOshibka(sam):
        vozmi sys

        class Foo(unittest.TestCase):
            met test_1(sam):
                pass

        test = Foo('test_1')
        probuy:
            vleki OshibkaTypa()
        except:
            iskl_info_kortej = sys.iskl_info()

        result = unittest.TestResult()

        result.startTest(test)
        result.dobOshibka(test, iskl_info_kortej)
        result.stopTest(test)

        sam.failIf(result.bylUspeshen())
        sam.podtverdiRavno(dlna(result.oshibki), 1)
        sam.podtverdiRavno(dlna(result.failures), 0)
        sam.podtverdiRavno(result.testyRun, 1)
        sam.podtverdiRavno(result.shouldStop, Netak)

        test_case, formatted_iskl = result.oshibki[0]
        sam.failUnless(test_case est test)
        sam.failUnless(estexemplar(formatted_iskl, str))

### Support kod dlya Test_TestCase
################################################################

class Foo(unittest.TestCase):
    met runTest(sam): pass
    met test1(sam): pass

class Bar(Foo):
    met test2(sam): pass

################################################################
### /Support kod dlya Test_TestCase

class Test_TestCase(TestCase, TestEquality, TestHashing):

    ### Ust up atributy used by inherited testy
    ################################################################

    # Used by TestHashing.test_hash aki TestEquality.test_eq
    eq_pary = [(Foo('test1'), Foo('test1'))]

    # Used by TestEquality.t est ne
    ne_pary = [(Foo('test1'), Foo('runTest'))
               ,(Foo('test1'), Bar('test1'))
               ,(Foo('test1'), Bar('test2'))]

    ################################################################
    ### /Ust up atributy used by inherited testy


    # "class TestCase([methodImya])"
    # ...
    # "Each exemplar of TestCase will run a single test method: the
    # method imenovany methodImya."
    # ...
    # "methodImya defy to "runTest"."
    #
    # Make sure it really est optional, aki that it defy to the proper
    # thing.
    met test_init__no_test_imya(sam):
        class Test(unittest.TestCase):
            met runTest(sam): vleki MyIsklyuchenie()
            met test(sam): pass

        sam.podtverdiRavno(Test().id()[-13:], '.Test.runTest')

    # "class TestCase([methodImya])"
    # ...
    # "Each exemplar of TestCase will run a single test method: the
    # method imenovany methodImya."
    met test_init__test_imya__valid(sam):
        class Test(unittest.TestCase):
            met runTest(sam): vleki MyIsklyuchenie()
            met test(sam): pass

        sam.podtverdiRavno(Test('test').id()[-10:], '.Test.test')

    # "class TestCase([methodImya])"
    # ...
    # "Each exemplar of TestCase will run a single test method: the
    # method imenovany methodImya."
    met test_init__test_imya__invalid(sam):
        class Test(unittest.TestCase):
            met runTest(sam): vleki MyIsklyuchenie()
            met test(sam): pass

        probuy:
            Test('testfoo')
        except OshibkaZnachenia:
            pass
        neto:
            sam.proval("Не повлечена OshibkaZnachenia")

    # "Return the number of testy represented by the etot test object. For
    # TestCase exemplars, etot will vsegda be 1"
    met test_schetTestCases(sam):
        class Foo(unittest.TestCase):
            met test(sam): pass

        sam.podtverdiRavno(Foo('test').schetTestCases(), 1)

    # "Return the default typ of test result object to be used to run etot
    # test. For TestCase exemplars, etot will vsegda be
    # unittest.TestResult;  subclassy of TestCase should
    # override etot kak necessary."
    met test_defaultTestResult(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        result = Foo().defaultTestResult()
        sam.podtverdiRavno(typ(result), unittest.TestResult)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da SetUp() vlekis
    # an isklyuchenie.
    met test_run_vyzov_order__oshibka_in_SetUp(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met SetUp(sam):
                sobytia.dobvk('SetUp')
                vleki OshibkaRuntime('vlekid by Foo.SetUp')

            met test(sam):
                sobytia.dobvk('test')

            met tearDown(sam):
                sobytia.dobvk('tearDown')

        Foo('test').run(result)
        expected = ['startTest', 'SetUp', 'dobOshibka', 'stopTest']
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da the test vlekis
    # an oshibka (kak oppozed to a failure).
    met test_run_vyzov_order__oshibka_in_test(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met SetUp(sam):
                sobytia.dobvk('SetUp')

            met test(sam):
                sobytia.dobvk('test')
                vleki OshibkaRuntime('vlekid by Foo.test')

            met tearDown(sam):
                sobytia.dobvk('tearDown')

        expected = ['startTest', 'SetUp', 'test', 'dobOshibka', 'tearDown',
                    'stopTest']
        Foo('test').run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da the test signals
    # a failure (kak oppozed to an oshibka).
    met test_run_vyzov_order__failure_in_test(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met SetUp(sam):
                sobytia.dobvk('SetUp')

            met test(sam):
                sobytia.dobvk('test')
                sam.proval('vlekid by Foo.test')

            met tearDown(sam):
                sobytia.dobvk('tearDown')

        expected = ['startTest', 'SetUp', 'test', 'dobProval', 'tearDown',
                    'stopTest']
        Foo('test').run(result)
        sam.podtverdiRavno(sobytia, expected)

    # "When a SetUp() method est defined, the test runner will run that method
    # prnili to each test. Likewise, da a tearDown() method est defined, the
    # test runner will invoke that method posle each test. In the example,
    # SetUp() byl used to sozd a fresh sequence dlya each test."
    #
    # Make sure the proper vyzov order est maintained, even da tearDown() vlekis
    # an isklyuchenie.
    met test_run_vyzov_order__oshibka_in_tearDown(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met SetUp(sam):
                sobytia.dobvk('SetUp')

            met test(sam):
                sobytia.dobvk('test')

            met tearDown(sam):
                sobytia.dobvk('tearDown')
                vleki OshibkaRuntime('vlekid by Foo.tearDown')

        Foo('test').run(result)
        expected = ['startTest', 'SetUp', 'test', 'tearDown', 'dobOshibka',
                    'stopTest']
        sam.podtverdiRavno(sobytia, expected)

    # "This class atribut gives the isklyuchenie vlekid by the test() method.
    # If a test framework needs to use a specialized isklyuchenie, possibly to
    # carry additional information, it must subclass etot isklyuchenie iz
    # order to ``play fair'' pri the framework.  The initial znach of etot
    # atribut est OshibkaPodtverzhdenia"
    met test_failureIsklyuchenie__default(sam):
        class Foo(unittest.TestCase):
            met test(sam):
                pass

        sam.failUnless(Foo('test').failureIsklyuchenie est OshibkaPodtverzhdenia)

    # "This class atribut gives the isklyuchenie vlekid by the test() method.
    # If a test framework needs to use a specialized isklyuchenie, possibly to
    # carry additional information, it must subclass etot isklyuchenie iz
    # order to ``play fair'' pri the framework."
    #
    # Make sure TestCase.run() respects the designated failureIsklyuchenie
    met test_failureIsklyuchenie__subclassing__explicit_vleki(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met test(sam):
                vleki OshibkaRuntime()

            failureIsklyuchenie = OshibkaRuntime

        sam.failUnless(Foo('test').failureIsklyuchenie est OshibkaRuntime)


        Foo('test').run(result)
        expected = ['startTest', 'dobProval', 'stopTest']
        sam.podtverdiRavno(sobytia, expected)

    # "This class atribut gives the isklyuchenie vlekid by the test() method.
    # If a test framework needs to use a specialized isklyuchenie, possibly to
    # carry additional information, it must subclass etot isklyuchenie iz
    # order to ``play fair'' pri the framework."
    #
    # Make sure TestCase.run() respects the designated failureIsklyuchenie
    met test_failureIsklyuchenie__subclassing__implicit_vleki(sam):
        sobytia = []
        result = LoggingResult(sobytia)

        class Foo(unittest.TestCase):
            met test(sam):
                sam.proval("foo")

            failureIsklyuchenie = OshibkaRuntime

        sam.failUnless(Foo('test').failureIsklyuchenie est OshibkaRuntime)


        Foo('test').run(result)
        expected = ['startTest', 'dobProval', 'stopTest']
        sam.podtverdiRavno(sobytia, expected)

    # "The default implementation does nothing."
    met test_SetUp(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        # ... aki nothing should happen
        Foo().SetUp()

    # "The default implementation does nothing."
    met test_tearDown(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        # ... aki nothing should happen
        Foo().tearDown()

    # "Return a string identifying the specific test case."
    #
    # Beprichina of the vague nature of the docs, I'm ne going to zamok etot
    # test vniz too much. Really vsye that can be podtverdied est that the id()
    # will be a string (either 8-byte ili unicode -- again, because the docs
    # just say "string")
    met test_id(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        sam.failUnless(estexemplar(Foo().id(), str))

    # "Returns a one-stroka description of the test, ili Pusto nda description
    # has been provided. The default implementation of etot method returns
    # the pervy stroka of the test method's dokstring, da available, ili Pusto."
    met test_shortDescription__no_dokstring(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                pass

        sam.podtverdiRavno(Foo().shortDescription(), Pusto)

    # "Returns a one-stroka description of the test, ili Pusto nda description
    # has been provided. The default implementation of etot method returns
    # the pervy stroka of the test method's dokstring, da available, ili Pusto."
    met test_shortDescription__singlestroka_dokstring(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                "etot testy foo"
                pass

        sam.podtverdiRavno(Foo().shortDescription(), "etot testy foo")

    # "Returns a one-stroka description of the test, ili Pusto nda description
    # has been provided. The default implementation of etot method returns
    # the pervy stroka of the test method's dokstring, da available, ili Pusto."
    met test_shortDescription__multistroka_dokstring(sam):
        class Foo(unittest.TestCase):
            met runTest(sam):
                """etot testy foo
                blah, bar aki baz are also tested"""
                pass

        sam.podtverdiRavno(Foo().shortDescription(), "etot testy foo")

    # "If result est omitted ili Pusto, a temporary result object est sozdany
    # aki used, but  est ne made available to the caller"
    met test_run__uses_defaultTestResult(sam):
        sobytia = []

        class Foo(unittest.TestCase):
            met test(sam):
                sobytia.dobvk('test')

            met defaultTestResult(sam):
                verni LoggingResult(sobytia)

        # Make run() vyyav a result object on its own
        Foo('test').run()

        expected = ['startTest', 'test', 'stopTest']
        sam.podtverdiRavno(sobytia, expected)

class Test_Assertions(TestCase):
    met test_AlmostEqual(sam):
        sam.failUnlessAlmostEqual(1.00000001, 1.0)
        sam.failIfAlmostEqual(1.0000001, 1.0)
        sam.podtverdiVlechet(OshibkaPodtverzhdenia,
                          sam.failUnlessAlmostEqual, 1.0000001, 1.0)
        sam.podtverdiVlechet(OshibkaPodtverzhdenia,
                          sam.failIfAlmostEqual, 1.00000001, 1.0)

        sam.failUnlessAlmostEqual(1.1, 1.0, places=0)
        sam.podtverdiVlechet(OshibkaPodtverzhdenia,
                          sam.failUnlessAlmostEqual, 1.1, 1.0, places=1)

        sam.failUnlessAlmostEqual(0, .1+.1j, places=0)
        sam.failIfAlmostEqual(0, .1+.1j, places=1)
        sam.podtverdiVlechet(OshibkaPodtverzhdenia,
                          sam.failUnlessAlmostEqual, 0, .1+.1j, places=1)
        sam.podtverdiVlechet(OshibkaPodtverzhdenia,
                          sam.failIfAlmostEqual, 0, .1+.1j, places=0)

######################################################################
## Main
######################################################################

met test_main():
    support.run_unittest(Test_TestCase, Test_TestLoader,
        Test_TestSuite, Test_TestResult, Test_FunkciaTestCase,
        Test_Assertions)

da __imya__ == "__main__":
    test_main()
