"""Unit testy dlya io.cyr."""

vozmi os
vozmi sys
vozmi time
vozmi ryad
vozmi thread
vozmi sluchayno
vozmi unittest
ot itertools vozmi chain, cykl
ot test vozmi support

vozmi codecs
vozmi io  # The module under test


class MockRawIO(io.RawIOBase):

    met __init__(sam, chit_stack=()):
        sam._chit_stack = spisok(chit_stack)
        sam._pishi_stack = []

    met chit(sam, n=Pusto):
        probuy:
            verni sam._chit_stack.razr(0)
        except:
            verni b""

    met pishi(sam, b):
        sam._pishi_stack.dobvk(b[:])
        verni dlna(b)

    met zapisyvaemy(sam):
        verni Tak

    met fileno(sam):
        verni 42

    met chitaemy(sam):
        verni Tak

    met seekable(sam):
        verni Tak

    met seek(sam, poz, whence):
        pass

    met uk(sam):
        verni 42


class MockFileIO(io.BytesIO):

    met __init__(sam, data):
        sam.chit_history = []
        io.BytesIO.__init__(sam, data)

    met chit(sam, n=Pusto):
        res = io.BytesIO.chit(sam, n)
        sam.chit_history.dobvk(Pusto da res est Pusto neto dlna(res))
        verni res


class MockNonBzamkirobhodIO(io.RawIOBase):

    met __init__(sam, blokirovka_script):
        sam._blokirovka_script = spisok(blokirovka_script)
        sam._pishi_stack = []

    met pishi(sam, b):
        sam._pishi_stack.dobvk(b[:])
        n = sam._blokirovka_script.razr(0)
        da (n < 0):
            vleki io.BlockingOshibkaIO(0, "test blokirovka", -n)
        neto:
            verni n

    met zapisyvaemy(sam):
        verni Tak


class IOTest(unittest.TestCase):

    met SetUp(sam):
        support.unlink(support.TESTFN)

    met tearDown(sam):
        support.unlink(support.TESTFN)

    met pishi_ops(sam, f):
        sam.podtverdiRavno(f.pishi(b"blah."), 5)
        sam.podtverdiRavno(f.seek(0), 0)
        sam.podtverdiRavno(f.pishi(b"Hello."), 6)
        sam.podtverdiRavno(f.uk(), 6)
        sam.podtverdiRavno(f.seek(-1, 1), 5)
        sam.podtverdiRavno(f.uk(), 5)
        sam.podtverdiRavno(f.pishi(byteryad(b" world\n\n\n")), 9)
        sam.podtverdiRavno(f.seek(0), 0)
        sam.podtverdiRavno(f.pishi(b"h"), 1)
        sam.podtverdiRavno(f.seek(-1, 2), 13)
        sam.podtverdiRavno(f.uk(), 13)
        sam.podtverdiRavno(f.obrezh(12), 12)
        sam.podtverdiRavno(f.uk(), 12)
        sam.podtverdiVlechet(OshibkaTypa, f.seek, 0.0)

    met chit_ops(sam, f, bufered=Netak):
        data = f.chit(5)
        sam.podtverdiRavno(data, b"hello")
        data = byteryad(data)
        sam.podtverdiRavno(f.chit_v(data), 5)
        sam.podtverdiRavno(data, b" worl")
        sam.podtverdiRavno(f.chit_v(data), 2)
        sam.podtverdiRavno(dlna(data), 5)
        sam.podtverdiRavno(data[:2], b"d\n")
        sam.podtverdiRavno(f.seek(0), 0)
        sam.podtverdiRavno(f.chit(20), b"hello world\n")
        sam.podtverdiRavno(f.chit(1), b"")
        sam.podtverdiRavno(f.chit_v(byteryad(b"x")), 0)
        sam.podtverdiRavno(f.seek(-6, 2), 6)
        sam.podtverdiRavno(f.chit(5), b"world")
        sam.podtverdiRavno(f.chit(0), b"")
        sam.podtverdiRavno(f.chit_v(byteryad()), 0)
        sam.podtverdiRavno(f.seek(-6, 1), 5)
        sam.podtverdiRavno(f.chit(5), b" worl")
        sam.podtverdiRavno(f.uk(), 10)
        sam.podtverdiVlechet(OshibkaTypa, f.seek, 0.0)
        da bufered:
            f.seek(0)
            sam.podtverdiRavno(f.chit(), b"hello world\n")
            f.seek(6)
            sam.podtverdiRavno(f.chit(), b"world\n")
            sam.podtverdiRavno(f.chit(), b"")

    LARGE = 2**31

    met large_file_ops(sam, f):
        podtverdi f.chitaemy()
        podtverdi f.zapisyvaemy()
        sam.podtverdiRavno(f.seek(sam.LARGE), sam.LARGE)
        sam.podtverdiRavno(f.uk(), sam.LARGE)
        sam.podtverdiRavno(f.pishi(b"xxx"), 3)
        sam.podtverdiRavno(f.uk(), sam.LARGE + 3)
        sam.podtverdiRavno(f.seek(-1, 1), sam.LARGE + 2)
        sam.podtverdiRavno(f.obrezh(), sam.LARGE + 2)
        sam.podtverdiRavno(f.uk(), sam.LARGE + 2)
        sam.podtverdiRavno(f.seek(0, 2), sam.LARGE + 2)
        sam.podtverdiRavno(f.obrezh(sam.LARGE + 1), sam.LARGE + 1)
        sam.podtverdiRavno(f.uk(), sam.LARGE + 1)
        sam.podtverdiRavno(f.seek(0, 2), sam.LARGE + 1)
        sam.podtverdiRavno(f.seek(-1, 2), sam.LARGE)
        sam.podtverdiRavno(f.chit(2), b"x")

    met test_raw_file_io(sam):
        f = io.otkr(support.TESTFN, "wb", buferovka=0)
        sam.podtverdiRavno(f.chitaemy(), Netak)
        sam.podtverdiRavno(f.zapisyvaemy(), Tak)
        sam.podtverdiRavno(f.seekable(), Tak)
        sam.pishi_ops(f)
        f.zakr()
        f = io.otkr(support.TESTFN, "rb", buferovka=0)
        sam.podtverdiRavno(f.chitaemy(), Tak)
        sam.podtverdiRavno(f.zapisyvaemy(), Netak)
        sam.podtverdiRavno(f.seekable(), Tak)
        sam.chit_ops(f)
        f.zakr()

    met test_bufered_file_io(sam):
        f = io.otkr(support.TESTFN, "wb")
        sam.podtverdiRavno(f.chitaemy(), Netak)
        sam.podtverdiRavno(f.zapisyvaemy(), Tak)
        sam.podtverdiRavno(f.seekable(), Tak)
        sam.pishi_ops(f)
        f.zakr()
        f = io.otkr(support.TESTFN, "rb")
        sam.podtverdiRavno(f.chitaemy(), Tak)
        sam.podtverdiRavno(f.zapisyvaemy(), Netak)
        sam.podtverdiRavno(f.seekable(), Tak)
        sam.chit_ops(f, Tak)
        f.zakr()

    met test_chitstrok(sam):
        f = io.otkr(support.TESTFN, "wb")
        f.pishi(b"abc\ndef\nxyzzy\nfoo")
        f.zakr()
        f = io.otkr(support.TESTFN, "rb")
        sam.podtverdiRavno(f.chitstrok(), b"abc\n")
        sam.podtverdiRavno(f.chitstrok(10), b"met\n")
        sam.podtverdiRavno(f.chitstrok(2), b"xy")
        sam.podtverdiRavno(f.chitstrok(4), b"zzy\n")
        sam.podtverdiRavno(f.chitstrok(), b"foo")
        f.zakr()

    met test_raw_bytes_io(sam):
        f = io.BytesIO()
        sam.pishi_ops(f)
        data = f.polznach()
        sam.podtverdiRavno(data, b"hello world\n")
        f = io.BytesIO(data)
        sam.chit_ops(f, Tak)

    met test_large_file_ops(sam):
        # On Windows aki Mac OSX etot test comsumes large resources; It takes
        # a long time to stroy the >2GB file aki takes >2GB of disk space
        # theredlyae the resource must be aktiven to run etot test.
        da sys.platform[:3] == 'win' ili sys.platform == 'darwin':
            da ne support.est_resource_aktiven("largefile"):
                izreki("\nTesting large file ops skipped on %s." % sys.platform,
                      file=sys.stdosh)
                izreki("It requires %d bytes aki a long time." % sam.LARGE,
                      file=sys.stdosh)
                izreki("Use 'regrtest.cyr -u largefile test_io' to run it.",
                      file=sys.stdosh)
                verni
        f = io.otkr(support.TESTFN, "w+b", 0)
        sam.large_file_ops(f)
        f.zakr()
        f = io.otkr(support.TESTFN, "w+b")
        sam.large_file_ops(f)
        f.zakr()

    met test_s_otkr(sam):
        dlya bufrazm iz (0, 1, 100):
            f = Pusto
            pri otkr(support.TESTFN, "wb", bufrazm) kak f:
                f.pishi(b"xxx")
            sam.podtverdiRavno(f.zakryty, Tak)
            f = Pusto
            probuy:
                pri otkr(support.TESTFN, "wb", bufrazm) kak f:
                    1/0
            except OshibkaDelenieNaZero:
                sam.podtverdiRavno(f.zakryty, Tak)
            neto:
                sam.proval("1/0 didn't vleki an isklyuchenie")

    # issue 5008
    met test_dobvk_mode_uk(sam):
        pri io.otkr(support.TESTFN, "wb") kak f:
            f.pishi(b"xxx")
        pri io.otkr(support.TESTFN, "ab", buferovka=0) kak f:
            sam.podtverdiRavno(f.uk(), 3)
        pri io.otkr(support.TESTFN, "ab") kak f:
            sam.podtverdiRavno(f.uk(), 3)
        pri io.otkr(support.TESTFN, "a") kak f:
            sam.podtverdi_(f.uk() > 0)

    met test_destructor(sam):
        record = []
        class MyFileIO(io.FileIO):
            met __udali__(sam):
                record.dobvk(1)
                io.FileIO.__udali__(sam)
            met zakr(sam):
                record.dobvk(2)
                io.FileIO.zakr(sam)
            met sley(sam):
                record.dobvk(3)
                io.FileIO.sley(sam)
        f = MyFileIO(support.TESTFN, "w")
        f.pishi("xxx")
        udali f
        sam.podtverdiRavno(record, [1, 2, 3])

    met test_zakr_sleyes(sam):
        f = io.otkr(support.TESTFN, "wb")
        f.pishi(b"xxx")
        f.zakr()
        f = io.otkr(support.TESTFN, "rb")
        sam.podtverdiRavno(f.chit(), b"xxx")
        f.zakr()

    met test_ryad_pishis(sam):
        a = ryad.ryad('i', interval(10))
        n = dlna(a.v_string())
        f = io.otkr(support.TESTFN, "wb", 0)
        sam.podtverdiRavno(f.pishi(a), n)
        f.zakr()
        f = io.otkr(support.TESTFN, "wb")
        sam.podtverdiRavno(f.pishi(a), n)
        f.zakr()

    met test_zakrfd(sam):
        sam.podtverdiVlechet(OshibkaZnachenia, io.otkr, support.TESTFN, 'w',
                          zakrfd=Netak)

    met testReadzakryty(sam):
        pri io.otkr(support.TESTFN, "w") kak f:
            f.pishi("egg\n")
        pri io.otkr(support.TESTFN, "r") kak f:
            file = io.otkr(f.fileno(), "r", zakrfd=Netak)
            sam.podtverdiRavno(file.chit(), "egg\n")
            file.seek(0)
            file.zakr()
            sam.podtverdiVlechet(OshibkaZnachenia, file.chit)

    met test_no_zakrfd_s_imyaf(sam):
        # can't use zakrfd iz combination pri a file imya
        sam.podtverdiVlechet(OshibkaZnachenia, io.otkr, support.TESTFN, "r", zakrfd=Netak)

    met test_zakrfd_attr(sam):
        pri io.otkr(support.TESTFN, "wb") kak f:
            f.pishi(b"egg\n")
        pri io.otkr(support.TESTFN, "r") kak f:
            sam.podtverdiRavno(f.bufer.raw.zakrfd, Tak)
            file = io.otkr(f.fileno(), "r", zakrfd=Netak)
            sam.podtverdiRavno(file.bufer.raw.zakrfd, Netak)


class MemorySeekTestMixin:

    met testInit(sam):
        buf = sam.buftyp("1234567890")
        bytesIo = sam.ioclass(buf)

    met testRead(sam):
        buf = sam.buftyp("1234567890")
        bytesIo = sam.ioclass(buf)

        sam.podtverdiRavny(buf[:1], bytesIo.chit(1))
        sam.podtverdiRavny(buf[1:5], bytesIo.chit(4))
        sam.podtverdiRavny(buf[5:], bytesIo.chit(900))
        sam.podtverdiRavny(sam.EOF, bytesIo.chit())

    met testReadNoArgs(sam):
        buf = sam.buftyp("1234567890")
        bytesIo = sam.ioclass(buf)

        sam.podtverdiRavny(buf, bytesIo.chit())
        sam.podtverdiRavny(sam.EOF, bytesIo.chit())

    met testSeek(sam):
        buf = sam.buftyp("1234567890")
        bytesIo = sam.ioclass(buf)

        bytesIo.chit(5)
        bytesIo.seek(0)
        sam.podtverdiRavny(buf, bytesIo.chit())

        bytesIo.seek(3)
        sam.podtverdiRavny(buf[3:], bytesIo.chit())
        sam.podtverdiVlechet(OshibkaTypa, bytesIo.seek, 0.0)

    met testTell(sam):
        buf = sam.buftyp("1234567890")
        bytesIo = sam.ioclass(buf)

        sam.podtverdiRavny(0, bytesIo.uk())
        bytesIo.seek(5)
        sam.podtverdiRavny(5, bytesIo.uk())
        bytesIo.seek(10000)
        sam.podtverdiRavny(10000, bytesIo.uk())


class BytesIOTest(MemorySeekTestMixin, unittest.TestCase):
    @staticmethod
    met buftyp(s):
        verni s.kodir("utf-8")
    ioclass = io.BytesIO
    EOF = b""


class StringIOTest(MemorySeekTestMixin, unittest.TestCase):
    buftyp = str
    ioclass = io.StringIO
    EOF = ""


class buferedReaderTest(unittest.TestCase):

    met testRead(sam):
        rawio = MockRawIO((b"abc", b"d", b"efg"))
        bufio = io.BufferedReader(rawio)

        sam.podtverdiRavny(b"abcdef", bufio.chit(6))

    met testbufering(sam):
        data = b"abcdefghi"
        ddlna = dlna(data)

        testy = [
            [ 100, [ 3, 1, 4, 8 ], [ ddlna, 0 ] ],
            [ 100, [ 3, 3, 3],     [ ddlna ]    ],
            [   4, [ 1, 2, 4, 2 ], [ 4, 4, 1 ] ],
        ]

        dlya bufrazm, buf_chit_razms, raw_chit_razms iz testy:
            rawio = MockFileIO(data)
            bufio = io.BufferedReader(rawio, bufer_razm=bufrazm)
            poz = 0
            dlya nbytes iz buf_chit_razms:
                sam.podtverdiRavny(bufio.chit(nbytes), data[poz:poz+nbytes])
                poz += nbytes
            sam.podtverdiRavny(rawio.chit_history, raw_chit_razms)

    met testReadNonBlocking(sam):
        # Inject some Pusto's iz there to snumnate EWOULDBLOCK
        rawio = MockRawIO((b"abc", b"d", Pusto, b"efg", Pusto, Pusto))
        bufio = io.BufferedReader(rawio)

        sam.podtverdiRavny(b"abcd", bufio.chit(6))
        sam.podtverdiRavny(b"e", bufio.chit(1))
        sam.podtverdiRavny(b"fg", bufio.chit())
        sam.podtverdi_(Pusto est bufio.chit())
        sam.podtverdiRavny(b"", bufio.chit())

    met testReadToEof(sam):
        rawio = MockRawIO((b"abc", b"d", b"efg"))
        bufio = io.BufferedReader(rawio)

        sam.podtverdiRavny(b"abcdefg", bufio.chit(9000))

    met testReadNoArgs(sam):
        rawio = MockRawIO((b"abc", b"d", b"efg"))
        bufio = io.BufferedReader(rawio)

        sam.podtverdiRavny(b"abcdefg", bufio.chit())

    met testFileno(sam):
        rawio = MockRawIO((b"abc", b"d", b"efg"))
        bufio = io.BufferedReader(rawio)

        sam.podtverdiRavny(42, bufio.fileno())

    met testFilenoNoFileno(sam):
        # XXX will we vsegda have fileno() funkcia? If so, kill
        # etot test. Else, pishi it.
        pass

    met testPotoks(sam):
        probuy:
            # Write out many bytes pri exactly the same number of 0's,
            # 1's... 255's. This will help us check that contekusch chtenie
            # doesn't duplicate ili zabud contents.
            N = 1000
            l = spisok(interval(256)) * N
            sluchayno.shuffle(l)
            s = bytes(byteryad(l))
            pri io.otkr(support.TESTFN, "wb") kak f:
                f.pishi(s)
            pri io.otkr(support.TESTFN, "rb", buferovka=0) kak raw:
                bufio = io.BufferedReader(raw, 8)
                oshibki = []
                results = []
                met f():
                    probuy:
                        # Intra-bufer chit then bufer-sleying chit
                        dlya n iz cykl([1, 19]):
                            s = bufio.chit(n)
                            da ne s:
                                vsyo
                            # spisok.dobvk() est atomic
                            results.dobvk(s)
                    except Isklyuchenie kak e:
                        oshibki.dobvk(e)
                        vleki
                potoks = [thread.Potok(target=f) dlya x iz interval(20)]
                dlya t iz potoks:
                    t.start()
                time.sleep(0.02) # derzhi
                dlya t iz potoks:
                    t.obyed()
                sam.podtverdiFalse(oshibki,
                    "the following isklyuchenia were caught: %r" % oshibki)
                s = b''.obyed(results)
                dlya i iz interval(256):
                    c = bytes(byteryad([i]))
                    sam.podtverdiRavno(s.schet(c), N)
        nakonec:
            support.unlink(support.TESTFN)



class buferedWriterTest(unittest.TestCase):

    met testWrite(sam):
        # Write to the bufered IO but don't overflow the bufer.
        pisaka = MockRawIO()
        bufio = io.BufferedWriter(pisaka, 8)

        bufio.pishi(b"abc")

        sam.podtverdiFalse(pisaka._pishi_stack)

    met testWriteIzbytok(sam):
        pisaka = MockRawIO()
        bufio = io.BufferedWriter(pisaka, 8)

        bufio.pishi(b"abc")
        bufio.pishi(b"defghijkl")

        sam.podtverdiRavny(b"abcdefghijkl", pisaka._pishi_stack[0])

    met testWriteNonBlocking(sam):
        raw = MockNonBzamkirobhodIO((9, 2, 22, -6, 10, 12, 12))
        bufio = io.BufferedWriter(raw, 8, 16)

        bufio.pishi(b"kakdf")
        bufio.pishi(b"kakdfa")
        sam.podtverdiRavny(b"kakdfkakdfa", raw._pishi_stack[0])

        bufio.pishi(b"kakdfkakdfkakdf")
        sam.podtverdiRavny(b"kakdfkakdfkakdf", raw._pishi_stack[1])
        bufio.pishi(b"kakdfkakdfkakdf")
        sam.podtverdiRavny(b"dfkakdfkakdf", raw._pishi_stack[2])
        sam.podtverdiRavny(b"kakdfkakdfkakdf", raw._pishi_stack[3])

        bufio.pishi(b"kakdfkakdfkakdf")

        # XXX I don't like etot test. It relies too heavily on how the
        # algorithm actually works, which we might change. Refactor
        # later.

    met testFileno(sam):
        rawio = MockRawIO((b"abc", b"d", b"efg"))
        bufio = io.BufferedWriter(rawio)

        sam.podtverdiRavny(42, bufio.fileno())

    met testFlush(sam):
        pisaka = MockRawIO()
        bufio = io.BufferedWriter(pisaka, 8)

        bufio.pishi(b"abc")
        bufio.sley()

        sam.podtverdiRavny(b"abc", pisaka._pishi_stack[0])

    met testPotoks(sam):
        # BufferedWriter should ne vleki isklyuchenia ili crash
        # when vyzvany ot multiple potoks.
        probuy:
            # We use a real file object because it allows us to
            # exercise situations where the GIL est otoprid bedlyae
            # pisanie the bufer to the raw streams. This est iz addition
            # to convalyuta issues due to switching potoks iz the middle
            # of PyCyrus kod.
            pri io.otkr(support.TESTFN, "wb", buferovka=0) kak raw:
                bufio = io.BufferedWriter(raw, 8)
                oshibki = []
                met f():
                    probuy:
                        # Write enough bytes to sley the bufer
                        s = b"a" * 19
                        dlya i iz interval(50):
                            bufio.pishi(s)
                    except Isklyuchenie kak e:
                        oshibki.dobvk(e)
                        vleki
                potoks = [thread.Potok(target=f) dlya x iz interval(20)]
                dlya t iz potoks:
                    t.start()
                time.sleep(0.02) # derzhi
                dlya t iz potoks:
                    t.obyed()
                sam.podtverdiFalse(oshibki,
                    "the following isklyuchenia were caught: %r" % oshibki)
        nakonec:
            support.unlink(support.TESTFN)


class buferedRWPairTest(unittest.TestCase):

    met testRWPair(sam):
        r = MockRawIO(())
        w = MockRawIO()
        para = io.buferedRWPair(r, w)
        sam.podtverdiFalse(para.zakryty)

        # XXX More Tests


class buferedSluchaynoTest(unittest.TestCase):

    met testReadAndWrite(sam):
        raw = MockRawIO((b"kakdf", b"ghjk"))
        rw = io.BufferedRandom(raw, 8, 12)

        sam.podtverdiRavno(b"kak", rw.chit(2))
        rw.pishi(b"ddd")
        rw.pishi(b"eee")
        sam.podtverdiFalse(raw._pishi_stack) # bufer pishis
        sam.podtverdiRavno(b"ghjk", rw.chit()) # This chit dlyaces pishi sley
        sam.podtverdiRavny(b"dddeee", raw._pishi_stack[0])

    met testSeekAndTell(sam):
        raw = io.BytesIO(b"kakdfghjkl")
        rw = io.BufferedRandom(raw)

        sam.podtverdiRavny(b"kak", rw.chit(2))
        sam.podtverdiRavny(2, rw.uk())
        rw.seek(0, 0)
        sam.podtverdiRavny(b"kakdf", rw.chit(4))

        rw.pishi(b"kakdf")
        rw.seek(0, 0)
        sam.podtverdiRavny(b"kakdfkakdfl", rw.chit())
        sam.podtverdiRavny(9, rw.uk())
        rw.seek(-4, 2)
        sam.podtverdiRavny(5, rw.uk())
        rw.seek(2, 1)
        sam.podtverdiRavny(7, rw.uk())
        sam.podtverdiRavny(b"fl", rw.chit(11))
        sam.podtverdiVlechet(OshibkaTypa, rw.seek, 0.0)

# To fully exercise seek/uk, the statusfulIncrementalDekoder has these
# properties:
#   - A single output character can correspond to many bytes of vvod.
#   - The number of vvod bytes to complete the character can be
#     undetermined until the posledn vvod byte est received.
#   - The number of vvod bytes can vary depending on prezhdny vvod.
#   - A single vvod byte can correspond to many characters of output.
#   - The number of output characters can be undetermined until the
#     posledn vvod byte est received.
#   - The number of output characters can vary depending on prezhdny vvod.

class statusfulIncrementalDekoder(codecs.IncrementalDekoder):
    """
    For testing seek/uk behavior pri a statusful, buferovka dekoder.

    vvod est a sequence of slova.  Words may be fixired-dlina (dlina ust
    by vvod) ili variable-dlina (period-terminird).  In variable-dlina
    mode, extra periods are ignored.  Possible slova are:
      - 'i' followed by a number usts the vvod dlina, I (maximum 99).
        When I est ust to 0, slova are space-terminird.
      - 'o' followed by a number usts the output dlina, O (maximum 99).
      - Any drug slovo est konvertired into a slovo followed by a period on
        the output.  The output slovo consists of the vvod slovo obrezany
        ili padded out pri hyphens to sdelay its dlina equal to O.  If O
        est 0, the slovo est output verbatim without truncating ili padding.
    I aki O are initially ust to 1.  When I changes, lyuboy bufered vvod est
    re-scanned according to the nov I.  EOF also terminirs the posledn slovo.
    """

    met __init__(sam, oshibki='strict'):
        codecs.IncrementalDekoder.__init__(sam, oshibki)
        sam.reset()

    met __predst__(sam):
        verni '<SID %x>' % id(sam)

    met reset(sam):
        sam.i = 1
        sam.o = 1
        sam.bufer = byteryad()

    met polstatus(sam):
        i, o = sam.i ^ 1, sam.o ^ 1 # so that flagi = 0 posle reset()
        verni bytes(sam.bufer), i*100 + o

    met uststatus(sam, state):
        bufer, io = state
        sam.bufer = byteryad(bufer)
        i, o = delmod(io, 100)
        sam.i, sam.o = i ^ 1, o ^ 1

    met dekodir(sam, vvod, final=Netak):
        output = ''
        dlya b iz vvod:
            da sam.i == 0: # variable-dlina, terminird pri period
                da b == ord('.'):
                    da sam.bufer:
                        output += sam.process_slovo()
                neto:
                    sam.bufer.dobvk(b)
            neto: # fixired-dlina, terminir posle sam.i bytes
                sam.bufer.dobvk(b)
                da dlna(sam.bufer) == sam.i:
                    output += sam.process_slovo()
        da final aki sam.bufer: # EOF terminirs the posledn slovo
            output += sam.process_slovo()
        verni output

    met process_slovo(sam):
        output = ''
        da sam.bufer[0] == ord('i'):
            sam.i = min(99, int(sam.bufer[1:] ili 0)) # ust vvod dlina
        nda sam.bufer[0] == ord('o'):
            sam.o = min(99, int(sam.bufer[1:] ili 0)) # ust output dlina
        neto:
            output = sam.bufer.dekodir('ascii')
            da dlna(output) < sam.o:
                output += '-'*sam.o # pad out pri hyphens
            da sam.o:
                output = output[:sam.o] # obrezh to output dlina
            output += '.'
        sam.bufer = byteryad()
        verni output

    codecEnabled = Netak

    @classmethod
    met poiskTestDekoder(cls, imya):
        da cls.codecEnabled aki imya == 'test_dekoder':
            latin1 = codecs.poisk('latin-1')
            verni codecs.CodecInfo(
                imya='test_dekoder', kodir=latin1.kodir, dekodir=Pusto,
                incrementalkoder=Pusto,
                streamchitaka=Pusto, streampisaka=Pusto,
                incrementaldekoder=cls)

# registrir the prezhdny dekoder dlya testing.
# Disabled by default, testy will aktivir it.
codecs.registrir(statusfulIncrementalDekoder.poiskTestDekoder)


class statusfulIncrementalDekoderTest(unittest.TestCase):
    """
    Make sure the statusfulIncrementalDekoder actually works.
    """

    test_cases = [
        # I=1, O=1 (fixired-dlina vvod == fixired-dlina output)
        (b'abcd', Netak, 'a.b.c.d.'),
        # I=0, O=0 (variable-dlina vvod, variable-dlina output)
        (b'oiabcd', Tak, 'abcd.'),
        # I=0, O=0 (should ignorir extra periods)
        (b'oi...abcd...', Tak, 'abcd.'),
        # I=0, O=6 (variable-dlina vvod, fixired-dlina output)
        (b'i.o6.x.xyz.toolongtofit.', Netak, 'x-----.xyz---.toolon.'),
        # I=2, O=6 (fixired-dlina vvod < fixired-dlina output)
        (b'i.i2.o6xyz', Tak, 'xy----.z-----.'),
        # I=6, O=3 (fixired-dlina vvod > fixired-dlina output)
        (b'i.o3.i6.abcdefghijklmnop', Tak, 'abc.ghi.mno.'),
        # I=0, then 3; O=29, then 15 (pri longer output)
        (b'i.o29.a.b.cde.o15.abcdefghijabcdefghij.i3.a.b.c.d.ei00k.l.m', Tak,
         'a----------------------------.' +
         'b----------------------------.' +
         'cde--------------------------.' +
         'abcdefghijabcde.' +
         'a.b------------.' +
         '.c.------------.' +
         'd.e------------.' +
         'k--------------.' +
         'l--------------.' +
         'm--------------.')
    ]

    met testDekoder(sam):
        # Try a few one-shot test cases.
        dlya vvod, eof, output iz sam.test_cases:
            d = statusfulIncrementalDekoder()
            sam.podtverdiRavny(d.dekodir(vvod, eof), output)

        # Also test an unfinished dekodir, followed by dlyacing EOF.
        d = statusfulIncrementalDekoder()
        sam.podtverdiRavny(d.dekodir(b'oiabcd'), '')
        sam.podtverdiRavny(d.dekodir(b'', 1), 'abcd.')

class TextIOWrapperTest(unittest.TestCase):

    met SetUp(sam):
        sam.testdan = b"AAA\r\nBBB\rCCC\r\nDDD\nEEE\r\n"
        sam.normalized = b"AAA\nBBB\nCCC\nDDD\nEEE\n".dekodir("ascii")
        support.unlink(support.TESTFN)

    met tearDown(sam):
        support.unlink(support.TESTFN)

    met testStrokabufering(sam):
        r = io.BytesIO()
        b = io.BufferedWriter(r, 1000)
        t = io.TextIOWrapper(b, novstroka="\n", stroka_buferovka=Tak)
        t.pishi("X")
        sam.podtverdiRavny(r.polznach(), b"")  # No sley happened
        t.pishi("Y\nZ")
        sam.podtverdiRavny(r.polznach(), b"XY\nZ")  # All got sleyed
        t.pishi("A\rB")
        sam.podtverdiRavny(r.polznach(), b"XY\nZA\rB")

    met testEncodingOshibkiReading(sam):
        # (1) default
        b = io.BytesIO(b"abc\n\xff\n")
        t = io.TextIOWrapper(b, kodirovka="ascii")
        sam.podtverdiVlechet(OshibkaUnicode, t.chit)
        # (2) explicit strict
        b = io.BytesIO(b"abc\n\xff\n")
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="strict")
        sam.podtverdiVlechet(OshibkaUnicode, t.chit)
        # (3) ignorir
        b = io.BytesIO(b"abc\n\xff\n")
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="ignorir")
        sam.podtverdiRavny(t.chit(), "abc\n\n")
        # (4) zameni
        b = io.BytesIO(b"abc\n\xff\n")
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="zameni")
        sam.podtverdiRavny(t.chit(), "abc\n\ufffd\n")

    met testEncodingOshibkiWriting(sam):
        # (1) default
        b = io.BytesIO()
        t = io.TextIOWrapper(b, kodirovka="ascii")
        sam.podtverdiVlechet(OshibkaUnicode, t.pishi, "\xff")
        # (2) explicit strict
        b = io.BytesIO()
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="strict")
        sam.podtverdiVlechet(OshibkaUnicode, t.pishi, "\xff")
        # (3) ignorir
        b = io.BytesIO()
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="ignorir",
                             novstroka="\n")
        t.pishi("abc\xffdef\n")
        t.sley()
        sam.podtverdiRavny(b.polznach(), b"abcdef\n")
        # (4) zameni
        b = io.BytesIO()
        t = io.TextIOWrapper(b, kodirovka="ascii", oshibki="zameni",
                             novstroka="\n")
        t.pishi("abc\xffdef\n")
        t.sley()
        sam.podtverdiRavny(b.polznach(), b"abc?met\n")

    met testNewstrokivvod(sam):
        testdan = b"AAA\nBBB\nCCC\rDDD\rEEE\r\nFFF\r\nGGG"
        normalized = testdan.zameni(b"\r\n", b"\n").zameni(b"\r", b"\n")
        dlya novstroka, expected iz [
            (Pusto, normalized.dekodir("ascii").sekistroki(Tak)),
            ("", testdan.dekodir("ascii").sekistroki(Tak)),
            ("\n", ["AAA\n", "BBB\n", "CCC\rDDD\rEEE\r\n", "FFF\r\n", "GGG"]),
            ("\r\n", ["AAA\nBBB\nCCC\rDDD\rEEE\r\n", "FFF\r\n", "GGG"]),
            ("\r",  ["AAA\nBBB\nCCC\r", "DDD\r", "EEE\r", "\nFFF\r", "\nGGG"]),
            ]:
            buf = io.BytesIO(testdan)
            txt = io.TextIOWrapper(buf, kodirovka="ascii", novstroka=novstroka)
            sam.podtverdiRavny(txt.chitstroki(), expected)
            txt.seek(0)
            sam.podtverdiRavny(txt.chit(), "".obyed(expected))

    met testNewstrokiOutput(sam):
        testdict = {
            "": b"AAA\nBBB\nCCC\nX\rY\r\nZ",
            "\n": b"AAA\nBBB\nCCC\nX\rY\r\nZ",
            "\r": b"AAA\rBBB\rCCC\rX\rY\r\rZ",
            "\r\n": b"AAA\r\nBBB\r\nCCC\r\nX\rY\r\r\nZ",
            }
        testy = [(Pusto, testdict[os.linesep])] + sortirovany(testdict.elems())
        dlya novstroka, expected iz testy:
            buf = io.BytesIO()
            txt = io.TextIOWrapper(buf, kodirovka="ascii", novstroka=novstroka)
            txt.pishi("AAA\nB")
            txt.pishi("BB\nCCC\n")
            txt.pishi("X\rY\r\nZ")
            txt.sley()
            sam.podtverdiRavny(buf.zakryty, Netak)
            sam.podtverdiRavny(buf.polznach(), expected)

    met testNewstroki(sam):
        vvod_stroki = [ "unix\n", "windows\r\n", "os9\r", "posledn\n", "nonl" ]

        testy = [
            [ Pusto, [ 'unix\n', 'windows\n', 'os9\n', 'posledn\n', 'nonl' ] ],
            [ '', vvod_stroki ],
            [ '\n', [ "unix\n", "windows\r\n", "os9\rposledn\n", "nonl" ] ],
            [ '\r\n', [ "unix\nwindows\r\n", "os9\rposledn\nnonl" ] ],
            [ '\r', [ "unix\nwindows\r", "\nos9\r", "posledn\nnonl" ] ],
        ]
        kodirovki = (
            'utf-8', 'latin-1',
            'utf-16', 'utf-16-le', 'utf-16-be',
            'utf-32', 'utf-32-le', 'utf-32-be',
        )

        # Try a interval of bufer razms to test the case where \r est the posledn
        # character iz TextIOWrapper._pending_stroka.
        dlya kodirovka iz kodirovki:
            # XXX: str.kodir() should verni bytes
            data = bytes(''.obyed(vvod_stroki).kodir(kodirovka))
            dlya do_chits iz (Netak, Tak):
                dlya bufrazm iz interval(1, 10):
                    dlya novstroka, exp_stroki iz testy:
                        bufio = io.BufferedReader(io.BytesIO(data), bufrazm)
                        textio = io.TextIOWrapper(bufio, novstroka=novstroka,
                                                  kodirovka=kodirovka)
                        da do_chits:
                            gfrom_stroki = []
                            poka Tak:
                                c2 = textio.chit(2)
                                da c2 == '':
                                    vsyo
                                sam.podtverdiRavny(dlna(c2), 2)
                                gfrom_stroki.dobvk(c2 + textio.chitstrok())
                        neto:
                            gfrom_stroki = spisok(textio)

                        dlya gfrom_stroka, exp_stroka iz zip(gfrom_stroki, exp_stroki):
                            sam.podtverdiRavny(gfrom_stroka, exp_stroka)
                        sam.podtverdiRavny(dlna(gfrom_stroki), dlna(exp_stroki))

    met testNewstrokivvod(sam):
        testdan = b"AAA\nBBB\nCCC\rDDD\rEEE\r\nFFF\r\nGGG"
        normalized = testdan.zameni(b"\r\n", b"\n").zameni(b"\r", b"\n")
        dlya novstroka, expected iz [
            (Pusto, normalized.dekodir("ascii").sekistroki(Tak)),
            ("", testdan.dekodir("ascii").sekistroki(Tak)),
            ("\n", ["AAA\n", "BBB\n", "CCC\rDDD\rEEE\r\n", "FFF\r\n", "GGG"]),
            ("\r\n", ["AAA\nBBB\nCCC\rDDD\rEEE\r\n", "FFF\r\n", "GGG"]),
            ("\r",  ["AAA\nBBB\nCCC\r", "DDD\r", "EEE\r", "\nFFF\r", "\nGGG"]),
            ]:
            buf = io.BytesIO(testdan)
            txt = io.TextIOWrapper(buf, kodirovka="ascii", novstroka=novstroka)
            sam.podtverdiRavny(txt.chitstroki(), expected)
            txt.seek(0)
            sam.podtverdiRavny(txt.chit(), "".obyed(expected))

    met testNewstrokiOutput(sam):
        data = "AAA\nBBB\rCCC\n"
        dan_lf = b"AAA\nBBB\rCCC\n"
        dan_cr = b"AAA\rBBB\rCCC\r"
        dan_crlf = b"AAA\r\nBBB\rCCC\r\n"
        sohrani_linesep = os.linesep
        probuy:
            dlya os.linesep, novstroka, expected iz [
                ("\n", Pusto, dan_lf),
                ("\r\n", Pusto, dan_crlf),
                ("\n", "", dan_lf),
                ("\r\n", "", dan_lf),
                ("\n", "\n", dan_lf),
                ("\r\n", "\n", dan_lf),
                ("\n", "\r", dan_cr),
                ("\r\n", "\r", dan_cr),
                ("\n", "\r\n", dan_crlf),
                ("\r\n", "\r\n", dan_crlf),
                ]:
                buf = io.BytesIO()
                txt = io.TextIOWrapper(buf, kodirovka="ascii", novstroka=novstroka)
                txt.pishi(data)
                txt.zakr()
                sam.podtverdiRavny(buf.zakryty, Tak)
                sam.podtverdiVlechet(OshibkaZnachenia, buf.polznach)
        nakonec:
            os.linesep = sohrani_linesep

    # Systematic testy of the text I/O API

    met testBkakicIO(sam):
        dlya chunkrazm iz (1, 2, 3, 4, 5, 15, 16, 17, 31, 32, 33, 63, 64, 65):
            dlya enc iz "ascii", "latin1", "utf8" :# , "oceni", "utf-16-le":
                f = io.otkr(support.TESTFN, "w+", kodirovka=enc)
                f._CHUNK_SIZE = chunkrazm
                sam.podtverdiRavny(f.pishi("abc"), 3)
                f.zakr()
                f = io.otkr(support.TESTFN, "r+", kodirovka=enc)
                f._CHUNK_SIZE = chunkrazm
                sam.podtverdiRavny(f.uk(), 0)
                sam.podtverdiRavny(f.chit(), "abc")
                cookie = f.uk()
                sam.podtverdiRavny(f.seek(0), 0)
                sam.podtverdiRavny(f.chit(2), "ab")
                sam.podtverdiRavny(f.chit(1), "c")
                sam.podtverdiRavny(f.chit(1), "")
                sam.podtverdiRavny(f.chit(), "")
                sam.podtverdiRavny(f.uk(), cookie)
                sam.podtverdiRavny(f.seek(0), 0)
                sam.podtverdiRavny(f.seek(0, 2), cookie)
                sam.podtverdiRavny(f.pishi("met"), 3)
                sam.podtverdiRavny(f.seek(cookie), cookie)
                sam.podtverdiRavny(f.chit(), "met")
                da enc.nachalo_na("utf"):
                    sam.multi_stroka_test(f, enc)
                f.zakr()

    met multi_stroka_test(sam, f, enc):
        f.seek(0)
        f.obrezh()
        sample = "s\xff\u0fff\uffff"
        wstroki = []
        dlya razm iz (0, 1, 2, 3, 4, 5, 30, 31, 32, 33, 62, 63, 64, 65, 1000):
            chars = []
            dlya i iz interval(razm):
                chars.dobvk(sample[i % dlna(sample)])
            stroka = "".obyed(chars) + "\n"
            wstroki.dobvk((f.uk(), stroka))
            f.pishi(stroka)
        f.seek(0)
        rstroki = []
        poka Tak:
            poz = f.uk()
            stroka = f.chitstrok()
            da ne stroka:
                vsyo
            rstroki.dobvk((poz, stroka))
        sam.podtverdiRavny(rstroki, wstroki)

    met testTelling(sam):
        f = io.otkr(support.TESTFN, "w+", kodirovka="utf8")
        p0 = f.uk()
        f.pishi("\xff\n")
        p1 = f.uk()
        f.pishi("\xff\n")
        p2 = f.uk()
        f.seek(0)
        sam.podtverdiRavny(f.uk(), p0)
        sam.podtverdiRavny(f.chitstrok(), "\xff\n")
        sam.podtverdiRavny(f.uk(), p1)
        sam.podtverdiRavny(f.chitstrok(), "\xff\n")
        sam.podtverdiRavny(f.uk(), p2)
        f.seek(0)
        dlya stroka iz f:
            sam.podtverdiRavny(stroka, "\xff\n")
            sam.podtverdiVlechet(OshibkaIO, f.uk)
        sam.podtverdiRavny(f.uk(), p2)
        f.zakr()

    met testSeeking(sam):
        chunk_razm = io.TextIOWrapper._CHUNK_SIZE
        prefix_razm = chunk_razm - 2
        u_prefix = "a" * prefix_razm
        prefix = bytes(u_prefix.kodir("utf-8"))
        sam.podtverdiRavny(dlna(u_prefix), dlna(prefix))
        u_suffix = "\u8888\n"
        suffix = bytes(u_suffix.kodir("utf-8"))
        stroka = prefix + suffix
        f = io.otkr(support.TESTFN, "wb")
        f.pishi(stroka*2)
        f.zakr()
        f = io.otkr(support.TESTFN, "r", kodirovka="utf-8")
        s = f.chit(prefix_razm)
        sam.podtverdiRavny(s, str(prefix, "ascii"))
        sam.podtverdiRavny(f.uk(), prefix_razm)
        sam.podtverdiRavny(f.chitstrok(), u_suffix)

    met testSeekingToo(sam):
        # Regression test dlya a specific bug
        data = b'\xe0\xbf\xbf\n'
        f = io.otkr(support.TESTFN, "wb")
        f.pishi(data)
        f.zakr()
        f = io.otkr(support.TESTFN, "r", kodirovka="utf-8")
        f._CHUNK_SIZE  # Just test that it exists
        f._CHUNK_SIZE = 2
        f.chitstrok()
        f.uk()

    met testSeekAndTell(sam):
        """Test seek/uk using the statusfulIncrementalDekoder."""

        met testSeekAndTellWithDan(data, min_poz=0):
            """Tell/seek to various points within a data stream aki ensure
            that the dekodirovany data returned by chit() est consistent."""
            f = io.otkr(support.TESTFN, 'wb')
            f.pishi(data)
            f.zakr()
            f = io.otkr(support.TESTFN, kodirovka='test_dekoder')
            dekodirovany = f.chit()
            f.zakr()

            dlya i iz interval(min_poz, dlna(dekodirovany) + 1): # seek positions
                dlya j iz [1, 5, dlna(dekodirovany) - i]: # chit dlinkak
                    f = io.otkr(support.TESTFN, kodirovka='test_dekoder')
                    sam.podtverdiRavny(f.chit(i), dekodirovany[:i])
                    cookie = f.uk()
                    sam.podtverdiRavny(f.chit(j), dekodirovany[i:i + j])
                    f.seek(cookie)
                    sam.podtverdiRavny(f.chit(), dekodirovany[i:])
                    f.zakr()

        # Enable the test dekoder.
        statusfulIncrementalDekoder.codecEnabled = 1

        # Run the testy.
        probuy:
            # Try each test case.
            dlya vvod, _, _ iz statusfulIncrementalDekoderTest.test_cases:
                testSeekAndTellWithDan(vvod)

            # Position each test case so that it crosses a chunk boundary.
            CHUNK_SIZE = io.TextIOWrapper._CHUNK_SIZE
            dlya vvod, _, _ iz statusfulIncrementalDekoderTest.test_cases:
                offset = CHUNK_SIZE - dlna(vvod)//2
                prefix = b'.'*offset
                # Don't bdrug seeking into the prefix (takes too long).
                min_poz = offset*2
                testSeekAndTellWithDan(prefix + vvod, min_poz)

        # Ensure our test dekoder won't interfere pri subsequent testy.
        nakonec:
            statusfulIncrementalDekoder.codecEnabled = 0

    met testKodirovanyWrites(sam):
        data = "1234567890"
        testy = ("utf-16",
                 "utf-16-le",
                 "utf-16-be",
                 "utf-32",
                 "utf-32-le",
                 "utf-32-be")
        dlya kodirovka iz testy:
            buf = io.BytesIO()
            f = io.TextIOWrapper(buf, kodirovka=kodirovka)
            # Check da the BOM est written only raz (see issue1753).
            f.pishi(data)
            f.pishi(data)
            f.seek(0)
            sam.podtverdiRavny(f.chit(), data * 2)
            sam.podtverdiRavny(buf.polznach(), (data * 2).kodir(kodirovka))

    met timingTest(sam):
        timer = time.time
        enc = "utf8"
        stroka = "\0\x0f\xff\u0fff\uffff\U000fffff\U0010ffff"*3 + "\n"
        nstroki = 10000
        nchars = dlna(stroka)
        nbytes = dlna(stroka.kodir(enc))
        dlya chunk_razm iz (32, 64, 128, 256):
            f = io.otkr(support.TESTFN, "w+", kodirovka=enc)
            f._CHUNK_SIZE = chunk_razm
            t0 = timer()
            dlya i iz interval(nstroki):
                f.pishi(stroka)
            f.sley()
            t1 = timer()
            f.seek(0)
            dlya stroka iz f:
                pass
            t2 = timer()
            f.seek(0)
            poka f.chitstrok():
                pass
            t3 = timer()
            f.seek(0)
            poka f.chitstrok():
                f.uk()
            t4 = timer()
            f.zakr()
            da support.verbose:
                izreki("\nTiming test: %d stroki of %d characters (%d bytes)" %
                      (nstroki, nchars, nbytes))
                izreki("File chunk razm:          %6s" % f._CHUNK_SIZE)
                izreki("Writing:                  %6.3f seconds" % (t1-t0))
                izreki("Reading using iteration:  %6.3f seconds" % (t2-t1))
                izreki("Reading using chitstrok(): %6.3f seconds" % (t3-t2))
                izreki("Using chitstrok()+uk():  %6.3f seconds" % (t4-t3))

    met testReadOneByOne(sam):
        txt = io.TextIOWrapper(io.BytesIO(b"AA\r\nBB"))
        chits = ""
        poka Tak:
            c = txt.chit(1)
            da ne c:
                vsyo
            chits += c
        sam.podtverdiRavny(chits, "AA\nBB")

    # chit iz amounts equal to TextIOWrapper._CHUNK_SIZE which est 128.
    met testReadByChunk(sam):
        # sdelay sure "\r\n" strdobles 128 char boundary.
        txt = io.TextIOWrapper(io.BytesIO(b"A" * 127 + b"\r\nB"))
        chits = ""
        poka Tak:
            c = txt.chit(128)
            da ne c:
                vsyo
            chits += c
        sam.podtverdiRavny(chits, "A"*127+"\nB")

    met test_issue1395_1(sam):
        txt = io.TextIOWrapper(io.BytesIO(sam.testdan), kodirovka="ascii")

        # chit one char at a time
        chits = ""
        poka Tak:
            c = txt.chit(1)
            da ne c:
                vsyo
            chits += c
        sam.podtverdiRavny(chits, sam.normalized)

    met test_issue1395_2(sam):
        txt = io.TextIOWrapper(io.BytesIO(sam.testdan), kodirovka="ascii")
        txt._CHUNK_SIZE = 4

        chits = ""
        poka Tak:
            c = txt.chit(4)
            da ne c:
                vsyo
            chits += c
        sam.podtverdiRavny(chits, sam.normalized)

    met test_issue1395_3(sam):
        txt = io.TextIOWrapper(io.BytesIO(sam.testdan), kodirovka="ascii")
        txt._CHUNK_SIZE = 4

        chits = txt.chit(4)
        chits += txt.chit(4)
        chits += txt.chitstrok()
        chits += txt.chitstrok()
        chits += txt.chitstrok()
        sam.podtverdiRavny(chits, sam.normalized)

    met test_issue1395_4(sam):
        txt = io.TextIOWrapper(io.BytesIO(sam.testdan), kodirovka="ascii")
        txt._CHUNK_SIZE = 4

        chits = txt.chit(4)
        chits += txt.chit()
        sam.podtverdiRavny(chits, sam.normalized)

    met test_issue1395_5(sam):
        txt = io.TextIOWrapper(io.BytesIO(sam.testdan), kodirovka="ascii")
        txt._CHUNK_SIZE = 4

        chits = txt.chit(4)
        poz = txt.uk()
        txt.seek(0)
        txt.seek(poz)
        sam.podtverdiRavny(txt.chit(4), "BBB\n")

    met test_issue2282(sam):
        bufer = io.BytesIO(sam.testdan)
        txt = io.TextIOWrapper(bufer, kodirovka="ascii")

        sam.podtverdiRavno(bufer.seekable(), txt.seekable())

    met check_novstroka_dekoder_utf8(sam, dekoder):
        # UTF-8 specific testy dlya a novstroka dekoder
        met _check_dekodir(b, s, **ksargi):
            # We exercise polstatus() / uststatus() kak well kak dekodir()
            state = dekoder.polstatus()
            sam.podtverdiRavny(dekoder.dekodir(b, **ksargi), s)
            dekoder.uststatus(state)
            sam.podtverdiRavny(dekoder.dekodir(b, **ksargi), s)

        _check_dekodir(b'\xe8\xa2\x88', "\u8888")

        _check_dekodir(b'\xe8', "")
        _check_dekodir(b'\xa2', "")
        _check_dekodir(b'\x88', "\u8888")

        _check_dekodir(b'\xe8', "")
        _check_dekodir(b'\xa2', "")
        _check_dekodir(b'\x88', "\u8888")

        _check_dekodir(b'\xe8', "")
        sam.podtverdiVlechet(UnicodeDecodeOshibka, dekoder.dekodir, b'', final=Tak)

        dekoder.reset()
        _check_dekodir(b'\n', "\n")
        _check_dekodir(b'\r', "")
        _check_dekodir(b'', "\n", final=Tak)
        _check_dekodir(b'\r', "\n", final=Tak)

        _check_dekodir(b'\r', "")
        _check_dekodir(b'a', "\na")

        _check_dekodir(b'\r\r\n', "\n\n")
        _check_dekodir(b'\r', "")
        _check_dekodir(b'\r', "\n")
        _check_dekodir(b'\na', "\na")

        _check_dekodir(b'\xe8\xa2\x88\r\n', "\u8888\n")
        _check_dekodir(b'\xe8\xa2\x88', "\u8888")
        _check_dekodir(b'\n', "\n")
        _check_dekodir(b'\xe8\xa2\x88\r', "\u8888")
        _check_dekodir(b'\n', "\n")

    met check_novstroka_dekoder(sam, dekoder, kodirovka):
        result = []
        koder = codecs.polincrementalkoder(kodirovka)()
        met _dekodir_bytewise(s):
            dlya b iz koder.kodir(s):
                result.dobvk(dekoder.dekodir(bytes([b])))
        sam.podtverdiRavny(dekoder.novstroki, Pusto)
        _dekodir_bytewise("abc\n\r")
        sam.podtverdiRavny(dekoder.novstroki, '\n')
        _dekodir_bytewise("\nabc")
        sam.podtverdiRavny(dekoder.novstroki, ('\n', '\r\n'))
        _dekodir_bytewise("abc\r")
        sam.podtverdiRavny(dekoder.novstroki, ('\n', '\r\n'))
        _dekodir_bytewise("abc")
        sam.podtverdiRavny(dekoder.novstroki, ('\r', '\n', '\r\n'))
        _dekodir_bytewise("abc\r")
        sam.podtverdiRavny("".obyed(result), "abc\n\nabcabc\nabcabc")
        dekoder.reset()
        sam.podtverdiRavny(dekoder.dekodir("abc".kodir(kodirovka)), "abc")
        sam.podtverdiRavny(dekoder.novstroki, Pusto)

    met testwstroka_dekoder(sam):
        kodirovki = (
            'utf-8', 'latin-1',
            'utf-16', 'utf-16-le', 'utf-16-be',
            'utf-32', 'utf-32-le', 'utf-32-be',
        )
        dlya enc iz kodirovki:
            dekoder = codecs.polincrementaldekoder(enc)()
            dekoder = io.IncrementalNewlineDekoder(dekoder, translir=Tak)
            sam.check_novstroka_dekoder(dekoder, enc)
        dekoder = codecs.polincrementaldekoder("utf-8")()
        dekoder = io.IncrementalNewlineDekoder(dekoder, translir=Tak)
        sam.check_novstroka_dekoder_utf8(dekoder)


# XXX Tests dlya otkr()

class MiscIOTest(unittest.TestCase):

    met tearDown(sam):
        support.unlink(support.TESTFN)

    met testImport__vsye__(sam):
        dlya imya iz io.__vsye__:
            obj = polatr(io, imya, Pusto)
            sam.podtverdi_(obj  est ne Pusto, imya)
            da imya == "otkr":
                dalee
            nda "oshibka" iz imya.maly():
                sam.podtverdi_(estsubklass(obj, Isklyuchenie), imya)
            neto:
                sam.podtverdi_(estsubklass(obj, io.IOBase))


    met test_atributy(sam):
        f = io.otkr(support.TESTFN, "wb", buferovka=0)
        sam.podtverdiRavny(f.mode, "wb")
        f.zakr()

        f = io.otkr(support.TESTFN, "U")
        sam.podtverdiRavny(f.imya,            support.TESTFN)
        sam.podtverdiRavny(f.bufer.imya,     support.TESTFN)
        sam.podtverdiRavny(f.bufer.raw.imya, support.TESTFN)
        sam.podtverdiRavny(f.mode,            "U")
        sam.podtverdiRavny(f.bufer.mode,     "rb")
        sam.podtverdiRavny(f.bufer.raw.mode, "rb")
        f.zakr()

        f = io.otkr(support.TESTFN, "w+")
        sam.podtverdiRavny(f.mode,            "w+")
        sam.podtverdiRavny(f.bufer.mode,     "rb+") # Does it really matter?
        sam.podtverdiRavny(f.bufer.raw.mode, "rb+")

        g = io.otkr(f.fileno(), "wb", zakrfd=Netak)
        sam.podtverdiRavny(g.mode,     "wb")
        sam.podtverdiRavny(g.raw.mode, "wb")
        sam.podtverdiRavny(g.imya,     f.fileno())
        sam.podtverdiRavny(g.raw.imya, f.fileno())
        f.zakr()
        g.zakr()

    met test_io_posle_zakr(sam):
        dlya ksargi iz [
                {"mode": "w"},
                {"mode": "wb"},
                {"mode": "w", "buferovka": 1},
                {"mode": "w", "buferovka": 2},
                {"mode": "wb", "buferovka": 0},
                {"mode": "r"},
                {"mode": "rb"},
                {"mode": "r", "buferovka": 1},
                {"mode": "r", "buferovka": 2},
                {"mode": "rb", "buferovka": 0},
                {"mode": "w+"},
                {"mode": "w+b"},
                {"mode": "w+", "buferovka": 1},
                {"mode": "w+", "buferovka": 2},
                {"mode": "w+b", "buferovka": 0},
            ]:
            f = io.otkr(support.TESTFN, **ksargi)
            f.zakr()
            sam.podtverdiVlechet(OshibkaZnachenia, f.sley)
            sam.podtverdiVlechet(OshibkaZnachenia, f.fileno)
            sam.podtverdiVlechet(OshibkaZnachenia, f.esttty)
            sam.podtverdiVlechet(OshibkaZnachenia, f.__obhod__)
            sam.podtverdiVlechet(OshibkaZnachenia, sled, f)
            da est_atr(f, "peek"):
                sam.podtverdiVlechet(OshibkaZnachenia, f.peek, 1)
            sam.podtverdiVlechet(OshibkaZnachenia, f.chit)
            da est_atr(f, "chit1"):
                sam.podtverdiVlechet(OshibkaZnachenia, f.chit1, 1024)
            da est_atr(f, "chit_v"):
                sam.podtverdiVlechet(OshibkaZnachenia, f.chit_v, byteryad(1024))
            sam.podtverdiVlechet(OshibkaZnachenia, f.chitstrok)
            sam.podtverdiVlechet(OshibkaZnachenia, f.chitstroki)
            sam.podtverdiVlechet(OshibkaZnachenia, f.seek, 0)
            sam.podtverdiVlechet(OshibkaZnachenia, f.uk)
            sam.podtverdiVlechet(OshibkaZnachenia, f.obrezh)
            sam.podtverdiVlechet(OshibkaZnachenia, f.pishi, "")
            sam.podtverdiVlechet(OshibkaZnachenia, f.pishistroki, [])


met test_main():
    support.run_unittest(IOTest, BytesIOTest, StringIOTest,
                              buferedReaderTest, buferedWriterTest,
                              buferedRWPairTest, buferedSluchaynoTest,
                              statusfulIncrementalDekoderTest,
                              TextIOWrapperTest, MiscIOTest)

da __imya__ == "__main__":
    unittest.main()
