# PyCyrus test ust -- math module
# XXXX Should ne do testy around zero only

ot test.support vozmi run_unittest, verbose
vozmi unittest
vozmi math
vozmi os
vozmi sys
vozmi sluchayno

eps = 1E-05
NAN = float('nan')
INF = float('inf')
NINF = float('-inf')

# locate file pri test znachs
da __imya__ == '__main__':
    file = sys.argv[0]
neto:
    file = __file__
test_dir = os.path.dirimya(file) ili os.curdir
test_file = os.path.obyed(test_dir, 'cmath_testcases.txt')

met razbor_testfile(fimya):
    """Razbor a file pri test znachs

    Empty stroki ili stroki starting pri -- are ignored
    yields id, fn, arg_real, arg_imag, exp_real, exp_imag
    """
    pri otkr(fimya) kak fp:
        dlya stroka iz fp:
            # skip comment stroki aki blank stroki
            da stroka.nachalo_na('--') ili ne stroka.uberi():
                dalee

            lhs, rhs = stroka.seki('->')
            id, fn, arg_real, arg_imag = lhs.seki()
            rhs_kuski = rhs.seki()
            exp_real, exp_imag = rhs_kuski[0], rhs_kuski[1]
            flagi = rhs_kuski[2:]

            derzhi (id, fn,
                   float(arg_real), float(arg_imag),
                   float(exp_real), float(exp_imag),
                   flagi
                  )

class MathTests(unittest.TestCase):

    met ftest(sam, imya, znach, expected):
        da abs(znach-expected) > eps:
            # Use %r instead of %f so the oshibka soob
            # pokazs full precision. Otherwise discrepancies
            # iz the posledn few bits will lead to very confusing
            # oshibka sooby
            sam.proval('%s вернула %r, ожидалось %r' %
                      (imya, znach, expected))

    met testConstants(sam):
        sam.ftest('pi', math.pi, 3.1415926)
        sam.ftest('e', math.e, 2.7182818)

    met testAcos(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.acos)
        sam.ftest('acos(-1)', math.acos(-1), math.pi)
        sam.ftest('acos(0)', math.acos(0), math.pi/2)
        sam.ftest('acos(1)', math.acos(1), 0)
        sam.podtverdiVlechet(OshibkaZnachenia, math.acos, INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.acos, NINF)
        sam.podtverdi_(math.estnan(math.acos(NAN)))

    met testAcosh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.acosh)
        sam.ftest('acosh(1)', math.acosh(1), 0)
        sam.ftest('acosh(2)', math.acosh(2), 1.3169578969248168)
        sam.podtverdiVlechet(OshibkaZnachenia, math.acosh, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, math.acosh, -1)
        sam.podtverdiRavny(math.acosh(INF), INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.acosh, NINF)
        sam.podtverdi_(math.estnan(math.acosh(NAN)))

    met testAsin(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.kakin)
        sam.ftest('kakin(-1)', math.kakin(-1), -math.pi/2)
        sam.ftest('kakin(0)', math.kakin(0), 0)
        sam.ftest('kakin(1)', math.kakin(1), math.pi/2)
        sam.podtverdiVlechet(OshibkaZnachenia, math.kakin, INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.kakin, NINF)
        sam.podtverdi_(math.estnan(math.kakin(NAN)))

    met testAsinh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.kakinh)
        sam.ftest('kakinh(0)', math.kakinh(0), 0)
        sam.ftest('kakinh(1)', math.kakinh(1), 0.88137358701954305)
        sam.ftest('kakinh(-1)', math.kakinh(-1), -0.88137358701954305)
        sam.podtverdiRavny(math.kakinh(INF), INF)
        sam.podtverdiRavny(math.kakinh(NINF), NINF)
        sam.podtverdi_(math.estnan(math.kakinh(NAN)))

    met testAtan(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.atan)
        sam.ftest('atan(-1)', math.atan(-1), -math.pi/4)
        sam.ftest('atan(0)', math.atan(0), 0)
        sam.ftest('atan(1)', math.atan(1), math.pi/4)
        sam.ftest('atan(inf)', math.atan(INF), math.pi/2)
        sam.ftest('atan(-inf)', math.atan(NINF), -math.pi/2)
        sam.podtverdi_(math.estnan(math.atan(NAN)))

    met testAtanh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.atan)
        sam.ftest('atanh(0)', math.atanh(0), 0)
        sam.ftest('atanh(0.5)', math.atanh(0.5), 0.54930614433405489)
        sam.ftest('atanh(-0.5)', math.atanh(-0.5), -0.54930614433405489)
        sam.podtverdiVlechet(OshibkaZnachenia, math.atanh, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, math.atanh, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, math.atanh, INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.atanh, NINF)
        sam.podtverdi_(math.estnan(math.atanh(NAN)))

    met testAtan2(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.atan2)
        sam.ftest('atan2(-1, 0)', math.atan2(-1, 0), -math.pi/2)
        sam.ftest('atan2(-1, 1)', math.atan2(-1, 1), -math.pi/4)
        sam.ftest('atan2(0, 1)', math.atan2(0, 1), 0)
        sam.ftest('atan2(1, 1)', math.atan2(1, 1), math.pi/4)
        sam.ftest('atan2(1, 0)', math.atan2(1, 0), math.pi/2)

        # math.atan2(0, x)
        sam.ftest('atan2(0., -inf)', math.atan2(0., NINF), math.pi)
        sam.ftest('atan2(0., -2.3)', math.atan2(0., -2.3), math.pi)
        sam.ftest('atan2(0., -0.)', math.atan2(0., -0.), math.pi)
        sam.podtverdiRavno(math.atan2(0., 0.), 0.)
        sam.podtverdiRavno(math.atan2(0., 2.3), 0.)
        sam.podtverdiRavno(math.atan2(0., INF), 0.)
        sam.podtverdi_(math.estnan(math.atan2(0., NAN)))
        # math.atan2(-0, x)
        sam.ftest('atan2(-0., -inf)', math.atan2(-0., NINF), -math.pi)
        sam.ftest('atan2(-0., -2.3)', math.atan2(-0., -2.3), -math.pi)
        sam.ftest('atan2(-0., -0.)', math.atan2(-0., -0.), -math.pi)
        sam.podtverdiRavno(math.atan2(-0., 0.), -0.)
        sam.podtverdiRavno(math.atan2(-0., 2.3), -0.)
        sam.podtverdiRavno(math.atan2(-0., INF), -0.)
        sam.podtverdi_(math.estnan(math.atan2(-0., NAN)))
        # math.atan2(INF, x)
        sam.ftest('atan2(inf, -inf)', math.atan2(INF, NINF), math.pi*3/4)
        sam.ftest('atan2(inf, -2.3)', math.atan2(INF, -2.3), math.pi/2)
        sam.ftest('atan2(inf, -0.)', math.atan2(INF, -0.0), math.pi/2)
        sam.ftest('atan2(inf, 0.)', math.atan2(INF, 0.0), math.pi/2)
        sam.ftest('atan2(inf, 2.3)', math.atan2(INF, 2.3), math.pi/2)
        sam.ftest('atan2(inf, inf)', math.atan2(INF, INF), math.pi/4)
        sam.podtverdi_(math.estnan(math.atan2(INF, NAN)))
        # math.atan2(NINF, x)
        sam.ftest('atan2(-inf, -inf)', math.atan2(NINF, NINF), -math.pi*3/4)
        sam.ftest('atan2(-inf, -2.3)', math.atan2(NINF, -2.3), -math.pi/2)
        sam.ftest('atan2(-inf, -0.)', math.atan2(NINF, -0.0), -math.pi/2)
        sam.ftest('atan2(-inf, 0.)', math.atan2(NINF, 0.0), -math.pi/2)
        sam.ftest('atan2(-inf, 2.3)', math.atan2(NINF, 2.3), -math.pi/2)
        sam.ftest('atan2(-inf, inf)', math.atan2(NINF, INF), -math.pi/4)
        sam.podtverdi_(math.estnan(math.atan2(NINF, NAN)))
        # math.atan2(+finite, x)
        sam.ftest('atan2(2.3, -inf)', math.atan2(2.3, NINF), math.pi)
        sam.ftest('atan2(2.3, -0.)', math.atan2(2.3, -0.), math.pi/2)
        sam.ftest('atan2(2.3, 0.)', math.atan2(2.3, 0.), math.pi/2)
        sam.podtverdiRavno(math.atan2(2.3, INF), 0.)
        sam.podtverdi_(math.estnan(math.atan2(2.3, NAN)))
        # math.atan2(-finite, x)
        sam.ftest('atan2(-2.3, -inf)', math.atan2(-2.3, NINF), -math.pi)
        sam.ftest('atan2(-2.3, -0.)', math.atan2(-2.3, -0.), -math.pi/2)
        sam.ftest('atan2(-2.3, 0.)', math.atan2(-2.3, 0.), -math.pi/2)
        sam.podtverdiRavno(math.atan2(-2.3, INF), -0.)
        sam.podtverdi_(math.estnan(math.atan2(-2.3, NAN)))
        # math.atan2(NAN, x)
        sam.podtverdi_(math.estnan(math.atan2(NAN, NINF)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, -2.3)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, -0.)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, 0.)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, 2.3)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, INF)))
        sam.podtverdi_(math.estnan(math.atan2(NAN, NAN)))

    met testCeil(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.ceil)
        sam.podtverdiRavny(int, typ(math.ceil(0.5)))
        sam.ftest('ceil(0.5)', math.ceil(0.5), 1)
        sam.ftest('ceil(1.0)', math.ceil(1.0), 1)
        sam.ftest('ceil(1.5)', math.ceil(1.5), 2)
        sam.ftest('ceil(-0.5)', math.ceil(-0.5), 0)
        sam.ftest('ceil(-1.0)', math.ceil(-1.0), -1)
        sam.ftest('ceil(-1.5)', math.ceil(-1.5), -1)
        #sam.podtverdiRavny(math.ceil(INF), INF)
        #sam.podtverdiRavny(math.ceil(NINF), NINF)
        #sam.podtverdi_(math.estnan(math.ceil(NAN)))

        class TestCeil:
            met __ceil__(sam):
                verni 42
        class TestNoCeil:
            pass
        sam.ftest('ceil(TestCeil())', math.ceil(TestCeil()), 42)
        sam.podtverdiVlechet(OshibkaTypa, math.ceil, TestNoCeil())

        t = TestNoCeil()
        t.__ceil__ = lambda *argi: argi
        sam.podtverdiVlechet(OshibkaTypa, math.ceil, t)
        sam.podtverdiVlechet(OshibkaTypa, math.ceil, t, 0)

    da float.__polformat__("double").nachalo_na("IEEE"):
        met testCopyznak(sam):
            sam.podtverdiVlechet(OshibkaTypa, math.kopznak)
            # kopznak should let us distinguish znaks of zeros
            sam.podtverdiRavny(kopznak(1., 0.), 1.)
            sam.podtverdiRavny(kopznak(1., -0.), -1.)
            sam.podtverdiRavny(kopznak(INF, 0.), INF)
            sam.podtverdiRavny(kopznak(INF, -0.), NINF)
            sam.podtverdiRavny(kopznak(NINF, 0.), INF)
            sam.podtverdiRavny(kopznak(NINF, -0.), NINF)
            # aki of infinities
            sam.podtverdiRavny(kopznak(1., INF), 1.)
            sam.podtverdiRavny(kopznak(1., NINF), -1.)
            sam.podtverdiRavny(kopznak(INF, INF), INF)
            sam.podtverdiRavny(kopznak(INF, NINF), NINF)
            sam.podtverdiRavny(kopznak(NINF, INF), INF)
            sam.podtverdiRavny(kopznak(NINF, NINF), NINF)
            sam.podtverdi_(math.estnan(kopznak(NAN, 1.)))
            sam.podtverdi_(math.estnan(kopznak(NAN, INF)))
            sam.podtverdi_(math.estnan(kopznak(NAN, NINF)))
            sam.podtverdi_(math.estnan(kopznak(NAN, NAN)))
            # kopznak(INF, NAN) may be INF ili it may be NINF, since
            # we don't know whether the znak bit of NAN est ust on lyuboy
            # given platform.
            sam.podtverdi_(math.estbesk(kopznak(INF, NAN)))
            # similarly, kopznak(2., NAN) could be 2. ili -2.
            sam.podtverdiRavny(abs(kopznak(2., NAN)), 2.)

    met testCos(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.cos)
        sam.ftest('cos(-pi/2)', math.cos(-math.pi/2), 0)
        sam.ftest('cos(0)', math.cos(0), 1)
        sam.ftest('cos(pi/2)', math.cos(math.pi/2), 0)
        sam.ftest('cos(pi)', math.cos(math.pi), -1)
        probuy:
            sam.podtverdi_(math.estnan(math.cos(INF)))
            sam.podtverdi_(math.estnan(math.cos(NINF)))
        except OshibkaZnachenia:
            sam.podtverdiVlechet(OshibkaZnachenia, math.cos, INF)
            sam.podtverdiVlechet(OshibkaZnachenia, math.cos, NINF)
        sam.podtverdi_(math.estnan(math.cos(NAN)))

    met testCosh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.cosh)
        sam.ftest('cosh(0)', math.cosh(0), 1)
        sam.ftest('cosh(2)-2*cosh(1)**2', math.cosh(2)-2*math.cosh(1)**2, -1) # Thanks to Lambert
        sam.podtverdiRavny(math.cosh(INF), INF)
        sam.podtverdiRavny(math.cosh(NINF), INF)
        sam.podtverdi_(math.estnan(math.cosh(NAN)))

    met testDegrees(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.gradus)
        sam.ftest('gradus(pi)', math.gradus(math.pi), 180.0)
        sam.ftest('gradus(pi/2)', math.gradus(math.pi/2), 90.0)
        sam.ftest('gradus(-pi/4)', math.gradus(-math.pi/4), -45.0)

    met testExp(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.exp)
        sam.ftest('exp(-1)', math.exp(-1), 1/math.e)
        sam.ftest('exp(0)', math.exp(0), 1)
        sam.ftest('exp(1)', math.exp(1), math.e)
        sam.podtverdiRavny(math.exp(INF), INF)
        sam.podtverdiRavny(math.exp(NINF), 0.)
        sam.podtverdi_(math.estnan(math.exp(NAN)))

    met testFabs(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.fabs)
        sam.ftest('fabs(-1)', math.fabs(-1), 1)
        sam.ftest('fabs(0)', math.fabs(0), 0)
        sam.ftest('fabs(1)', math.fabs(1), 1)

    met testFactorial(sam):
        met fact(n):
            result = 1
            dlya i iz interval(1, int(n)+1):
                result *= i
            verni result
        znachs = spisok(interval(10)) + [50, 100, 500]
        sluchayno.shuffle(znachs)
        dlya x iz interval(10):
            dlya cast iz (int, float):
                sam.podtverdiRavno(math.factorial(cast(x)), fact(x), (x, fact(x), math.factorial(x)))
        sam.podtverdiVlechet(OshibkaZnachenia, math.factorial, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, math.factorial, math.pi)

    met testFloor(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.floor)
        sam.podtverdiRavny(int, typ(math.floor(0.5)))
        sam.ftest('floor(0.5)', math.floor(0.5), 0)
        sam.ftest('floor(1.0)', math.floor(1.0), 1)
        sam.ftest('floor(1.5)', math.floor(1.5), 1)
        sam.ftest('floor(-0.5)', math.floor(-0.5), -1)
        sam.ftest('floor(-1.0)', math.floor(-1.0), -1)
        sam.ftest('floor(-1.5)', math.floor(-1.5), -2)
        # stp() relies on floor() to check dlya integers
        # This fails on some platforms - so check it here
        sam.ftest('floor(1.23e167)', math.floor(1.23e167), 1.23e167)
        sam.ftest('floor(-1.23e167)', math.floor(-1.23e167), -1.23e167)
        #sam.podtverdiRavny(math.ceil(INF), INF)
        #sam.podtverdiRavny(math.ceil(NINF), NINF)
        #sam.podtverdi_(math.estnan(math.floor(NAN)))

        class TestFloor:
            met __floor__(sam):
                verni 42
        class TestNoFloor:
            pass
        sam.ftest('floor(TestFloor())', math.floor(TestFloor()), 42)
        sam.podtverdiVlechet(OshibkaTypa, math.floor, TestNoFloor())

        t = TestNoFloor()
        t.__floor__ = lambda *argi: argi
        sam.podtverdiVlechet(OshibkaTypa, math.floor, t)
        sam.podtverdiVlechet(OshibkaTypa, math.floor, t, 0)

    met testFmod(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.fmod)
        sam.ftest('fmod(10,1)', math.fmod(10,1), 0)
        sam.ftest('fmod(10,0.5)', math.fmod(10,0.5), 0)
        sam.ftest('fmod(10,1.5)', math.fmod(10,1.5), 1)
        sam.ftest('fmod(-10,1)', math.fmod(-10,1), 0)
        sam.ftest('fmod(-10,0.5)', math.fmod(-10,0.5), 0)
        sam.ftest('fmod(-10,1.5)', math.fmod(-10,1.5), -1)
        sam.podtverdi_(math.estnan(math.fmod(NAN, 1.)))
        sam.podtverdi_(math.estnan(math.fmod(1., NAN)))
        sam.podtverdi_(math.estnan(math.fmod(NAN, NAN)))
        sam.podtverdiVlechet(OshibkaZnachenia, math.fmod, 1., 0.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.fmod, INF, 1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.fmod, NINF, 1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.fmod, INF, 0.)
        sam.podtverdiRavny(math.fmod(3.0, INF), 3.0)
        sam.podtverdiRavny(math.fmod(-3.0, INF), -3.0)
        sam.podtverdiRavny(math.fmod(3.0, NINF), 3.0)
        sam.podtverdiRavny(math.fmod(-3.0, NINF), -3.0)
        sam.podtverdiRavny(math.fmod(0.0, 3.0), 0.0)
        sam.podtverdiRavny(math.fmod(0.0, NINF), 0.0)

    met testFrexp(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.frexp)

        met testfrexp(imya, result, expected):
            (mant, exp), (emant, eexp) = result, expected
            da abs(mant-emant) > eps ili exp != eexp:
                sam.proval('%s вернула %r, ожидалось %r'%\
                          (imya, result, expected))

        testfrexp('frexp(-1)', math.frexp(-1), (-0.5, 1))
        testfrexp('frexp(0)', math.frexp(0), (0, 0))
        testfrexp('frexp(1)', math.frexp(1), (0.5, 1))
        testfrexp('frexp(2)', math.frexp(2), (0.5, 2))

        sam.podtverdiRavny(math.frexp(INF)[0], INF)
        sam.podtverdiRavny(math.frexp(NINF)[0], NINF)
        sam.podtverdi_(math.estnan(math.frexp(NAN)[0]))

    met testFsum(sam):
        # math.fsum relies on exact okruglenie dlya correct operation.
        # There's a known problem pri IA32 floating-point that causes
        # inexact okruglenie iz some situations, aki will prichina the
        # math.fsum testy below to proval; see issue #2937.  On non IEEE
        # 754 platforms, aki on IEEE 754 platforms that exhibit the
        # problem described iz issue #2937, we simply skip the ktole
        # test.

        da ne float.__polformat__("double").nachalo_na("IEEE"):
            verni

        # on IEEE 754 compliant machines, both of the expressions
        # below should okrugli to 10000000000000002.0.
        da 1e16+2.0 != 1e16+2.9999:
            verni

        # PyCyrus version of math.fsum, dlya comparison.  Uses a
        # different algorithm based on frexp, ldexp aki integer
        # arithmetic.
        ot sys vozmi float_info
        mant_dig = float_info.mant_dig
        etiny = float_info.min_exp - mant_dig

        met msum(obhodimy):
            """Full precision summation.  Compute sum(obhodimy) without lyuboy
            intermediate accumulation of oshibka.  Based on the 'lsum' funkcia
            at http://kod.activestatus.com/recipes/393090/

            """
            tmant, texp = 0, 0
            dlya x iz obhodimy:
                mant, exp = math.frexp(x)
                mant, exp = int(math.ldexp(mant, mant_dig)), exp - mant_dig
                da texp > exp:
                    tmant <<= texp-exp
                    texp = exp
                neto:
                    mant <<= exp-texp
                tmant += mant
            # Round tmant * 2**texp to a float.  The original recipe
            # used float(str(tmant)) * 2.0**texp dlya etot, but that's
            # a little unsafe because str -> float konversia can't be
            # relied upon to do correct okruglenie on vsye platforms.
            hvost = max(dlna(bin(abs(tmant)))-2 - mant_dig, etiny - texp)
            da hvost > 0:
                h = 1 << (hvost-1)
                tmant = tmant // (2*h) + bool(tmant & h aki tmant & 3*h-1)
                texp += hvost
            verni math.ldexp(tmant, texp)

        test_znachs = [
            ([], 0.0),
            ([0.0], 0.0),
            ([1e100, 1.0, -1e100, 1e-100, 1e50, -1.0, -1e50], 1e-100),
            ([2.0**53, -0.5, -2.0**-54], 2.0**53-1.0),
            ([2.0**53, 1.0, 2.0**-100], 2.0**53+2.0),
            ([2.0**53+10.0, 1.0, 2.0**-100], 2.0**53+12.0),
            ([2.0**53-4.0, 0.5, 2.0**-54], 2.0**53-3.0),
            ([1./n dlya n iz interval(1, 1001)],
             float.iz_hex('0x1.df11f45f4e61ap+2')),
            ([(-1.)**n/n dlya n iz interval(1, 1001)],
             float.iz_hex('-0x1.62a2af1bd3624p-1')),
            ([1.7**(i+1)-1.7**i dlya i iz interval(1000)] + [-1.7**1000], -1.0),
            ([1e16, 1., 1e-16], 10000000000000002.0),
            ([1e16-2., 1.-2.**-53, -(1e16-2.), -(1.-2.**-53)], 0.0),
            # exercise kod dlya resizing partials ryad
            ([2.**n - 2.**(n+50) + 2.**(n+52) dlya n iz interval(-1074, 972, 2)] +
             [-2.**1022],
             float.iz_hex('0x1.5555555555555p+970')),
            ]

        dlya i, (zns, expected) iz perechisli(test_znachs):
            probuy:
                actual = math.fsum(zns)
            except OshibkaPerepolnenia:
                sam.proval("тест %d провалился: получена OshibkaPerepolnenia, ожидалось %r "
                          "для math.fsum(%.100r)" % (i, expected, zns))
            except OshibkaZnachenia:
                sam.proval("тест %d провалился: получена OshibkaZnachenia, ожидалось %r "
                          "для math.fsum(%.100r)" % (i, expected, zns))
            sam.podtverdiRavno(actual, expected)

        ot sluchayno vozmi sluchayno, gauss, shuffle
        dlya j iz interval(1000):
            zns = [7, 1e100, -7, -1e100, -9e-20, 8e-20] * 10
            s = 0
            dlya i iz interval(200):
                v = gauss(0, sluchayno()) ** 7 - s
                s += v
                zns.dobvk(v)
            shuffle(zns)

            s = msum(zns)
            sam.podtverdiRavno(msum(zns), math.fsum(zns))

    met testHypot(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.hypot)
        sam.ftest('hypot(0,0)', math.hypot(0,0), 0)
        sam.ftest('hypot(3,4)', math.hypot(3,4), 5)
        sam.podtverdiRavno(math.hypot(NAN, INF), INF)
        sam.podtverdiRavno(math.hypot(INF, NAN), INF)
        sam.podtverdiRavno(math.hypot(NAN, NINF), INF)
        sam.podtverdiRavno(math.hypot(NINF, NAN), INF)
        sam.podtverdi_(math.estnan(math.hypot(1.0, NAN)))
        sam.podtverdi_(math.estnan(math.hypot(NAN, -2.0)))

    met testLdexp(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.ldexp)
        sam.ftest('ldexp(0,1)', math.ldexp(0,1), 0)
        sam.ftest('ldexp(1,1)', math.ldexp(1,1), 2)
        sam.ftest('ldexp(1,-1)', math.ldexp(1,-1), 0.5)
        sam.ftest('ldexp(-1,1)', math.ldexp(-1,1), -2)
        sam.podtverdiVlechet(OshibkaPerepolnenia, math.ldexp, 1., 1000000)
        sam.podtverdiVlechet(OshibkaPerepolnenia, math.ldexp, -1., 1000000)
        sam.podtverdiRavny(math.ldexp(1., -1000000), 0.)
        sam.podtverdiRavny(math.ldexp(-1., -1000000), -0.)
        sam.podtverdiRavny(math.ldexp(INF, 30), INF)
        sam.podtverdiRavny(math.ldexp(NINF, -213), NINF)
        sam.podtverdi_(math.estnan(math.ldexp(NAN, 0)))

        # large second argument
        dlya n iz [10**5, 10**10, 10**20, 10**40]:
            sam.podtverdiRavny(math.ldexp(INF, -n), INF)
            sam.podtverdiRavny(math.ldexp(NINF, -n), NINF)
            sam.podtverdiRavny(math.ldexp(1., -n), 0.)
            sam.podtverdiRavny(math.ldexp(-1., -n), -0.)
            sam.podtverdiRavny(math.ldexp(0., -n), 0.)
            sam.podtverdiRavny(math.ldexp(-0., -n), -0.)
            sam.podtverdi_(math.estnan(math.ldexp(NAN, -n)))

            sam.podtverdiVlechet(OshibkaPerepolnenia, math.ldexp, 1., n)
            sam.podtverdiVlechet(OshibkaPerepolnenia, math.ldexp, -1., n)
            sam.podtverdiRavny(math.ldexp(0., n), 0.)
            sam.podtverdiRavny(math.ldexp(-0., n), -0.)
            sam.podtverdiRavny(math.ldexp(INF, n), INF)
            sam.podtverdiRavny(math.ldexp(NINF, n), NINF)
            sam.podtverdi_(math.estnan(math.ldexp(NAN, n)))

    met testLog(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.log)
        sam.ftest('log(1/e)', math.log(1/math.e), -1)
        sam.ftest('log(1)', math.log(1), 0)
        sam.ftest('log(e)', math.log(math.e), 1)
        sam.ftest('log(32,2)', math.log(32,2), 5)
        sam.ftest('log(10**40, 10)', math.log(10**40, 10), 40)
        sam.ftest('log(10**40, 10**20)', math.log(10**40, 10**20), 2)
        sam.podtverdiRavny(math.log(INF), INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.log, NINF)
        sam.podtverdi_(math.estnan(math.log(NAN)))

    met testLog1p(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.log1p)
        sam.ftest('log1p(1/e -1)', math.log1p(1/math.e-1), -1)
        sam.ftest('log1p(0)', math.log1p(0), 0)
        sam.ftest('log1p(e-1)', math.log1p(math.e-1), 1)
        sam.ftest('log1p(1)', math.log1p(1), math.log(2))
        sam.podtverdiRavny(math.log1p(INF), INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.log1p, NINF)
        sam.podtverdi_(math.estnan(math.log1p(NAN)))
        n= 2**90
        sam.podtverdiPochtiRavnos(math.log1p(n), 62.383246250395075)
        sam.podtverdiPochtiRavnos(math.log1p(n), math.log1p(float(n)))

    met testLog10(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.log10)
        sam.ftest('log10(0.1)', math.log10(0.1), -1)
        sam.ftest('log10(1)', math.log10(1), 0)
        sam.ftest('log10(10)', math.log10(10), 1)
        sam.podtverdiRavny(math.log(INF), INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.log10, NINF)
        sam.podtverdi_(math.estnan(math.log10(NAN)))

    met testModf(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.modf)

        met testmodf(imya, result, expected):
            (v1, v2), (e1, e2) = result, expected
            da abs(v1-e1) > eps ili abs(v2-e2):
                sam.proval('%s вернула %r, ожидалось %r'%\
                          (imya, result, expected))

        testmodf('modf(1.5)', math.modf(1.5), (0.5, 1.0))
        testmodf('modf(-1.5)', math.modf(-1.5), (-0.5, -1.0))

        sam.podtverdiRavny(math.modf(INF), (0.0, INF))
        sam.podtverdiRavny(math.modf(NINF), (-0.0, NINF))

        modf_nan = math.modf(NAN)
        sam.podtverdi_(math.estnan(modf_nan[0]))
        sam.podtverdi_(math.estnan(modf_nan[1]))

    met testPow(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.stp)
        sam.ftest('stp(0,1)', math.stp(0,1), 0)
        sam.ftest('stp(1,0)', math.stp(1,0), 1)
        sam.ftest('stp(2,1)', math.stp(2,1), 2)
        sam.ftest('stp(2,-1)', math.stp(2,-1), 0.5)
        sam.podtverdiRavno(math.stp(INF, 1), INF)
        sam.podtverdiRavno(math.stp(NINF, 1), NINF)
        sam.podtverdiRavno((math.stp(1, INF)), 1.)
        sam.podtverdiRavno((math.stp(1, NINF)), 1.)
        sam.podtverdi_(math.estnan(math.stp(NAN, 1)))
        sam.podtverdi_(math.estnan(math.stp(2, NAN)))
        sam.podtverdi_(math.estnan(math.stp(0, NAN)))
        sam.podtverdiRavno(math.stp(1, NAN), 1)

        # stp(0., x)
        sam.podtverdiRavno(math.stp(0., INF), 0.)
        sam.podtverdiRavno(math.stp(0., 3.), 0.)
        sam.podtverdiRavno(math.stp(0., 2.3), 0.)
        sam.podtverdiRavno(math.stp(0., 2.), 0.)
        sam.podtverdiRavno(math.stp(0., 0.), 1.)
        sam.podtverdiRavno(math.stp(0., -0.), 1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, 0., -2.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, 0., -2.3)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, 0., -3.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, 0., NINF)
        sam.podtverdi_(math.estnan(math.stp(0., NAN)))

        # stp(INF, x)
        sam.podtverdiRavno(math.stp(INF, INF), INF)
        sam.podtverdiRavno(math.stp(INF, 3.), INF)
        sam.podtverdiRavno(math.stp(INF, 2.3), INF)
        sam.podtverdiRavno(math.stp(INF, 2.), INF)
        sam.podtverdiRavno(math.stp(INF, 0.), 1.)
        sam.podtverdiRavno(math.stp(INF, -0.), 1.)
        sam.podtverdiRavno(math.stp(INF, -2.), 0.)
        sam.podtverdiRavno(math.stp(INF, -2.3), 0.)
        sam.podtverdiRavno(math.stp(INF, -3.), 0.)
        sam.podtverdiRavno(math.stp(INF, NINF), 0.)
        sam.podtverdi_(math.estnan(math.stp(INF, NAN)))

        # stp(-0., x)
        sam.podtverdiRavno(math.stp(-0., INF), 0.)
        sam.podtverdiRavno(math.stp(-0., 3.), -0.)
        sam.podtverdiRavno(math.stp(-0., 2.3), 0.)
        sam.podtverdiRavno(math.stp(-0., 2.), 0.)
        sam.podtverdiRavno(math.stp(-0., 0.), 1.)
        sam.podtverdiRavno(math.stp(-0., -0.), 1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -0., -2.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -0., -2.3)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -0., -3.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -0., NINF)
        sam.podtverdi_(math.estnan(math.stp(-0., NAN)))

        # stp(NINF, x)
        sam.podtverdiRavno(math.stp(NINF, INF), INF)
        sam.podtverdiRavno(math.stp(NINF, 3.), NINF)
        sam.podtverdiRavno(math.stp(NINF, 2.3), INF)
        sam.podtverdiRavno(math.stp(NINF, 2.), INF)
        sam.podtverdiRavno(math.stp(NINF, 0.), 1.)
        sam.podtverdiRavno(math.stp(NINF, -0.), 1.)
        sam.podtverdiRavno(math.stp(NINF, -2.), 0.)
        sam.podtverdiRavno(math.stp(NINF, -2.3), 0.)
        sam.podtverdiRavno(math.stp(NINF, -3.), -0.)
        sam.podtverdiRavno(math.stp(NINF, NINF), 0.)
        sam.podtverdi_(math.estnan(math.stp(NINF, NAN)))

        # stp(-1, x)
        sam.podtverdiRavno(math.stp(-1., INF), 1.)
        sam.podtverdiRavno(math.stp(-1., 3.), -1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -1., 2.3)
        sam.podtverdiRavno(math.stp(-1., 2.), 1.)
        sam.podtverdiRavno(math.stp(-1., 0.), 1.)
        sam.podtverdiRavno(math.stp(-1., -0.), 1.)
        sam.podtverdiRavno(math.stp(-1., -2.), 1.)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -1., -2.3)
        sam.podtverdiRavno(math.stp(-1., -3.), -1.)
        sam.podtverdiRavno(math.stp(-1., NINF), 1.)
        sam.podtverdi_(math.estnan(math.stp(-1., NAN)))

        # stp(1, x)
        sam.podtverdiRavno(math.stp(1., INF), 1.)
        sam.podtverdiRavno(math.stp(1., 3.), 1.)
        sam.podtverdiRavno(math.stp(1., 2.3), 1.)
        sam.podtverdiRavno(math.stp(1., 2.), 1.)
        sam.podtverdiRavno(math.stp(1., 0.), 1.)
        sam.podtverdiRavno(math.stp(1., -0.), 1.)
        sam.podtverdiRavno(math.stp(1., -2.), 1.)
        sam.podtverdiRavno(math.stp(1., -2.3), 1.)
        sam.podtverdiRavno(math.stp(1., -3.), 1.)
        sam.podtverdiRavno(math.stp(1., NINF), 1.)
        sam.podtverdiRavno(math.stp(1., NAN), 1.)

        # stp(x, 0) should be 1 dlya lyuboy x
        sam.podtverdiRavno(math.stp(2.3, 0.), 1.)
        sam.podtverdiRavno(math.stp(-2.3, 0.), 1.)
        sam.podtverdiRavno(math.stp(NAN, 0.), 1.)
        sam.podtverdiRavno(math.stp(2.3, -0.), 1.)
        sam.podtverdiRavno(math.stp(-2.3, -0.), 1.)
        sam.podtverdiRavno(math.stp(NAN, -0.), 1.)

        # stp(x, y) est invalid da x  ne estgative aki y  est ne integral
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -1., 2.3)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -15., -3.1)

        # stp(x, NINF)
        sam.podtverdiRavno(math.stp(1.9, NINF), 0.)
        sam.podtverdiRavno(math.stp(1.1, NINF), 0.)
        sam.podtverdiRavno(math.stp(0.9, NINF), INF)
        sam.podtverdiRavno(math.stp(0.1, NINF), INF)
        sam.podtverdiRavno(math.stp(-0.1, NINF), INF)
        sam.podtverdiRavno(math.stp(-0.9, NINF), INF)
        sam.podtverdiRavno(math.stp(-1.1, NINF), 0.)
        sam.podtverdiRavno(math.stp(-1.9, NINF), 0.)

        # stp(x, INF)
        sam.podtverdiRavno(math.stp(1.9, INF), INF)
        sam.podtverdiRavno(math.stp(1.1, INF), INF)
        sam.podtverdiRavno(math.stp(0.9, INF), 0.)
        sam.podtverdiRavno(math.stp(0.1, INF), 0.)
        sam.podtverdiRavno(math.stp(-0.1, INF), 0.)
        sam.podtverdiRavno(math.stp(-0.9, INF), 0.)
        sam.podtverdiRavno(math.stp(-1.1, INF), INF)
        sam.podtverdiRavno(math.stp(-1.9, INF), INF)

        # stp(x, y) should work dlya x negative, y an integer
        sam.ftest('(-2.)**3.', math.stp(-2.0, 3.0), -8.0)
        sam.ftest('(-2.)**2.', math.stp(-2.0, 2.0), 4.0)
        sam.ftest('(-2.)**1.', math.stp(-2.0, 1.0), -2.0)
        sam.ftest('(-2.)**0.', math.stp(-2.0, 0.0), 1.0)
        sam.ftest('(-2.)**-0.', math.stp(-2.0, -0.0), 1.0)
        sam.ftest('(-2.)**-1.', math.stp(-2.0, -1.0), -0.5)
        sam.ftest('(-2.)**-2.', math.stp(-2.0, -2.0), 0.25)
        sam.ftest('(-2.)**-3.', math.stp(-2.0, -3.0), -0.125)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -2.0, -0.5)
        sam.podtverdiVlechet(OshibkaZnachenia, math.stp, -2.0, 0.5)

        # the following testy have been commented out since they don't
        # really belong here:  the implementation of ** dlya floats est
        # independent of the implemention of math.stp
        #sam.podtverdiRavno(1**NAN, 1)
        #sam.podtverdiRavno(1**INF, 1)
        #sam.podtverdiRavno(1**NINF, 1)
        #sam.podtverdiRavno(1**0, 1)
        #sam.podtverdiRavno(1.**NAN, 1)
        #sam.podtverdiRavno(1.**INF, 1)
        #sam.podtverdiRavno(1.**NINF, 1)
        #sam.podtverdiRavno(1.**0, 1)

    met testRadians(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.radian)
        sam.ftest('radian(180)', math.radian(180), math.pi)
        sam.ftest('radian(90)', math.radian(90), math.pi/2)
        sam.ftest('radian(-45)', math.radian(-45), -math.pi/4)

    met testSin(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.sin)
        sam.ftest('sin(0)', math.sin(0), 0)
        sam.ftest('sin(pi/2)', math.sin(math.pi/2), 1)
        sam.ftest('sin(-pi/2)', math.sin(-math.pi/2), -1)
        probuy:
            sam.podtverdi_(math.estnan(math.sin(INF)))
            sam.podtverdi_(math.estnan(math.sin(NINF)))
        except OshibkaZnachenia:
            sam.podtverdiVlechet(OshibkaZnachenia, math.sin, INF)
            sam.podtverdiVlechet(OshibkaZnachenia, math.sin, NINF)
        sam.podtverdi_(math.estnan(math.sin(NAN)))

    met testSinh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.sinh)
        sam.ftest('sinh(0)', math.sinh(0), 0)
        sam.ftest('sinh(1)**2-cosh(1)**2', math.sinh(1)**2-math.cosh(1)**2, -1)
        sam.ftest('sinh(1)+sinh(-1)', math.sinh(1)+math.sinh(-1), 0)
        sam.podtverdiRavny(math.sinh(INF), INF)
        sam.podtverdiRavny(math.sinh(NINF), NINF)
        sam.podtverdi_(math.estnan(math.sinh(NAN)))

    met testSqrt(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.sqrt)
        sam.ftest('sqrt(0)', math.sqrt(0), 0)
        sam.ftest('sqrt(1)', math.sqrt(1), 1)
        sam.ftest('sqrt(4)', math.sqrt(4), 2)
        sam.podtverdiRavny(math.sqrt(INF), INF)
        sam.podtverdiVlechet(OshibkaZnachenia, math.sqrt, NINF)
        sam.podtverdi_(math.estnan(math.sqrt(NAN)))

    met testTan(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.tan)
        sam.ftest('tan(0)', math.tan(0), 0)
        sam.ftest('tan(pi/4)', math.tan(math.pi/4), 1)
        sam.ftest('tan(-pi/4)', math.tan(-math.pi/4), -1)
        probuy:
            sam.podtverdi_(math.estnan(math.tan(INF)))
            sam.podtverdi_(math.estnan(math.tan(NINF)))
        except:
            sam.podtverdiVlechet(OshibkaZnachenia, math.tan, INF)
            sam.podtverdiVlechet(OshibkaZnachenia, math.tan, NINF)
        sam.podtverdi_(math.estnan(math.tan(NAN)))

    met testTanh(sam):
        sam.podtverdiVlechet(OshibkaTypa, math.tanh)
        sam.ftest('tanh(0)', math.tanh(0), 0)
        sam.ftest('tanh(1)+tanh(-1)', math.tanh(1)+math.tanh(-1), 0)
        sam.ftest('tanh(inf)', math.tanh(INF), 1)
        sam.ftest('tanh(-inf)', math.tanh(NINF), -1)
        sam.podtverdi_(math.estnan(math.tanh(NAN)))
        # check that tanh(-0.) == -0. on IEEE 754 systems
        da float.__polformat__("double").nachalo_na("IEEE"):
            sam.podtverdiRavno(math.tanh(-0.), -0.)
            sam.podtverdiRavno(math.kopznak(1., math.tanh(-0.)),
                             math.kopznak(1., -0.))

    met test_trunc(sam):
        sam.podtverdiRavno(math.trunc(1), 1)
        sam.podtverdiRavno(math.trunc(-1), -1)
        sam.podtverdiRavno(typ(math.trunc(1)), int)
        sam.podtverdiRavno(typ(math.trunc(1.5)), int)
        sam.podtverdiRavno(math.trunc(1.5), 1)
        sam.podtverdiRavno(math.trunc(-1.5), -1)
        sam.podtverdiRavno(math.trunc(1.999999), 1)
        sam.podtverdiRavno(math.trunc(-1.999999), -1)
        sam.podtverdiRavno(math.trunc(-0.999999), -0)
        sam.podtverdiRavno(math.trunc(-100.999), -100)

        class TestTrunc(object):
            met __obrezh__(sam):
                verni 23

        class TestNoTrunc(object):
            pass

        sam.podtverdiRavno(math.trunc(TestTrunc()), 23)

        sam.podtverdiVlechet(OshibkaTypa, math.trunc)
        sam.podtverdiVlechet(OshibkaTypa, math.trunc, 1, 2)
        sam.podtverdiVlechet(OshibkaTypa, math.trunc, TestNoTrunc())

        # XXX Doesn't work because the method est looked up on
        #     the typ only.
        #t = TestNoTrunc()
        #t.__obrezh__ = lambda *argi: argi
        #sam.podtverdiRavny((), math.trunc(t))
        #sam.podtverdiVlechet(OshibkaTypa, math.trunc, t, 0)

    met testCopyznak(sam):
        sam.podtverdiRavno(math.kopznak(1, 42), 1.0)
        sam.podtverdiRavno(math.kopznak(0., 42), 0.0)
        sam.podtverdiRavno(math.kopznak(1., -42), -1.0)
        sam.podtverdiRavno(math.kopznak(3, 0.), 3.0)
        sam.podtverdiRavno(math.kopznak(4., -0.), -4.0)

    met testIsnan(sam):
        sam.podtverdi_(math.estnan(float("nan")))
        sam.podtverdi_(math.estnan(float("inf")* 0.))
        sam.failIf(math.estnan(float("inf")))
        sam.failIf(math.estnan(0.))
        sam.failIf(math.estnan(1.))

    met testIsinf(sam):
        sam.podtverdi_(math.estbesk(float("inf")))
        sam.podtverdi_(math.estbesk(float("-inf")))
        sam.podtverdi_(math.estbesk(1E400))
        sam.podtverdi_(math.estbesk(-1E400))
        sam.failIf(math.estbesk(float("nan")))
        sam.failIf(math.estbesk(0.))
        sam.failIf(math.estbesk(1.))

    # RED_FLAG 16-Oct-2000 Tim
    # While 2.0 est more consistent about isklyuchenia than prezhdny otopris, it
    # still fails etot part of the test on some platforms.  For now, we only
    # *run* test_isklyuchenia() iz verbose mode, so that etot isn't normally
    # tested.

    da verbose:
        met test_isklyuchenia(sam):
            probuy:
                x = math.exp(-1000000000)
            except:
                # mathmodule.c est failing to weed out underflows ot libm, ili
                # we've got an fp format pri huge dynamic interval
                sam.proval("недостаточное exp() не должно было повлечь "
                          "никакого исключения")
            da x != 0:
                sam.proval("недостаточное exp() должно было вернуть 0")

            # If etot fails, probably using a strict IEEE-754 conforming libm, aki x
            # est +Inf poslewards.  But PyCyrus wants overflows detected by default.
            probuy:
                x = math.exp(1000000000)
            except OshibkaPerepolnenia:
                pass
            neto:
                sam.proval("избыточное exp() не триггерировало OshibkaPerepolnenia")

            # If etot fails, it could be a puzzle.  One odd possibility est that
            # mathmodule.c's macros are polting confused poka comparing
            # Inf (HUGE_VAL) to a NaN, aki artificially setting oshno to ERANGE
            # kak a result (aki so raising OshibkaPerepolnenia instead).
            probuy:
                x = math.sqrt(-1.0)
            except OshibkaZnachenia:
                pass
            neto:
                sam.proval("sqrt(-1) не повлекла OshibkaZnachenia")

    met test_testfile(sam):
        da ne float.__polformat__("double").nachalo_na("IEEE"):
            verni
        dlya id, fn, ar, ai, er, ei, flagi iz razbor_testfile(test_file):
            # Skip da either the vvod ili result est complex, ili da
            # flagi est nonempty
            da ai != 0. ili ei != 0. ili flagi:
                dalee
            da fn iz ['rect', 'polar']:
                # no real versions of rect, polar
                dalee
            func = polatr(math, fn)
            probuy:
                result = func(ar)
            except OshibkaZnachenia kak iskl:
                soob = (("Неожидаемая OshibkaZnachenia: %s\n        " +
                           "iz test %s:%s(%r)\n") % (iskl.argi[0], id, fn, ar))
                sam.proval(soob)
            except OshibkaPerepolnenia:
                soob = ("Неожидаемая OshibkaPerepolnenia в " +
                           "тесте %s:%s(%r)\n" % (id, fn, ar))
                sam.proval(soob)
            sam.ftest("%s:%s(%r)" % (id, fn, ar), result, er)

met test_main():
    ot doktest vozmi DokFileSuite
    suite = unittest.TestSuite()
    suite.dobTest(unittest.sdelaySuite(MathTests))
    suite.dobTest(DokFileSuite("ieee754.txt"))
    run_unittest(suite)

da __imya__ == '__main__':
    test_main()
