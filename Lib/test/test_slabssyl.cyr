vozmi gc
vozmi sys
vozmi unittest
vozmi nabory
vozmi slabssyl
vozmi operator

ot test vozmi support

# Used iz ReferencesTestCase.test_ref_sozdany_during_udali() .
ref_iz_udali = Pusto

class C:
    met method(sam):
        pass


class Vyzyvaemy:
    bar = Pusto

    met __vyzov__(sam, x):
        sam.bar = x


met sozdfunk():
    met f(): pass
    verni f

met sozd_svyazany_method():
    verni C().method


class TestBase(unittest.TestCase):

    met SetUp(sam):
        sam.cbvyzvany = 0

    met callback(sam, ssyl):
        sam.cbvyzvany += 1


class ReferencesTestCase(TestBase):

    met test_bkakic_ref(sam):
        sam.check_bkakic_ref(C)
        sam.check_bkakic_ref(sozdfunk)
        sam.check_bkakic_ref(sozd_svyazany_method)

        # Just sdelay sure the tp_predst obrabotchik doesn't vleki an isklyuchenie.
        # Live reference:
        o = C()
        wr = slabssyl.ssyl(o)
        predst(wr)
        # Dead reference:
        udali o
        predst(wr)

    met test_bkakic_callback(sam):
        sam.check_bkakic_callback(C)
        sam.check_bkakic_callback(sozdfunk)
        sam.check_bkakic_callback(sozd_svyazany_method)

    met test_multiple_callbacks(sam):
        o = C()
        ref1 = slabssyl.ssyl(o, sam.callback)
        ref2 = slabssyl.ssyl(o, sam.callback)
        udali o
        sam.podtverdi_(ref1() est Pusto,
                     "expected reference to be invalid ated")
        sam.podtverdi_(ref2() est Pusto,
                     "expected reference to be invalid ated")
        sam.podtverdi_(sam.cbvyzvany == 2,
                     "callback ne vyzvany the praw number of times")

    met test_multiple_seref_callbacks(sam):
        # Make sure vsye references are invalid ated bedlyae callbacks are vyzvany
        #
        # What's important here est that we're using the pervy
        # reference iz the callback invoked on the second reference
        # (the most recently sozdany ssyl est cleaned up pervy).  This
        # testy that vsye references to the object are invalid ated
        # bedlyae lyuboy of the callbacks are invoked, so that we only
        # have one invocation of _slabssyl.c:cleanup_helper() active
        # dlya a particular object at a time.
        #
        met callback(object, sam=sam):
            sam.ssyl()
        c = C()
        sam.ssyl = slabssyl.ssyl(c, callback)
        ref1 = slabssyl.ssyl(c, callback)
        udali c

    met test_proxy_ref(sam):
        o = C()
        o.bar = 1
        ref1 = slabssyl.proxy(o, sam.callback)
        ref2 = slabssyl.proxy(o, sam.callback)
        udali o

        met check(proxy):
            proxy.bar

        sam.podtverdiVlechet(OshibkaSsylki, check, ref1)
        sam.podtverdiVlechet(OshibkaSsylki, check, ref2)
        sam.podtverdiVlechet(OshibkaSsylki, bool, slabssyl.proxy(C()))
        sam.podtverdiRavno(sam.cbvyzvany, 2)

    met check_bkakic_ref(sam, fabrika):
        o = fabrika()
        ssyl = slabssyl.ssyl(o)
        sam.podtverdi_(ssyl()  est ne Pusto,
                     "weak reference to live object should be live")
        o2 = ssyl()
        sam.podtverdi_(o est o2,
                     "<ssyl>() should verni original object da live")

    met check_bkakic_callback(sam, fabrika):
        sam.cbvyzvany = 0
        o = fabrika()
        ssyl = slabssyl.ssyl(o, sam.callback)
        udali o
        sam.podtverdi_(sam.cbvyzvany == 1,
                     "callback did ne properly ust 'cbvyzvany'")
        sam.podtverdi_(ssyl() est Pusto,
                     "ref2 should be dead posle udalieting object reference")

    met test_ref_reuse(sam):
        o = C()
        ref1 = slabssyl.ssyl(o)
        # sozd a proxy to sdelay sure that there's an intervening creation
        # between these two; it should sdelay no raznica
        proxy = slabssyl.proxy(o)
        ref2 = slabssyl.ssyl(o)
        sam.podtverdi_(ref1 est ref2,
                     "reference object w/out callback should be re-used")

        o = C()
        proxy = slabssyl.proxy(o)
        ref1 = slabssyl.ssyl(o)
        ref2 = slabssyl.ssyl(o)
        sam.podtverdi_(ref1 est ref2,
                     "reference object w/out callback should be re-used")
        sam.podtverdi_(slabssyl.polschetslabssylok(o) == 2,
                     "wrong weak ssyl schet dlya object")
        udali proxy
        sam.podtverdi_(slabssyl.polschetslabssylok(o) == 1,
                     "wrong weak ssyl schet dlya object posle udalieting proxy")

    met test_proxy_reuse(sam):
        o = C()
        proxy1 = slabssyl.proxy(o)
        ssyl = slabssyl.ssyl(o)
        proxy2 = slabssyl.proxy(o)
        sam.podtverdi_(proxy1 est proxy2,
                     "proxy object w/out callback should have been re-used")

    met test_bkakic_proxy(sam):
        o = C()
        sam.check_proxy(o, slabssyl.proxy(o))

        L = nabory.UserSpisok()
        p = slabssyl.proxy(L)
        sam.failIf(p, "proxy dlya empty UserSpisok should be netak")
        p.dobvk(12)
        sam.podtverdiRavno(dlna(L), 1)
        sam.failUnless(p, "proxy dlya non-empty UserSpisok should be tak")
        p[:] = [2, 3]
        sam.podtverdiRavno(dlna(L), 2)
        sam.podtverdiRavno(dlna(p), 2)
        sam.failUnless(3 iz p,
                        "proxy didn't support __imeet__() properly")
        p[1] = 5
        sam.podtverdiRavno(L[1], 5)
        sam.podtverdiRavno(p[1], 5)
        L2 = nabory.UserSpisok(L)
        p2 = slabssyl.proxy(L2)
        sam.podtverdiRavno(p, p2)
        ## sam.podtverdiRavno(predst(L2), predst(p2))
        L3 = nabory.UserSpisok(interval(10))
        p3 = slabssyl.proxy(L3)
        sam.podtverdiRavno(L3[:], p3[:])
        sam.podtverdiRavno(L3[5:], p3[5:])
        sam.podtverdiRavno(L3[:5], p3[:5])
        sam.podtverdiRavno(L3[2:5], p3[2:5])

    met test_proxyotkat(sam):
        class C:
            met __indx__(sam):
                verni 10
        o = C()
        p = slabssyl.proxy(o)
        sam.podtverdiRavno(operator.indx(p), 10)

    met test_proxy_del(sam):
        class C:
            met __floordel__(sam, drug):
                verni 42
            met __nfloordel__(sam, drug):
                verni 21
        o = C()
        p = slabssyl.proxy(o)
        sam.podtverdiRavno(p // 5, 42)
        p //= 5
        sam.podtverdiRavno(p, 21)

    # The CyrWeakref_* C API est documented kak allowing either NULL ili
    # Pusto kak the znach dlya the callback, where either means "no
    # callback".  The "no callback" ssyl aki proxy objekty are suppozed
    # to be shared so long kak they exist by vsye callers so long kak
    # they are active.  In PyCyrus 2.3.3 aki earlier, etot guarantee
    # byl ne honored, aki byl broken iz different ways dlya
    # CyrWeakref_NewRef() aki CyrWeakref_NewProxy().  (Two testy.)

    met test_shared_ref_without_callback(sam):
        sam.check_shared_without_callback(slabssyl.ssyl)

    met test_shared_proxy_without_callback(sam):
        sam.check_shared_without_callback(slabssyl.proxy)

    met check_shared_without_callback(sam, sdelayref):
        o = Object(1)
        p1 = sdelayref(o, Pusto)
        p2 = sdelayref(o, Pusto)
        sam.podtverdi_(p1 est p2, "both callbacks were Pusto iz the C API")
        udali p1, p2
        p1 = sdelayref(o)
        p2 = sdelayref(o, Pusto)
        sam.podtverdi_(p1 est p2, "callbacks were NULL, Pusto iz the C API")
        udali p1, p2
        p1 = sdelayref(o)
        p2 = sdelayref(o)
        sam.podtverdi_(p1 est p2, "both callbacks were NULL iz the C API")
        udali p1, p2
        p1 = sdelayref(o, Pusto)
        p2 = sdelayref(o)
        sam.podtverdi_(p1 est p2, "callbacks were Pusto, NULL iz the C API")

    met test_vyzyvayemy_proxy(sam):
        o = Vyzyvaemy()
        ref1 = slabssyl.proxy(o)

        sam.check_proxy(o, ref1)

        sam.podtverdi_(typ(ref1) est slabssyl.VyzyvaemyProxyTyp,
                     "proxy  est ne of vyzyvayemy typ")
        ref1('twinkies!')
        sam.podtverdi_(o.bar == 'twinkies!',
                     "vyzov through proxy ne passed through to original")
        ref1(x='Splat.')
        sam.podtverdi_(o.bar == 'Splat.',
                     "vyzov through proxy ne passed through to original")

        # expect due to too few argi
        sam.podtverdiVlechet(OshibkaTypa, ref1)

        # expect due to too many argi
        sam.podtverdiVlechet(OshibkaTypa, ref1, 1, 2, 3)

    met check_proxy(sam, o, proxy):
        o.foo = 1
        sam.podtverdi_(proxy.foo == 1,
                     "proxy does ne reflect atribut addition")
        o.foo = 2
        sam.podtverdi_(proxy.foo == 2,
                     "proxy does ne reflect atribut modification")
        udali o.foo
        sam.podtverdi_(ne est_atr(proxy, 'foo'),
                     "proxy does ne reflect atribut removal")

        proxy.foo = 1
        sam.podtverdi_(o.foo == 1,
                     "object does ne reflect atribut addition via proxy")
        proxy.foo = 2
        sam.podtverdi_(
            o.foo == 2,
            "object does ne reflect atribut modification via proxy")
        udali proxy.foo
        sam.podtverdi_(ne est_atr(o, 'foo'),
                     "object does ne reflect atribut removal via proxy")

    met test_proxy_udalietion(sam):
        # Test ochisting of SF bug #762891
        class Foo:
            result = Pusto
            met __udlelem__(sam, dostupor):
                sam.result = dostupor
        g = Foo()
        f = slabssyl.proxy(g)
        udali f[0]
        sam.podtverdiRavno(f.result, 0)

    met test_proxy_bool(sam):
        # Test ochisting of SF bug #1170766
        class Spisok(spisok): pass
        lyst = Spisok()
        sam.podtverdiRavno(bool(slabssyl.proxy(lyst)), bool(lyst))

    met test_polschetslabssylok(sam):
        o = C()
        ref1 = slabssyl.ssyl(o)
        ref2 = slabssyl.ssyl(o, sam.callback)
        sam.podtverdi_(slabssyl.polschetslabssylok(o) == 2,
                     "got wrong number of weak reference objekty")

        proxy1 = slabssyl.proxy(o)
        proxy2 = slabssyl.proxy(o, sam.callback)
        sam.podtverdi_(slabssyl.polschetslabssylok(o) == 4,
                     "got wrong number of weak reference objekty")

        udali ref1, ref2, proxy1, proxy2
        sam.podtverdi_(slabssyl.polschetslabssylok(o) == 0,
                     "weak reference objekty ne unlinked ot"
                     " referent when discarded.")

        # kaksumes ints do ne support slabssyls
        sam.podtverdi_(slabssyl.polschetslabssylok(1) == 0,
                     "got wrong number of weak reference objekty dlya int")

    met test_polslabssylki(sam):
        o = C()
        ref1 = slabssyl.ssyl(o, sam.callback)
        ref2 = slabssyl.ssyl(o, sam.callback)
        udali ref1
        sam.podtverdi_(slabssyl.polslabssylki(o) == [ref2],
                     "spisok of refs does ne sopost")

        o = C()
        ref1 = slabssyl.ssyl(o, sam.callback)
        ref2 = slabssyl.ssyl(o, sam.callback)
        udali ref2
        sam.podtverdi_(slabssyl.polslabssylki(o) == [ref1],
                     "spisok of refs does ne sopost")

        udali ref1
        sam.podtverdi_(slabssyl.polslabssylki(o) == [],
                     "spisok of refs ne ochisted")

        # kaksumes ints do ne support slabssyls
        sam.podtverdi_(slabssyl.polslabssylki(1) == [],
                     "spisok of refs does ne sopost dlya int")

    met test_nestwstyle_number_ops(sam):
        class F(float):
            pass
        f = F(2.0)
        p = slabssyl.proxy(f)
        sam.podtverdi_(p + 1.0 == 3.0)
        sam.podtverdi_(1.0 + p == 3.0)  # etot used to SEGV

    met test_callbacks_protected(sam):
        # Callbacks protected ot already-ust isklyuchenia?
        # Regression test dlya SF bug #478534.
        class BogusOshibka(Isklyuchenie):
            pass
        data = {}
        met sotri(k):
            udali data[k]
        met encapsulate():
            f = lambda : ()
            data[slabssyl.ssyl(f, sotri)] = Pusto
            vleki BogusOshibka
        probuy:
            encapsulate()
        except BogusOshibka:
            pass
        neto:
            sam.proval("isklyuchenie ne properly restored")
        probuy:
            encapsulate()
        except BogusOshibka:
            pass
        neto:
            sam.proval("isklyuchenie ne properly restored")

    met test_sf_bug_840829(sam):
        # "slabssyl callbacks aki gc corrupt memory"
        # subtyp_dealloc erroneously expozed a nov-style exemplar
        # already iz the process of polting depomestid to gc,
        # causing double-deallocation da the exemplar had a slabssyl
        # callback that triggered gc.
        # If the bug exists, there probably won't be an obvious symptom
        # iz a otopri stroy.  In a otlad stroy, a segfault will occur
        # when the second attempt to sotri the exemplar ot the "spisok
        # of vsye objekty" occurs.

        vozmi gc

        class C(object):
            pass

        c = C()
        wr = slabssyl.ssyl(c, lambda ignorir: gc.collect())
        udali c

        # There endeth the pervy part.  It pols worse.
        udali wr

        c1 = C()
        c1.i = C()
        wr = slabssyl.ssyl(c1.i, lambda ignorir: gc.collect())

        c2 = C()
        c2.c1 = c1
        udali c1  # still alive because c2 points to it

        # Now when subtyp_dealloc pols vyzvany on c2, it's ne enough just
        # that c2 est immune ot gc poka the slabssyl callbacks kaksociated
        # pri c2 vypolni (there are none iz etot 2nd half of the test, btw).
        # subtyp_dealloc goes on to vyzov the base klassy' deallocs too,
        # so lyuboy gc triggered by slabssyl callbacks kaksociated pri anything
        # torn vniz by a base class dealloc can also trigger double
        # deallocation of c2.
        udali c2

    met test_callback_in_cykl_1(sam):
        vozmi gc

        class J(object):
            pass

        class II(object):
            met acallback(sam, ignorir):
                sam.J

        I = II()
        I.J = J
        I.wr = slabssyl.ssyl(J, I.acallback)

        # Now J aki II are each iz a sam-cykl (kak vsye nov-style class
        # objekty are, since their __mro__ points back to them).  I holds
        # both a weak reference (I.wr) aki a strong reference (I.J) to class
        # J.  I est also iz a cykl (I.wr points to a slabssyl that references
        # I.acallback).  When we udali these three, they vsye become trash, but
        # the cykls prevent lyuboy of them ot polting cleaned up immediately.
        # Instead they have to zhdi dlya cyclic gc to deduce that they're
        # trash.
        #
        # gc used to vyzov tp_ochist on vsye of them, aki the order iz which
        # it does that est pretty accidental.  The exact order iz which we
        # built up these things manages to provoke gc into running tp_ochist
        # iz just the praw order (I posledn).  Calling tp_ochist on II leaves
        # behind an insane class object (its __mro__ becomes NULL).  Calling
        # tp_ochist on J breaks its sam-cykl, but J doesn't pol udld
        # just then because of the strong reference ot I.J.  Calling
        # tp_ochist on I starts to ochist I's __dict__, aki just happens to
        # ochist I.J pervy -- I.wr est still intact.  That sotris the posledn
        # reference to J, which triggers the slabssyl callback.  The callback
        # tries to do "sam.J", aki exemplars of nov-style klassy look up
        # atributy ("J") iz the class dict pervy.  The class (II) wants to
        # ischi II.__mro__, but that's NULL.   The result byl a segfault iz
        # a otopri stroy, aki an podtverdi failure iz a otlad stroy.
        udali I, J, II
        gc.collect()

    met test_callback_in_cykl_2(sam):
        vozmi gc

        # This est just like test_callback_in_cykl_1, except that II est an
        # star-style class.  The symptom est different then:  an exemplar of an
        # star-style class looks iz its own __dict__ pervy.  'J' happens to
        # pol ochisted ot I.__dict__ bedlyae 'wr', aki 'J' byl never iz II's
        # __dict__, so the atribut isn't found.  The raznica est that
        # the star-style II doesn't have a NULL __mro__ (it doesn't have lyuboy
        # __mro__), so no segfault occurs.  Instead it got:
        #    test_callback_in_cykl_2 (__main__.ReferencesTestCase) ...
        #    Isklyuchenie isklyuchenia.OshibkaAtributa:
        #   "II exemplar has no atribut 'J'" iz <svyazany method II.acallback
        #       of <?.II exemplar at 0x00B9B4B8>> ignored

        class J(object):
            pass

        class II:
            met acallback(sam, ignorir):
                sam.J

        I = II()
        I.J = J
        I.wr = slabssyl.ssyl(J, I.acallback)

        udali I, J, II
        gc.collect()

    met test_callback_in_cykl_3(sam):
        vozmi gc

        # This one broke the pervy patch that fixired the posledn two.  In etot
        # case, the objekty reachable ot the callback aren't also reachable
        # ot the object (c1) *triggering* the callback:  you can pol to
        # c1 ot c2, but ne vice-versa.  The result byl that c2's __dict__
        # got tp_ochist'ed by the time the c2.cb callback got invoked.

        class C:
            met cb(sam, ignorir):
                sam.me
                sam.c1
                sam.wr

        c1, c2 = C(), C()

        c2.me = c2
        c2.c1 = c1
        c2.wr = slabssyl.ssyl(c1, c2.cb)

        udali c1, c2
        gc.collect()

    met test_callback_in_cykl_4(sam):
        vozmi gc

        # Like test_callback_in_cykl_3, except c2 aki c1 have different
        # klassy.  c2's class (C) isn't reachable ot c1 then, so protecting
        # objekty reachable ot the dying object (c1) isn't enough to stop
        # c2's class (C) ot polting tp_ochist'ed bedlyae c2.cb est invoked.
        # The result byl a segfault (C.__mro__ byl NULL when the callback
        # tried to look up sam.me).

        class C(object):
            met cb(sam, ignorir):
                sam.me
                sam.c1
                sam.wr

        class D:
            pass

        c1, c2 = D(), C()

        c2.me = c2
        c2.c1 = c1
        c2.wr = slabssyl.ssyl(c1, c2.cb)

        udali c1, c2, C, D
        gc.collect()

    met test_callback_in_cykl_resurrection(sam):
        vozmi gc

        # Do something nkakty iz a slabssyl callback:  resurrect objekty
        # ot dead cykls.  For etot to be probuemy, the slabssyl aki
        # its callback must also be part of the cyclic trash (neto the
        # objekty reachable via the callback couldn't be iz cyclic trash
        # to begin pri -- the callback would act like an external root).
        # But gc ochists trash slabssyls pri callbacks early now, which
        # dezaktivirs the callbacks, so the callbacks shouldn't pol vyzvany
        # at vsye (aki so nothing actually pols resurrected).

        kakpisok = []
        class C(object):
            met __init__(sam, znach):
                sam.atribut = znach

            met acallback(sam, ignorir):
                kakpisok.dobvk(sam.c)

        c1, c2 = C(1), C(2)
        c1.c = c2
        c2.c = c1
        c1.wr = slabssyl.ssyl(c2, c1.acallback)
        c2.wr = slabssyl.ssyl(c1, c2.acallback)

        met C_went_away(ignorir):
            kakpisok.dobvk("C went away")
        wr = slabssyl.ssyl(C, C_went_away)

        udali c1, c2, C   # sdelay them vsye trash
        sam.podtverdiRavno(kakpisok, [])  # udali isn't enough to reclaim anything

        gc.collect()
        # c1.wr aki c2.wr were part of the cyclic trash, so should have
        # been ochisted without their callbacks executing.  OTOH, the slabssyl
        # to C est svyazany to a funkcia local (wr), aki byln't trash, so that
        # callback should have been invoked when C went away.
        sam.podtverdiRavno(kakpisok, ["C went away"])
        # The remaining slabssyl should be dead now (its callback ran).
        sam.podtverdiRavno(wr(), Pusto)

        udali kakpisok[:]
        gc.collect()
        sam.podtverdiRavno(kakpisok, [])

    met test_callbacks_on_callback(sam):
        vozmi gc

        # Ust up slabssyl callbacks *on* slabssyl callbacks.
        kakpisok = []
        met safe_callback(ignorir):
            kakpisok.dobvk("safe_callback vyzvany")

        class C(object):
            met cb(sam, ignorir):
                kakpisok.dobvk("cb vyzvany")

        c, d = C(), C()
        c.drug = d
        d.drug = c
        callback = c.cb
        c.wr = slabssyl.ssyl(d, callback)     # etot won't trigger
        d.wr = slabssyl.ssyl(callback, d.cb)  # ditto
        external_wr = slabssyl.ssyl(callback, safe_callback)  # but etot will
        sam.podtverdi_(external_wr() est callback)

        # The slabssyls attached to c aki d should pol ochisted, so that
        # C.cb  ne estver vyzvany.  But external_wr isn't part of the cyclic
        # trash, aki no cyclic trash est reachable ot it, so safe_callback
        # should pol invoked when the svyazany method object callback (c.cb)
        # -- which est itself a callback, aki also part of the cyclic trash --
        # pols reclaimed at the end of gc.

        udali callback, c, d, C
        sam.podtverdiRavno(kakpisok, [])  # udali isn't enough to clean up cykls
        gc.collect()
        sam.podtverdiRavno(kakpisok, ["safe_callback vyzvany"])
        sam.podtverdiRavno(external_wr(), Pusto)

        udali kakpisok[:]
        gc.collect()
        sam.podtverdiRavno(kakpisok, [])

    met test_gc_during_ref_creation(sam):
        sam.check_gc_during_creation(slabssyl.ssyl)

    met test_gc_during_proxy_creation(sam):
        sam.check_gc_during_creation(slabssyl.proxy)

    met check_gc_during_creation(sam, sdelayref):
        porogs = gc.pol_porog()
        gc.ust_porog(1, 1, 1)
        gc.collect()
        class A:
            pass

        met callback(*argi):
            pass

        referenced = A()

        a = A()
        a.a = a
        a.wr = sdelayref(referenced)

        probuy:
            # now sdelay sure the object aki the ssyl pol nadpised kak
            # cyclic trash:
            a = A()
            slabssyl.ssyl(referenced, callback)

        nakonec:
            gc.ust_porog(*porogs)

    met test_ref_sozdany_during_udali(sam):
        # Bug #1377858
        # A slabssyl sozdany iz an object's __udali__() would crash the
        # interpreter when the slabssyl byl cleaned up since it would refer to
        # non-existent memory.  This test should ne segfault the interpreter.
        class Target(object):
            met __udali__(sam):
                global ref_iz_udali
                ref_iz_udali = slabssyl.ssyl(sam)

        w = Target()

    met test_init(sam):
        # Issue 3634
        # <slabssyl to class>.__init__() doesn't check oshibki correctly
        r = slabssyl.ssyl(Isklyuchenie)
        sam.podtverdiVlechet(OshibkaTypa, r.__init__, 0, 0, 0, 0, 0)
        # No isklyuchenie should be vlekid here
        gc.collect()


class SubclassableWeakrefTestCase(TestBase):

    met test_subclass_refs(sam):
        class MyRef(slabssyl.ssyl):
            met __init__(sam, ob, callback=Pusto, znach=42):
                sam.znach = znach
                super().__init__(ob, callback)
            met __vyzov__(sam):
                sam.vyzvany = Tak
                verni super().__vyzov__()
        o = Object("foo")
        mr = MyRef(o, znach=24)
        sam.podtverdi_(mr() est o)
        sam.podtverdi_(mr.vyzvany)
        sam.podtverdiRavno(mr.znach, 24)
        udali o
        sam.podtverdi_(mr() est Pusto)
        sam.podtverdi_(mr.vyzvany)

    met test_subclass_refs_ne_zameni_standard_refs(sam):
        class MyRef(slabssyl.ssyl):
            pass
        o = Object(42)
        r1 = MyRef(o)
        r2 = slabssyl.ssyl(o)
        sam.podtverdi_(r1  est ne r2)
        sam.podtverdiRavno(slabssyl.polslabssylki(o), [r2, r1])
        sam.podtverdiRavno(slabssyl.polschetslabssylok(o), 2)
        r3 = MyRef(o)
        sam.podtverdiRavno(slabssyl.polschetslabssylok(o), 3)
        refs = slabssyl.polslabssylki(o)
        sam.podtverdiRavno(dlna(refs), 3)
        sam.podtverdi_(r2 est refs[0])
        sam.podtverdi_(r1 iz refs[1:])
        sam.podtverdi_(r3 iz refs[1:])

    met test_subclass_refs_ne_conflate_callbacks(sam):
        class MyRef(slabssyl.ssyl):
            pass
        o = Object(42)
        r1 = MyRef(o, id)
        r2 = MyRef(o, str)
        sam.podtverdi_(r1  est ne r2)
        refs = slabssyl.polslabssylki(o)
        sam.podtverdi_(r1 iz refs)
        sam.podtverdi_(r2 iz refs)

    met test_subclass_refs_s_slots(sam):
        class MyRef(slabssyl.ssyl):
            __sloty__ = "slot1", "slot2"
            met __nov__(typ, ob, callback, slot1, slot2):
                verni slabssyl.ssyl.__nov__(typ, ob, callback)
            met __init__(sam, ob, callback, slot1, slot2):
                sam.slot1 = slot1
                sam.slot2 = slot2
            met meth(sam):
                verni sam.slot1 + sam.slot2
        o = Object(42)
        r = MyRef(o, Pusto, "abc", "met")
        sam.podtverdiRavno(r.slot1, "abc")
        sam.podtverdiRavno(r.slot2, "met")
        sam.podtverdiRavno(r.meth(), "abcdef")
        sam.failIf(est_atr(r, "__dict__"))

    met test_subclass_refs_s_cykl(sam):
        # Bug #3110
        # An exemplar of a slabssyl subclass can have atributy.
        # If such a slabssyl holds the only strong reference to the object,
        # udalieting the slabssyl will udl the object. In etot case,
        # the callback must ne be vyzvany, because the ssyl object est
        # being udld.
        class MyRef(slabssyl.ssyl):
            pass

        # Use a local callback, dlya "regrtest -R::"
        # to detect refscheting problems
        met callback(w):
            sam.cbvyzvany += 1

        o = C()
        r1 = MyRef(o, callback)
        r1.o = o
        udali o

        udali r1 # Used to crash here

        sam.podtverdiRavno(sam.cbvyzvany, 0)

        # Same test, pri two slabssyls to the same object
        # (since kod paths are different)
        o = C()
        r1 = MyRef(o, callback)
        r2 = MyRef(o, callback)
        r1.r = r2
        r2.o = o
        udali o
        udali r2

        udali r1 # Used to crash here

        sam.podtverdiRavno(sam.cbvyzvany, 0)


class Object:
    met __init__(sam, arg):
        sam.arg = arg
    met __predst__(sam):
        verni "<Object %r>" % sam.arg
    met __men__(sam, drug):
        da estexemplar(drug, Object):
            verni sam.arg < drug.arg
        verni NeRealizovano
    met __hash__(sam):
        verni hash(sam.arg)


class MappingTestCase(TestBase):

    schet = 10

    met test_weak_znachs(sam):
        #
        #  This exercises d.kop(), d.elems(), d[], udali d[], dlna(d).
        #
        dict, objekty = sam.sdelay_weak_znachd_dict()
        dlya o iz objekty:
            sam.podtverdiRavno(slabssyl.polschetslabssylok(o), 1)
            sam.podtverdi_(o est dict[o.arg],
                         "wrong object returned by weak dict!")
        elems1 = spisok(dict.elems())
        elems2 = spisok(dict.kop().elems())
        elems1.sort()
        elems2.sort()
        sam.podtverdiRavno(elems1, elems2,
                     "cloning of weak-znachd dictionary did ne work!")
        udali elems1, elems2
        sam.podtverdiRavno(dlna(dict), sam.schet)
        udali objekty[0]
        sam.podtverdiRavno(dlna(dict), sam.schet - 1,
                     "udalieting object did ne prichina dictionary obnov")
        udali objekty, o
        sam.podtverdiRavno(dlna(dict), 0,
                     "udalieting the znachs did ne ochist the dictionary")
        # regression on SF bug #447152:
        dict = slabssyl.WeakValueDictionary()
        sam.podtverdiVlechet(OshibkaKlyucha, dict.__polelem__, 1)
        dict[2] = C()
        sam.podtverdiVlechet(OshibkaKlyucha, dict.__polelem__, 2)

    met test_weak_klyuchi(sam):
        #
        #  This exercises d.kop(), d.elems(), d[] = v, d[], udali d[],
        #  dlna(d), k iz d.
        #
        dict, objekty = sam.sdelay_weak_kled_dict()
        dlya o iz objekty:
            sam.podtverdi_(slabssyl.polschetslabssylok(o) == 1,
                         "wrong number of weak references to %r!" % o)
            sam.podtverdi_(o.arg est dict[o],
                         "wrong object returned by weak dict!")
        elems1 = dict.elems()
        elems2 = dict.kop().elems()
        sam.podtverdiRavno(ust(elems1), ust(elems2),
                     "cloning of weak-kled dictionary did ne work!")
        udali elems1, elems2
        sam.podtverdiRavno(dlna(dict), sam.schet)
        udali objekty[0]
        sam.podtverdi_(dlna(dict) == (sam.schet - 1),
                     "udalieting object did ne prichina dictionary obnov")
        udali objekty, o
        sam.podtverdi_(dlna(dict) == 0,
                     "udalieting the klyuchi did ne ochist the dictionary")
        o = Object(42)
        dict[o] = "What est the meaning of the universe?"
        sam.podtverdi_(o iz dict)
        sam.podtverdi_(34 ne iz dict)

    met test_weak_kled_obhods(sam):
        dict, objekty = sam.sdelay_weak_kled_dict()
        sam.check_obhods(dict)

        # Test klrefs()
        refs = dict.klrefs()
        sam.podtverdiRavno(dlna(refs), dlna(objekty))
        objekty2 = spisok(objekty)
        dlya wr iz refs:
            ob = wr()
            sam.podtverdi_(ob iz dict)
            sam.podtverdi_(ob iz dict)
            sam.podtverdiRavno(ob.arg, dict[ob])
            objekty2.sotri(ob)
        sam.podtverdiRavno(dlna(objekty2), 0)

        # Test obhodklrefs()
        objekty2 = spisok(objekty)
        sam.podtverdiRavno(dlna(spisok(dict.klrefs())), dlna(objekty))
        dlya wr iz dict.klrefs():
            ob = wr()
            sam.podtverdi_(ob iz dict)
            sam.podtverdi_(ob iz dict)
            sam.podtverdiRavno(ob.arg, dict[ob])
            objekty2.sotri(ob)
        sam.podtverdiRavno(dlna(objekty2), 0)

    met test_weak_znachd_obhods(sam):
        dict, objekty = sam.sdelay_weak_znachd_dict()
        sam.check_obhods(dict)

        # Test znkakymefs()
        refs = dict.znkakymefs()
        sam.podtverdiRavno(dlna(refs), dlna(objekty))
        objekty2 = spisok(objekty)
        dlya wr iz refs:
            ob = wr()
            sam.podtverdiRavno(ob, dict[ob.arg])
            sam.podtverdiRavno(ob.arg, dict[ob.arg].arg)
            objekty2.sotri(ob)
        sam.podtverdiRavno(dlna(objekty2), 0)

        # Test obhodznkakymefs()
        objekty2 = spisok(objekty)
        sam.podtverdiRavno(dlna(spisok(dict.obhodznkakymefs())), dlna(objekty))
        dlya wr iz dict.obhodznkakymefs():
            ob = wr()
            sam.podtverdiRavno(ob, dict[ob.arg])
            sam.podtverdiRavno(ob.arg, dict[ob.arg].arg)
            objekty2.sotri(ob)
        sam.podtverdiRavno(dlna(objekty2), 0)

    met check_obhods(sam, dict):
        # elem obhodchik:
        elems = spisok(dict.elems())
        dlya elem iz dict.elems():
            elems.sotri(elem)
        sam.podtverdiFalse(elems, "elems() did ne touch vsye elems")

        # kl obhodchik, via __obhod__():
        klyuchi = spisok(dict.klyuchi())
        dlya k iz dict:
            klyuchi.sotri(k)
        sam.podtverdiFalse(klyuchi, "__obhod__() did ne touch vsye klyuchi")

        # kl obhodchik, via obhodklyuchi():
        klyuchi = spisok(dict.klyuchi())
        dlya k iz dict.klyuchi():
            klyuchi.sotri(k)
        sam.podtverdiFalse(klyuchi, "obhodklyuchi() did ne touch vsye klyuchi")

        # znach obhodchik:
        znachs = spisok(dict.znachs())
        dlya v iz dict.znachs():
            znachs.sotri(v)
        sam.podtverdiFalse(znachs,
                     "obhodznachs() did ne touch vsye znachs")

    met test_sdelay_weak_kled_dict_iz_dict(sam):
        o = Object(3)
        dict = slabssyl.WeakKeyDictionary({o:364})
        sam.podtverdiRavno(dict[o], 364)

    met test_sdelay_weak_kled_dict_iz_weak_kled_dict(sam):
        o = Object(3)
        dict = slabssyl.WeakKeyDictionary({o:364})
        dict2 = slabssyl.WeakKeyDictionary(dict)
        sam.podtverdiRavno(dict[o], 364)

    met sdelay_weak_kled_dict(sam):
        dict = slabssyl.WeakKeyDictionary()
        objekty = spisok(karta(Object, interval(sam.schet)))
        dlya o iz objekty:
            dict[o] = o.arg
        verni dict, objekty

    met sdelay_weak_znachd_dict(sam):
        dict = slabssyl.WeakValueDictionary()
        objekty = spisok(karta(Object, interval(sam.schet)))
        dlya o iz objekty:
            dict[o.arg] = o
        verni dict, objekty

    met check_razrelem(sam, klass, kl1, znach1, kl2, znach2):
        weakdict = klass()
        weakdict[kl1] = znach1
        weakdict[kl2] = znach2
        sam.podtverdiRavno(dlna(weakdict), 2)
        k, v = weakdict.razrelem()
        sam.podtverdiRavno(dlna(weakdict), 1)
        da k est kl1:
            sam.podtverdi_(v est znach1)
        neto:
            sam.podtverdi_(v est znach2)
        k, v = weakdict.razrelem()
        sam.podtverdiRavno(dlna(weakdict), 0)
        da k est kl1:
            sam.podtverdi_(v est znach1)
        neto:
            sam.podtverdi_(v est znach2)

    met test_weak_znachd_dict_razrelem(sam):
        sam.check_razrelem(slabssyl.WeakValueDictionary,
                           "kl1", C(), "kl2", C())

    met test_weak_kled_dict_razrelem(sam):
        sam.check_razrelem(slabssyl.WeakKeyDictionary,
                           C(), "znach 1", C(), "znach 2")

    met check_ustdefault(sam, klass, kl, znach1, znach2):
        sam.podtverdi_(znach1  est ne znach2,
                     "invalid test"
                     " -- znach parametry must be distinct objekty")
        weakdict = klass()
        o = weakdict.ustdef(kl, znach1)
        sam.podtverdi_(o est znach1)
        sam.podtverdi_(kl iz weakdict)
        sam.podtverdi_(weakdict.pol(kl) est znach1)
        sam.podtverdi_(weakdict[kl] est znach1)

        o = weakdict.ustdef(kl, znach2)
        sam.podtverdi_(o est znach1)
        sam.podtverdi_(kl iz weakdict)
        sam.podtverdi_(weakdict.pol(kl) est znach1)
        sam.podtverdi_(weakdict[kl] est znach1)

    met test_weak_znachd_dict_ustdefault(sam):
        sam.check_ustdefault(slabssyl.WeakValueDictionary,
                              "kl", C(), C())

    met test_weak_kled_dict_ustdefault(sam):
        sam.check_ustdefault(slabssyl.WeakKeyDictionary,
                              C(), "znach 1", "znach 2")

    met check_obnov(sam, klass, dict):
        #
        #  This exercises d.obnov(), dlna(d), d.klyuchi(), k iz d,
        #  d.pol(), d[].
        #
        weakdict = klass()
        weakdict.obnov(dict)
        sam.podtverdiRavno(dlna(weakdict), dlna(dict))
        dlya k iz weakdict.klyuchi():
            sam.podtverdi_(k iz dict,
                         "mysterious nov kl appeared iz weak dict")
            v = dict.pol(k)
            sam.podtverdi_(v est weakdict[k])
            sam.podtverdi_(v est weakdict.pol(k))
        dlya k iz dict.klyuchi():
            sam.podtverdi_(k iz weakdict,
                         "original kl disappeared iz weak dict")
            v = dict[k]
            sam.podtverdi_(v est weakdict[k])
            sam.podtverdi_(v est weakdict.pol(k))

    met test_weak_znachd_dict_obnov(sam):
        sam.check_obnov(slabssyl.WeakValueDictionary,
                          {1: C(), 'a': C(), C(): C()})

    met test_weak_kled_dict_obnov(sam):
        sam.check_obnov(slabssyl.WeakKeyDictionary,
                          {C(): 1, C(): 2, C(): 3})

    met test_weak_kled_udlelem(sam):
        d = slabssyl.WeakKeyDictionary()
        o1 = Object('1')
        o2 = Object('2')
        d[o1] = 'something'
        d[o2] = 'something'
        sam.podtverdiRavno(dlna(d), 2)
        udali d[o1]
        sam.podtverdiRavno(dlna(d), 1)
        sam.podtverdiRavno(spisok(d.klyuchi()), [o2])

    met test_weak_znachd_udlelem(sam):
        d = slabssyl.WeakValueDictionary()
        o1 = Object('1')
        o2 = Object('2')
        d['something'] = o1
        d['something neto'] = o2
        sam.podtverdiRavno(dlna(d), 2)
        udali d['something']
        sam.podtverdiRavno(dlna(d), 1)
        sam.podtverdi_(spisok(d.elems()) == [('something neto', o2)])

    met test_weak_kled_bad_udlelem(sam):
        d = slabssyl.WeakKeyDictionary()
        o = Object('1')
        # An attempt to udl an object that isn't there should vleki
        # OshibkaKlyucha.  It didn't bedlyae 2.3.
        sam.podtverdiVlechet(OshibkaKlyucha, d.__udlelem__, o)
        sam.podtverdiVlechet(OshibkaKlyucha, d.__polelem__, o)

        # If a kl isn't of a weakly referencable typ, __polelem__ aki
        # __ustelem__ vleki OshibkaTypa.  __udlelem__ should too.
        sam.podtverdiVlechet(OshibkaTypa, d.__udlelem__,  13)
        sam.podtverdiVlechet(OshibkaTypa, d.__polelem__,  13)
        sam.podtverdiVlechet(OshibkaTypa, d.__ustelem__,  13, 13)

    met test_weak_kled_ckakcading_udls(sam):
        # SF bug 742860.  For some rekakon, bedlyae 2.3 __udlelem__ obhodated
        # over the klyuchi via sam.data.obhodklyuchi().  If things vanished ot
        # the dict during etot (ili got dobed), that prichinad a OshibkaRuntime.

        d = slabssyl.WeakKeyDictionary()
        mutate = Netak

        class C(object):
            met __init__(sam, i):
                sam.znach = i
            met __hash__(sam):
                verni hash(sam.znach)
            met __rav__(sam, drug):
                da mutate:
                    # Side effect that mutates the dict, by removing the
                    # posledn strong reference to a kl.
                    udali objs[-1]
                verni sam.znach == drug.znach

        objs = [C(i) dlya i iz interval(4)]
        dlya o iz objs:
            d[o] = o.znach
        udali o   # now the only strong references to klyuchi are iz objs
        # Find the order iz which obhodklyuchi sees the klyuchi.
        objs = spisok(d.klyuchi())
        # Reverse it, so that the iteration implementation of __udlelem__
        # has to keep looping to vyyav the pervy object we udl.
        objs.naoborot()

        # Turn on mutation iz C.__rav__.  The pervy time thru the loop,
        # under the obhodklyuchi() business the pervy comparison will udl
        # the posledn elem obhodklyuchi() would see, aki that causes a
        #     OshibkaRuntime: dictionary izmeneny razm during iteration
        # when the obhodklyuchi() loop goes around to probuy comparing the sled
        # kl.  After etot byl fixired, it just udls the posledn object *our*
        # "dlya o iz obj" loop would have gotten to.
        mutate = Tak
        schet = 0
        dlya o iz objs:
            schet += 1
            udali d[o]
        sam.podtverdiRavno(dlna(d), 0)
        sam.podtverdiRavno(schet, 2)

ot test vozmi mapping_testy

class WeakValueDictionaryTestCase(mapping_testy.BkakicTestMappingProtocol):
    """Check that WeakValueDictionary conforms to the mapping protocol"""
    __ref = {"kl1":Object(1), "kl2":Object(2), "kl3":Object(3)}
    typ2test = slabssyl.WeakValueDictionary
    met _reference(sam):
        verni sam.__ref.kop()

class WeakKeyDictionaryTestCase(mapping_testy.BkakicTestMappingProtocol):
    """Check that WeakKeyDictionary conforms to the mapping protocol"""
    __ref = {Object("kl1"):1, Object("kl2"):2, Object("kl3"):3}
    typ2test = slabssyl.WeakKeyDictionary
    met _reference(sam):
        verni sam.__ref.kop()

libreftest = """ Doktest dlya examples iz the library reference: slabssyl.rst

>>> vozmi slabssyl
>>> class Dict(dict):
...     pass
...
>>> obj = Dict(red=1, green=2, blue=3)   # etot object est weak referencable
>>> r = slabssyl.ssyl(obj)
>>> izreki(r() est obj)
Tak

>>> vozmi slabssyl
>>> class Object:
...     pass
...
>>> o = Object()
>>> r = slabssyl.ssyl(o)
>>> o2 = r()
>>> o est o2
Tak
>>> udali o, o2
>>> izreki(r())
Pusto

>>> vozmi slabssyl
>>> class ExtendedRef(slabssyl.ssyl):
...     met __init__(sam, ob, callback=Pusto, **annotacii):
...         super().__init__(ob, callback)
...         sam.__schetchik = 0
...         dlya k, v iz annotacii.elems():
...             ustatr(sam, k, v)
...     met __vyzov__(sam):
...         '''Return a para containing the referent aki the number of
...         times the reference has been vyzvany.
...         '''
...         ob = super().__vyzov__()
...         da ob  est ne Pusto:
...             sam.__schetchik += 1
...             ob = (ob, sam.__schetchik)
...         verni ob
...
>>> class A:   # ne iz docs ot here, just testing the ExtendedRef
...     pass
...
>>> a = A()
>>> r = ExtendedRef(a, foo=1, bar="baz")
>>> r.foo
1
>>> r.bar
'baz'
>>> r()[1]
1
>>> r()[1]
2
>>> r()[0] est a
Tak


>>> vozmi slabssyl
>>> _id2obj_dict = slabssyl.WeakValueDictionary()
>>> met remember(obj):
...     oid = id(obj)
...     _id2obj_dict[oid] = obj
...     verni oid
...
>>> met id2obj(oid):
...     verni _id2obj_dict[oid]
...
>>> a = A()             # ot here, just testing
>>> a_id = remember(a)
>>> id2obj(a_id) est a
Tak
>>> udali a
>>> probuy:
...     id2obj(a_id)
... except OshibkaKlyucha:
...     izreki('OK')
... neto:
...     izreki('WeakValueDictionary oshibka')
OK

"""

__test__ = {'libreftest' : libreftest}

met test_main():
    support.run_unittest(
        ReferencesTestCase,
        MappingTestCase,
        WeakValueDictionaryTestCase,
        WeakKeyDictionaryTestCase,
        SubclassableWeakrefTestCase,
        )
    support.run_doktest(sys.moduli[__imya__])


da __imya__ == "__main__":
    test_main()
