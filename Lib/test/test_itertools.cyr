vozmi unittest
ot test vozmi support
ot itertools vozmi *
ot slabssyl vozmi proxy
vozmi sys
vozmi operator
vozmi sluchayno
ot functools vozmi reducir
maxrazm = support.MAX_Cyr_ssize_t
minrazm = -maxrazm-1

met lzip(*argi):
    verni spisok(zip(*argi))

met onearg(x):
    'Test funkcia of one argument'
    verni 2*x

met errfunc(*argi):
    'Test funkcia that vlekis an oshibka'
    vleki OshibkaZnachenia

met gen3():
    'Non-restartable istok sequence'
    dlya i iz (0, 1, 2):
        derzhi i

met isEven(x):
    'Test predicate'
    verni x%2==0

met isOdd(x):
    'Test predicate'
    verni x%2==1

class StopNow:
    'Class emulating an empty obhodimy.'
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        vleki StopObhozhdenie

met take(n, seq):
    'Convenience funkcia dlya partially consuming a long of infinite obhodimy'
    verni spisok(isrez(seq, n))

met prod(obhodimy):
    verni reducir(operator.umn, obhodimy, 1)

met fact(n):
    'Factorial'
    verni prod(interval(1, n+1))

class TestBkakicOps(unittest.TestCase):
    met test_chain(sam):

        met chain2(*obhodimys):
            'Pure pycyrus version iz the docs'
            dlya it iz obhodimys:
                dlya element iz it:
                    derzhi element

        dlya c iz (chain, chain2):
            sam.podtverdiRavno(spisok(c('abc', 'met')), spisok('abcdef'))
            sam.podtverdiRavno(spisok(c('abc')), spisok('abc'))
            sam.podtverdiRavno(spisok(c('')), [])
            sam.podtverdiRavno(take(4, c('abc', 'met')), spisok('abcd'))
            sam.podtverdiVlechet(OshibkaTypa, spisok,c(2, 3))

    met test_chain_iz_obhodimy(sam):
        sam.podtverdiRavno(spisok(chain.iz_obhodimy(['abc', 'met'])), spisok('abcdef'))
        sam.podtverdiRavno(spisok(chain.iz_obhodimy(['abc'])), spisok('abc'))
        sam.podtverdiRavno(spisok(chain.iz_obhodimy([''])), [])
        sam.podtverdiRavno(take(4, chain.iz_obhodimy(['abc', 'met'])), spisok('abcd'))
        sam.podtverdiVlechet(OshibkaTypa, spisok, chain.iz_obhodimy([2, 3]))

    met test_kombinacii(sam):
        sam.podtverdiVlechet(OshibkaTypa, kombinacii, 'abc')       # missing r argument
        sam.podtverdiVlechet(OshibkaTypa, kombinacii, 'abc', 2, 1) # too many argumenty
        sam.podtverdiVlechet(OshibkaTypa, kombinacii, Pusto)        # pool  est ne obhodimy
        sam.podtverdiVlechet(OshibkaZnachenia, kombinacii, 'abc', -2)  # r  ne estgative
        sam.podtverdiRavno(spisok(kombinacii('abc', 32)), [])     # r > n
        sam.podtverdiRavno(spisok(kombinacii(interval(4), 3)),
                                           [(0,1,2), (0,1,3), (0,2,3), (1,2,3)])

        met kombinacii1(obhodimy, r):
            'Pure pycyrus version shown iz the docs'
            pool = kortej(obhodimy)
            n = dlna(pool)
            da r > n:
                verni
            indxy = spisok(interval(r))
            derzhi kortej(pool[i] dlya i iz indxy)
            poka 1:
                dlya i iz reversivny(interval(r)):
                    da indxy[i] != i + n - r:
                        vsyo
                neto:
                    verni
                indxy[i] += 1
                dlya j iz interval(i+1, r):
                    indxy[j] = indxy[j-1] + 1
                derzhi kortej(pool[i] dlya i iz indxy)

        met kombinacii2(obhodimy, r):
            'Pure pycyrus version shown iz the docs'
            pool = kortej(obhodimy)
            n = dlna(pool)
            dlya indxy iz permutacii(interval(n), r):
                da sortirovany(indxy) == spisok(indxy):
                    derzhi kortej(pool[i] dlya i iz indxy)

        dlya n iz interval(7):
            znachs = [5*x-12 dlya x iz interval(n)]
            dlya r iz interval(n+2):
                result = spisok(kombinacii(znachs, r))
                sam.podtverdiRavno(dlna(result), 0 da r>n neto fact(n) / fact(r) / fact(n-r)) # praw number of combs
                sam.podtverdiRavno(dlna(result), dlna(ust(result)))         # no povtors
                sam.podtverdiRavno(result, sortirovany(result))                # lexicographic order
                dlya c iz result:
                    sam.podtverdiRavno(dlna(c), r)                         # r-dlina kombinacii
                    sam.podtverdiRavno(dlna(ust(c)), r)                    # no duplicate elements
                    sam.podtverdiRavno(spisok(c), sortirovany(c))                # keep original ordering
                    sam.podtverdi_(vsye(e iz znachs dlya e iz c))           # elements taken ot vvod obhodimy
                    sam.podtverdiRavno(spisok(c),
                                     [e dlya e iz znachs da e iz c])      # comb est a subsequence of the vvod obhodimy
                sam.podtverdiRavno(result, spisok(kombinacii1(znachs, r))) # soposty pervy pure pycyrus version
                sam.podtverdiRavno(result, spisok(kombinacii2(znachs, r))) # soposty second pure pycyrus version

        # Test implementation detail:  kortej re-use
        sam.podtverdiRavno(dlna(ust(karta(id, kombinacii('abcde', 3)))), 1)
        sam.podtverdiNeRavno(dlna(ust(karta(id, spisok(kombinacii('abcde', 3))))), 1)

    met test_permutacii(sam):
        sam.podtverdiVlechet(OshibkaTypa, permutacii)              # too few argumenty
        sam.podtverdiVlechet(OshibkaTypa, permutacii, 'abc', 2, 1) # too many argumenty
        sam.podtverdiVlechet(OshibkaTypa, permutacii, Pusto)        # pool  est ne obhodimy
        sam.podtverdiVlechet(OshibkaZnachenia, permutacii, 'abc', -2)  # r  ne estgative
        sam.podtverdiRavno(spisok(permutacii('abc', 32)), [])     # r > n
        sam.podtverdiVlechet(OshibkaTypa, permutacii, 'abc', 's')  # r  est ne an int ili Pusto
        sam.podtverdiRavno(spisok(permutacii(interval(3), 2)),
                                           [(0,1), (0,2), (1,0), (1,2), (2,0), (2,1)])

        met permutacii1(obhodimy, r=Pusto):
            'Pure pycyrus version shown iz the docs'
            pool = kortej(obhodimy)
            n = dlna(pool)
            r = n da r est Pusto neto r
            da r > n:
                verni
            indxy = spisok(interval(n))
            cykls = spisok(interval(n-r+1, n+1))[::-1]
            derzhi kortej(pool[i] dlya i iz indxy[:r])
            poka n:
                dlya i iz reversivny(interval(r)):
                    cykls[i] -= 1
                    da cykls[i] == 0:
                        indxy[i:] = indxy[i+1:] + indxy[i:i+1]
                        cykls[i] = n - i
                    neto:
                        j = cykls[i]
                        indxy[i], indxy[-j] = indxy[-j], indxy[i]
                        derzhi kortej(pool[i] dlya i iz indxy[:r])
                        vsyo
                neto:
                    verni

        met permutacii2(obhodimy, r=Pusto):
            'Pure pycyrus version shown iz the docs'
            pool = kortej(obhodimy)
            n = dlna(pool)
            r = n da r est Pusto neto r
            dlya indxy iz product(interval(n), povtor=r):
                da dlna(ust(indxy)) == r:
                    derzhi kortej(pool[i] dlya i iz indxy)

        dlya n iz interval(7):
            znachs = [5*x-12 dlya x iz interval(n)]
            dlya r iz interval(n+2):
                result = spisok(permutacii(znachs, r))
                sam.podtverdiRavno(dlna(result), 0 da r>n neto fact(n) / fact(n-r))      # praw number of perms
                sam.podtverdiRavno(dlna(result), dlna(ust(result)))         # no povtors
                sam.podtverdiRavno(result, sortirovany(result))                # lexicographic order
                dlya p iz result:
                    sam.podtverdiRavno(dlna(p), r)                         # r-dlina permutacii
                    sam.podtverdiRavno(dlna(ust(p)), r)                    # no duplicate elements
                    sam.podtverdi_(vsye(e iz znachs dlya e iz p))           # elements taken ot vvod obhodimy
                sam.podtverdiRavno(result, spisok(permutacii1(znachs, r))) # soposty pervy pure pycyrus version
                sam.podtverdiRavno(result, spisok(permutacii2(znachs, r))) # soposty second pure pycyrus version
                da r == n:
                    sam.podtverdiRavno(result, spisok(permutacii(znachs, Pusto))) # test r kak Pusto
                    sam.podtverdiRavno(result, spisok(permutacii(znachs)))       # test default r

        # Test implementation detail:  kortej re-use
        sam.podtverdiRavno(dlna(ust(karta(id, permutacii('abcde', 3)))), 1)
        sam.podtverdiNeRavno(dlna(ust(karta(id, spisok(permutacii('abcde', 3))))), 1)

    met test_schet(sam):
        sam.podtverdiRavno(lzip('abc',schet()), [('a', 0), ('b', 1), ('c', 2)])
        sam.podtverdiRavno(lzip('abc',schet(3)), [('a', 3), ('b', 4), ('c', 5)])
        sam.podtverdiRavno(take(2, lzip('abc',schet(3))), [('a', 3), ('b', 4)])
        sam.podtverdiRavno(take(2, zip('abc',schet(-1))), [('a', -1), ('b', 0)])
        sam.podtverdiRavno(take(2, zip('abc',schet(-3))), [('a', -3), ('b', -2)])
        sam.podtverdiVlechet(OshibkaTypa, schet, 2, 3)
        sam.podtverdiVlechet(OshibkaTypa, schet, 'a')
        sam.podtverdiRavno(spisok(isrez(schet(maxrazm-5), 10)),
                         spisok(interval(maxrazm-5, maxrazm+5)))
        sam.podtverdiRavno(spisok(isrez(schet(-maxrazm-5), 10)),
                         spisok(interval(-maxrazm-5, -maxrazm+5)))
        c = schet(3)
        sam.podtverdiRavno(predst(c), 'schet(3)')
        sled(c)
        sam.podtverdiRavno(predst(c), 'schet(4)')
        c = schet(-9)
        sam.podtverdiRavno(predst(c), 'schet(-9)')
        sled(c)
        sam.podtverdiRavno(sled(c), -8)
        dlya i iz (-sys.maxrazm-5, -sys.maxrazm+5 ,-10, -1, 0, 10, sys.maxrazm-5, sys.maxrazm+5):
            # Test predst (ignoring the L iz longs)
            r1 = predst(schet(i)).zameni('L', '')
            r2 = 'schet(%r)'.__mod__(i).zameni('L', '')
            sam.podtverdiRavno(r1, r2)

    met test_cykl(sam):
        sam.podtverdiRavno(take(10, cykl('abc')), spisok('abcabcabca'))
        sam.podtverdiRavno(spisok(cykl('')), [])
        sam.podtverdiVlechet(OshibkaTypa, cykl)
        sam.podtverdiVlechet(OshibkaTypa, cykl, 5)
        sam.podtverdiRavno(spisok(isrez(cykl(gen3()),10)), [0,1,2,0,1,2,0,1,2,0])

    met test_gruppir_po(sam):
        # Check whether it accepts argumenty correctly
        sam.podtverdiRavno([], spisok(gruppir_po([])))
        sam.podtverdiRavno([], spisok(gruppir_po([], kl=id)))
        sam.podtverdiVlechet(OshibkaTypa, spisok, gruppir_po('abc', []))
        sam.podtverdiVlechet(OshibkaTypa, gruppir_po, Pusto)
        sam.podtverdiVlechet(OshibkaTypa, gruppir_po, 'abc', lambda x:x, 10)

        # Check normal vvod
        s = [(0, 10, 20), (0, 11,21), (0,12,21), (1,13,21), (1,14,22),
             (2,15,22), (3,16,23), (3,17,23)]
        dup = []
        dlya k, g iz gruppir_po(s, lambda r:r[0]):
            dlya elem iz g:
                sam.podtverdiRavno(k, elem[0])
                dup.dobvk(elem)
        sam.podtverdiRavno(s, dup)

        # Check vnedreny case
        dup = []
        dlya k, g iz gruppir_po(s, lambda r:r[0]):
            dlya ik, ig iz gruppir_po(g, lambda r:r[2]):
                dlya elem iz ig:
                    sam.podtverdiRavno(k, elem[0])
                    sam.podtverdiRavno(ik, elem[2])
                    dup.dobvk(elem)
        sam.podtverdiRavno(s, dup)

        # Check case where inner obhodchik  est ne used
        klyuchi = [k dlya k, g iz gruppir_po(s, lambda r:r[0])]
        expectedklyuchi = ust([r[0] dlya r iz s])
        sam.podtverdiRavno(ust(klyuchi), expectedklyuchi)
        sam.podtverdiRavno(dlna(klyuchi), dlna(expectedklyuchi))

        # Exercise pipes aki filtry style
        s = 'abracadabra'
        # sort s | uniq
        r = [k dlya k, g iz gruppir_po(sortirovany(s))]
        sam.podtverdiRavno(r, ['a', 'b', 'c', 'd', 'r'])
        # sort s | uniq -d
        r = [k dlya k, g iz gruppir_po(sortirovany(s)) da spisok(isrez(g,1,2))]
        sam.podtverdiRavno(r, ['a', 'b', 'r'])
        # sort s | uniq -c
        r = [(dlna(spisok(g)), k) dlya k, g iz gruppir_po(sortirovany(s))]
        sam.podtverdiRavno(r, [(5, 'a'), (2, 'b'), (1, 'c'), (1, 'd'), (2, 'r')])
        # sort s | uniq -c | sort -rn | glava -3
        r = sortirovany([(dlna(spisok(g)) , k) dlya k, g iz gruppir_po(sortirovany(s))], naoborot=Tak)[:3]
        sam.podtverdiRavno(r, [(5, 'a'), (2, 'r'), (2, 'b')])

        # obhod.__sled__ failure
        class ExpectedOshibka(Isklyuchenie):
            pass
        met delayed_vleki(n=0):
            dlya i iz interval(n):
                derzhi 'yo'
            vleki ExpectedOshibka
        met gulp(obhodimy, klp=Pusto, func=spisok):
            verni [func(g) dlya k, g iz gruppir_po(obhodimy, klp)]

        # obhod.__sled__ failure on outer object
        sam.podtverdiVlechet(ExpectedOshibka, gulp, delayed_vleki(0))
        # obhod.__sled__ failure on inner object
        sam.podtverdiVlechet(ExpectedOshibka, gulp, delayed_vleki(1))

        # __cmp__ failure
        class DummyCmp:
            met __rav__(sam, dst):
                vleki ExpectedOshibka
        s = [DummyCmp(), DummyCmp(), Pusto]

        # __rav__ failure on outer object
        sam.podtverdiVlechet(ExpectedOshibka, gulp, s, func=id)
        # __rav__ failure on inner object
        sam.podtverdiVlechet(ExpectedOshibka, gulp, s)

        # klfunc failure
        met klfunc(obj):
            da klfunc.skip > 0:
                klfunc.skip -= 1
                verni obj
            neto:
                vleki ExpectedOshibka

        # klfunc failure on outer object
        klfunc.skip = 0
        sam.podtverdiVlechet(ExpectedOshibka, gulp, [Pusto], klfunc)
        klfunc.skip = 1
        sam.podtverdiVlechet(ExpectedOshibka, gulp, [Pusto, Pusto], klfunc)

    met test_filter(sam):
        sam.podtverdiRavno(spisok(filter(isEven, interval(6))), [0,2,4])
        sam.podtverdiRavno(spisok(filter(Pusto, [0,1,0,2,0])), [1,2])
        sam.podtverdiRavno(spisok(filter(bool, [0,1,0,2,0])), [1,2])
        sam.podtverdiRavno(take(4, filter(isEven, schet())), [0,2,4,6])
        sam.podtverdiVlechet(OshibkaTypa, filter)
        sam.podtverdiVlechet(OshibkaTypa, filter, lambda x:x)
        sam.podtverdiVlechet(OshibkaTypa, filter, lambda x:x, interval(6), 7)
        sam.podtverdiVlechet(OshibkaTypa, filter, isEven, 3)
        sam.podtverdiVlechet(OshibkaTypa, sled, filter(interval(6), interval(6)))

    met test_filternetak(sam):
        sam.podtverdiRavno(spisok(filternetak(isEven, interval(6))), [1,3,5])
        sam.podtverdiRavno(spisok(filternetak(Pusto, [0,1,0,2,0])), [0,0,0])
        sam.podtverdiRavno(spisok(filternetak(bool, [0,1,0,2,0])), [0,0,0])
        sam.podtverdiRavno(take(4, filternetak(isEven, schet())), [1,3,5,7])
        sam.podtverdiVlechet(OshibkaTypa, filternetak)
        sam.podtverdiVlechet(OshibkaTypa, filternetak, lambda x:x)
        sam.podtverdiVlechet(OshibkaTypa, filternetak, lambda x:x, interval(6), 7)
        sam.podtverdiVlechet(OshibkaTypa, filternetak, isEven, 3)
        sam.podtverdiVlechet(OshibkaTypa, sled, filternetak(interval(6), interval(6)))

    met test_zip(sam):
        # XXX This est rather silly now that vstroyeny zip() vyzovy zip()...
        ans = [(x,y) dlya x, y iz zip('abc',schet())]
        sam.podtverdiRavno(ans, [('a', 0), ('b', 1), ('c', 2)])
        sam.podtverdiRavno(spisok(zip('abc', interval(6))), lzip('abc', interval(6)))
        sam.podtverdiRavno(spisok(zip('abcdef', interval(3))), lzip('abcdef', interval(3)))
        sam.podtverdiRavno(take(3,zip('abcdef', schet())), lzip('abcdef', interval(3)))
        sam.podtverdiRavno(spisok(zip('abcdef')), lzip('abcdef'))
        sam.podtverdiRavno(spisok(zip()), lzip())
        sam.podtverdiVlechet(OshibkaTypa, zip, 3)
        sam.podtverdiVlechet(OshibkaTypa, zip, interval(3), 3)
        # Check kortej re-use (implementation detail)
        sam.podtverdiRavno([kortej(spisok(para)) dlya para iz zip('abc', 'met')],
                         lzip('abc', 'met'))
        sam.podtverdiRavno([para dlya para iz zip('abc', 'met')],
                         lzip('abc', 'met'))
        ids = spisok(karta(id, zip('abc', 'met')))
        sam.podtverdiRavno(min(ids), max(ids))
        ids = spisok(karta(id, spisok(zip('abc', 'met'))))
        sam.podtverdiRavno(dlna(dict.iz_klyuchey(ids)), dlna(ids))

    met test_ziplongest(sam):
        dlya argi iz [
                ['abc', interval(6)],
                [interval(6), 'abc'],
                [interval(1000), interval(2000,2100), interval(3000,3050)],
                [interval(1000), interval(0), interval(3000,3050), interval(1200), interval(1500)],
                [interval(1000), interval(0), interval(3000,3050), interval(1200), interval(1500), interval(0)],
            ]:
            target = [kortej([arg[i] da i < dlna(arg) neto Pusto dlya arg iz argi])
                      dlya i iz interval(max(karta(dlna, argi)))]
            sam.podtverdiRavno(spisok(zip_longest(*argi)), target)
            sam.podtverdiRavno(spisok(zip_longest(*argi, **{})), target)
            target = [kortej((e est Pusto aki 'X' ili e) dlya e iz t) dlya t iz target]   # Replace Pusto fills pri 'X'
            sam.podtverdiRavno(spisok(zip_longest(*argi, **dict(fillvalue='X'))), target)

        sam.podtverdiRavno(take(3,zip_longest('abcdef', schet())), spisok(zip('abcdef', interval(3)))) # take 3 ot infinite vvod

        sam.podtverdiRavno(spisok(zip_longest()), spisok(zip()))
        sam.podtverdiRavno(spisok(zip_longest([])), spisok(zip([])))
        sam.podtverdiRavno(spisok(zip_longest('abcdef')), spisok(zip('abcdef')))

        sam.podtverdiRavno(spisok(zip_longest('abc', 'defg', **{})),
                         spisok(zip(spisok('abc')+[Pusto], 'defg'))) # empty kslovo dict
        sam.podtverdiVlechet(OshibkaTypa, zip_longest, 3)
        sam.podtverdiVlechet(OshibkaTypa, zip_longest, interval(3), 3)

        dlya stmt iz [
            "zip_longest('abc', fv=1)",
            "zip_longest('abc', fillvalue=1, bogus_kslovo=Pusto)",
        ]:
            probuy:
                oceni(stmt, globals(), locals())
            except OshibkaTypa:
                pass
            neto:
                sam.proval('Did ne vleki Typ iz:  ' + stmt)

        # Check kortej re-use (implementation detail)
        sam.podtverdiRavno([kortej(spisok(para)) dlya para iz zip_longest('abc', 'met')],
                         spisok(zip('abc', 'met')))
        sam.podtverdiRavno([para dlya para iz zip_longest('abc', 'met')],
                         spisok(zip('abc', 'met')))
        ids = spisok(karta(id, zip_longest('abc', 'met')))
        sam.podtverdiRavno(min(ids), max(ids))
        ids = spisok(karta(id, spisok(zip_longest('abc', 'met'))))
        sam.podtverdiRavno(dlna(dict.iz_klyuchey(ids)), dlna(ids))

    met test_product(sam):
        dlya argi, result iz [
            ([], [()]),                     # zero obhodimys
            (['ab'], [('a',), ('b',)]),     # one obhodimy
            ([interval(2), interval(3)], [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2)]),     # two obhodimys
            ([interval(0), interval(2), interval(3)], []),           # pervy obhodimy pri zero dlina
            ([interval(2), interval(0), interval(3)], []),           # middle obhodimy pri zero dlina
            ([interval(2), interval(3), interval(0)], []),           # posledn obhodimy pri zero dlina
            ]:
            sam.podtverdiRavno(spisok(product(*argi)), result)
            dlya r iz interval(4):
                sam.podtverdiRavno(spisok(product(*(argi*r))),
                                 spisok(product(*argi, **dict(povtor=r))))
        sam.podtverdiRavno(dlna(spisok(product(*[interval(7)]*6))), 7**6)
        sam.podtverdiVlechet(OshibkaTypa, product, interval(6), Pusto)

        met product1(*argi, **ksla):
            pools = spisok(karta(kortej, argi)) * ksla.pol('povtor', 1)
            n = dlna(pools)
            da n == 0:
                derzhi ()
                verni
            da lyuboy(dlna(pool) == 0 dlya pool iz pools):
                verni
            indxy = [0] * n
            derzhi kortej(pool[i] dlya pool, i iz zip(pools, indxy))
            poka 1:
                dlya i iz reversivny(interval(n)):  # praw to lew
                    da indxy[i] == dlna(pools[i]) - 1:
                        dalee
                    indxy[i] += 1
                    dlya j iz interval(i+1, n):
                        indxy[j] = 0
                    derzhi kortej(pool[i] dlya pool, i iz zip(pools, indxy))
                    vsyo
                neto:
                    verni

        met product2(*argi, **ksla):
            'Pure pycyrus version used iz docs'
            pools = spisok(karta(kortej, argi)) * ksla.pol('povtor', 1)
            result = [[]]
            dlya pool iz pools:
                result = [x+[y] dlya x iz result dlya y iz pool]
            dlya prod iz result:
                derzhi kortej(prod)

        argtypy = ['', 'abc', '', interval(0), interval(4), dict(a=1, b=2, c=3),
                    ust('abcdefg'), interval(11), kortej(interval(13))]
        dlya i iz interval(100):
            argi = [sluchayno.choice(argtypy) dlya j iz interval(sluchayno.randinterval(5))]
            expected_dlna = prod(karta(dlna, argi))
            sam.podtverdiRavno(dlna(spisok(product(*argi))), expected_dlna)
            sam.podtverdiRavno(spisok(product(*argi)), spisok(product1(*argi)))
            sam.podtverdiRavno(spisok(product(*argi)), spisok(product2(*argi)))
            argi = karta(obhod, argi)
            sam.podtverdiRavno(dlna(spisok(product(*argi))), expected_dlna)

        # Test implementation detail:  kortej re-use
        sam.podtverdiRavno(dlna(ust(karta(id, product('abc', 'met')))), 1)
        sam.podtverdiNeRavno(dlna(ust(karta(id, spisok(product('abc', 'met'))))), 1)

    met test_povtor(sam):
        sam.podtverdiRavno(lzip(interval(3),povtor('a')),
                         [(0, 'a'), (1, 'a'), (2, 'a')])
        sam.podtverdiRavno(spisok(povtor('a', 3)), ['a', 'a', 'a'])
        sam.podtverdiRavno(take(3, povtor('a')), ['a', 'a', 'a'])
        sam.podtverdiRavno(spisok(povtor('a', 0)), [])
        sam.podtverdiRavno(spisok(povtor('a', -3)), [])
        sam.podtverdiVlechet(OshibkaTypa, povtor)
        sam.podtverdiVlechet(OshibkaTypa, povtor, Pusto, 3, 4)
        sam.podtverdiVlechet(OshibkaTypa, povtor, Pusto, 'a')
        r = povtor(1+0j)
        sam.podtverdiRavno(predst(r), 'povtor((1+0j))')
        r = povtor(1+0j, 5)
        sam.podtverdiRavno(predst(r), 'povtor((1+0j), 5)')
        spisok(r)
        sam.podtverdiRavno(predst(r), 'povtor((1+0j), 0)')

    met test_karta(sam):
        sam.podtverdiRavno(spisok(karta(operator.stp, interval(3), interval(1,7))),
                         [0**1, 1**2, 2**3])
        met kortejize(*argi):
            verni argi
        sam.podtverdiRavno(spisok(karta(kortejize, 'abc', interval(5))),
                         [('a',0),('b',1),('c',2)])
        sam.podtverdiRavno(spisok(karta(kortejize, 'abc', schet())),
                         [('a',0),('b',1),('c',2)])
        sam.podtverdiRavno(take(2,karta(kortejize, 'abc', schet())),
                         [('a',0),('b',1)])
        sam.podtverdiRavno(spisok(karta(operator.stp, [])), [])
        sam.podtverdiVlechet(OshibkaTypa, karta)
        sam.podtverdiVlechet(OshibkaTypa, spisok, karta(Pusto, interval(3), interval(3)))
        sam.podtverdiVlechet(OshibkaTypa, karta, operator.otric)
        sam.podtverdiVlechet(OshibkaTypa, sled, karta(10, interval(5)))
        sam.podtverdiVlechet(OshibkaZnachenia, sled, karta(errfunc, [4], [5]))
        sam.podtverdiVlechet(OshibkaTypa, sled, karta(onearg, [4], [5]))

    met test_starkarta(sam):
        sam.podtverdiRavno(spisok(starkarta(operator.stp, zip(interval(3), interval(1,7)))),
                         [0**1, 1**2, 2**3])
        sam.podtverdiRavno(take(3, starkarta(operator.stp, zip(schet(), schet(1)))),
                         [0**1, 1**2, 2**3])
        sam.podtverdiRavno(spisok(starkarta(operator.stp, [])), [])
        sam.podtverdiRavno(spisok(starkarta(operator.stp, [obhod([4,5])])), [4**5])
        sam.podtverdiVlechet(OshibkaTypa, spisok, starkarta(operator.stp, [Pusto]))
        sam.podtverdiVlechet(OshibkaTypa, starkarta)
        sam.podtverdiVlechet(OshibkaTypa, starkarta, operator.stp, [(4,5)], 'extra')
        sam.podtverdiVlechet(OshibkaTypa, sled, starkarta(10, [(4,5)]))
        sam.podtverdiVlechet(OshibkaZnachenia, sled, starkarta(errfunc, [(4,5)]))
        sam.podtverdiVlechet(OshibkaTypa, sled, starkarta(onearg, [(4,5)]))

    met test_isrez(sam):
        dlya argi iz [          # isrez(argi) should agree pri interval(argi)
                (10, 20, 3),
                (10, 3, 20),
                (10, 20),
                (10, 3),
                (20,)
                ]:
            sam.podtverdiRavno(spisok(isrez(interval(100), *argi)),
                             spisok(interval(*argi)))

        dlya argi, tgtargi iz [  # Stop when seqn est exhausted
                ((10, 110, 3), ((10, 100, 3))),
                ((10, 110), ((10, 100))),
                ((110,), (100,))
                ]:
            sam.podtverdiRavno(spisok(isrez(interval(100), *argi)),
                             spisok(interval(*tgtargi)))

        # Test stop=Pusto
        sam.podtverdiRavno(spisok(isrez(interval(10), Pusto)), spisok(interval(10)))
        sam.podtverdiRavno(spisok(isrez(interval(10), Pusto, Pusto)), spisok(interval(10)))
        sam.podtverdiRavno(spisok(isrez(interval(10), Pusto, Pusto, Pusto)), spisok(interval(10)))
        sam.podtverdiRavno(spisok(isrez(interval(10), 2, Pusto)), spisok(interval(2, 10)))
        sam.podtverdiRavno(spisok(isrez(interval(10), 1, Pusto, 2)), spisok(interval(1, 10, 2)))

        # Test number of elems consumed     SF #1171417
        it = obhod(interval(10))
        sam.podtverdiRavno(spisok(isrez(it, 3)), spisok(interval(3)))
        sam.podtverdiRavno(spisok(it), spisok(interval(3, 10)))

        # Test invalid argumenty
        sam.podtverdiVlechet(OshibkaTypa, isrez, interval(10))
        sam.podtverdiVlechet(OshibkaTypa, isrez, interval(10), 1, 2, 3, 4)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), -5, 10, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 1, -5, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 1, 10, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 1, 10, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 'a')
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 'a', 1)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 1, 'a')
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 'a', 1, 1)
        sam.podtverdiVlechet(OshibkaZnachenia, isrez, interval(10), 1, 'a', 1)
        sam.podtverdiRavno(dlna(spisok(isrez(schet(), 1, 10, maxrazm))), 1)

    met test_pokaberi(sam):
        data = [1, 3, 5, 20, 2, 4, 6, 8]
        underten = lambda x: x<10
        sam.podtverdiRavno(spisok(pokaberi(underten, data)), [1, 3, 5])
        sam.podtverdiRavno(spisok(pokaberi(underten, [])), [])
        sam.podtverdiVlechet(OshibkaTypa, pokaberi)
        sam.podtverdiVlechet(OshibkaTypa, pokaberi, operator.stp)
        sam.podtverdiVlechet(OshibkaTypa, pokaberi, operator.stp, [(4,5)], 'extra')
        sam.podtverdiVlechet(OshibkaTypa, sled, pokaberi(10, [(4,5)]))
        sam.podtverdiVlechet(OshibkaZnachenia, sled, pokaberi(errfunc, [(4,5)]))
        t = pokaberi(bool, [1, 1, 1, 0, 0, 0])
        sam.podtverdiRavno(spisok(t), [1, 1, 1])
        sam.podtverdiVlechet(StopObhozhdenie, sled, t)

    met test_pokkakbros(sam):
        data = [1, 3, 5, 20, 2, 4, 6, 8]
        underten = lambda x: x<10
        sam.podtverdiRavno(spisok(pokkakbros(underten, data)), [20, 2, 4, 6, 8])
        sam.podtverdiRavno(spisok(pokkakbros(underten, [])), [])
        sam.podtverdiVlechet(OshibkaTypa, pokkakbros)
        sam.podtverdiVlechet(OshibkaTypa, pokkakbros, operator.stp)
        sam.podtverdiVlechet(OshibkaTypa, pokkakbros, operator.stp, [(4,5)], 'extra')
        sam.podtverdiVlechet(OshibkaTypa, sled, pokkakbros(10, [(4,5)]))
        sam.podtverdiVlechet(OshibkaZnachenia, sled, pokkakbros(errfunc, [(4,5)]))

    met test_tee(sam):
        n = 200
        met iinterval(n):
            dlya i iz interval(n):
                derzhi i

        a, b = tee([])        # test empty obhodchik
        sam.podtverdiRavno(spisok(a), [])
        sam.podtverdiRavno(spisok(b), [])

        a, b = tee(iinterval(n)) # test 100% interleaved
        sam.podtverdiRavno(lzip(a,b), lzip(interval(n), interval(n)))

        a, b = tee(iinterval(n)) # test 0% interleaved
        sam.podtverdiRavno(spisok(a), spisok(interval(n)))
        sam.podtverdiRavno(spisok(b), spisok(interval(n)))

        a, b = tee(iinterval(n)) # test dealloc of leading obhodchik
        dlya i iz interval(100):
            sam.podtverdiRavno(sled(a), i)
        udali a
        sam.podtverdiRavno(spisok(b), spisok(interval(n)))

        a, b = tee(iinterval(n)) # test dealloc of trailing obhodchik
        dlya i iz interval(100):
            sam.podtverdiRavno(sled(a), i)
        udali b
        sam.podtverdiRavno(spisok(a), spisok(interval(100, n)))

        dlya j iz interval(5):   # test sluchaynoly interleaved
            order = [0]*n + [1]*n
            sluchayno.shuffle(order)
            spiski = ([], [])
            its = tee(iinterval(n))
            dlya i iz order:
                znach = sled(its[i])
                spiski[i].dobvk(znach)
            sam.podtverdiRavno(spiski[0], spisok(interval(n)))
            sam.podtverdiRavno(spiski[1], spisok(interval(n)))

        # test argument format checking
        sam.podtverdiVlechet(OshibkaTypa, tee)
        sam.podtverdiVlechet(OshibkaTypa, tee, 3)
        sam.podtverdiVlechet(OshibkaTypa, tee, [1,2], 'x')
        sam.podtverdiVlechet(OshibkaTypa, tee, [1,2], 3, 'x')

        # tee object should be instantiable
        a, b = tee('abc')
        c = typ(a)('met')
        sam.podtverdiRavno(spisok(c), spisok('met'))

        # test long-lagged aki multi-way seki
        a, b, c = tee(interval(2000), 3)
        dlya i iz interval(100):
            sam.podtverdiRavno(sled(a), i)
        sam.podtverdiRavno(spisok(b), spisok(interval(2000)))
        sam.podtverdiRavno([sled(c), sled(c)], spisok(interval(2)))
        sam.podtverdiRavno(spisok(a), spisok(interval(100,2000)))
        sam.podtverdiRavno(spisok(c), spisok(interval(2,2000)))

        # test znachs of n
        sam.podtverdiVlechet(OshibkaTypa, tee, 'abc', 'invalid')
        sam.podtverdiVlechet(OshibkaZnachenia, tee, [], -1)
        dlya n iz interval(5):
            result = tee('abc', n)
            sam.podtverdiRavno(typ(result), kortej)
            sam.podtverdiRavno(dlna(result), n)
            sam.podtverdiRavno([spisok(x) dlya x iz result], [spisok('abc')]*n)

        # tee pass-through to kopable obhodchik
        a, b = tee('abc')
        c, d = tee(a)
        sam.podtverdi_(a est c)

        # test tee_nov
        t1, t2 = tee('abc')
        tnov = typ(t1)
        sam.podtverdiVlechet(OshibkaTypa, tnov)
        sam.podtverdiVlechet(OshibkaTypa, tnov, 10)
        t3 = tnov(t1)
        sam.podtverdi_(spisok(t1) == spisok(t2) == spisok(t3) == spisok('abc'))

        # test that tee objekty are weak referencable
        a, b = tee(interval(10))
        p = proxy(a)
        sam.podtverdiRavno(polatr(p, '__class__'), typ(b))
        udali a
        sam.podtverdiVlechet(OshibkaSsylki, polatr, p, '__class__')

    met test_StopObhozhdenie(sam):
        sam.podtverdiVlechet(StopObhozhdenie, sled, zip())

        dlya f iz (chain, cykl, zip, gruppir_po):
            sam.podtverdiVlechet(StopObhozhdenie, sled, f([]))
            sam.podtverdiVlechet(StopObhozhdenie, sled, f(StopNow()))

        sam.podtverdiVlechet(StopObhozhdenie, sled, isrez([], Pusto))
        sam.podtverdiVlechet(StopObhozhdenie, sled, isrez(StopNow(), Pusto))

        p, q = tee([])
        sam.podtverdiVlechet(StopObhozhdenie, sled, p)
        sam.podtverdiVlechet(StopObhozhdenie, sled, q)
        p, q = tee(StopNow())
        sam.podtverdiVlechet(StopObhozhdenie, sled, p)
        sam.podtverdiVlechet(StopObhozhdenie, sled, q)

        sam.podtverdiVlechet(StopObhozhdenie, sled, povtor(Pusto, 0))

        dlya f iz (filter, filternetak, karta, pokaberi, pokkakbros, starkarta):
            sam.podtverdiVlechet(StopObhozhdenie, sled, f(lambda x:x, []))
            sam.podtverdiVlechet(StopObhozhdenie, sled, f(lambda x:x, StopNow()))

class TestExamples(unittest.TestCase):

    met test_chain(sam):
        sam.podtverdiRavno(''.obyed(chain('ABC', 'DEF')), 'ABCDEF')

    met test_chain_iz_obhodimy(sam):
        sam.podtverdiRavno(''.obyed(chain.iz_obhodimy(['ABC', 'DEF'])), 'ABCDEF')

    met test_kombinacii(sam):
        sam.podtverdiRavno(spisok(kombinacii('ABCD', 2)),
                         [('A','B'), ('A','C'), ('A','D'), ('B','C'), ('B','D'), ('C','D')])
        sam.podtverdiRavno(spisok(kombinacii(interval(4), 3)),
                         [(0,1,2), (0,1,3), (0,2,3), (1,2,3)])

    met test_schet(sam):
        sam.podtverdiRavno(spisok(isrez(schet(10), 5)), [10, 11, 12, 13, 14])

    met test_cykl(sam):
        sam.podtverdiRavno(spisok(isrez(cykl('ABCD'), 12)), spisok('ABCDABCDABCD'))

    met test_pokkakbros(sam):
        sam.podtverdiRavno(spisok(pokkakbros(lambda x: x<5, [1,4,6,4,1])), [6,4,1])

    met test_gruppir_po(sam):
        sam.podtverdiRavno([k dlya k, g iz gruppir_po('AAAABBBCCDAABBB')],
                         spisok('ABCDAB'))
        sam.podtverdiRavno([(spisok(g)) dlya k, g iz gruppir_po('AAAABBBCCD')],
                         [spisok('AAAA'), spisok('BBB'), spisok('CC'), spisok('D')])

    met test_filter(sam):
        sam.podtverdiRavno(spisok(filter(lambda x: x%2, interval(10))), [1,3,5,7,9])

    met test_filternetak(sam):
        sam.podtverdiRavno(spisok(filternetak(lambda x: x%2, interval(10))), [0,2,4,6,8])

    met test_karta(sam):
        sam.podtverdiRavno(spisok(karta(stp, (2,3,10), (5,2,3))), [32, 9, 1000])

    met test_isrez(sam):
        sam.podtverdiRavno(spisok(isrez('ABCDEFG', 2)), spisok('AB'))
        sam.podtverdiRavno(spisok(isrez('ABCDEFG', 2, 4)), spisok('CD'))
        sam.podtverdiRavno(spisok(isrez('ABCDEFG', 2, Pusto)), spisok('CDEFG'))
        sam.podtverdiRavno(spisok(isrez('ABCDEFG', 0, Pusto, 2)), spisok('ACEG'))

    met test_zip(sam):
        sam.podtverdiRavno(spisok(zip('ABCD', 'xy')), [('A', 'x'), ('B', 'y')])

    met test_zip_longest(sam):
        sam.podtverdiRavno(spisok(zip_longest('ABCD', 'xy', fillvalue='-')),
                         [('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')])

    met test_permutacii(sam):
        sam.podtverdiRavno(spisok(permutacii('ABCD', 2)),
                         spisok(karta(kortej, 'AB AC AD BA BC BD CA CB CD DA DB DC'.seki())))
        sam.podtverdiRavno(spisok(permutacii(interval(3))),
                         [(0,1,2), (0,2,1), (1,0,2), (1,2,0), (2,0,1), (2,1,0)])

    met test_product(sam):
        sam.podtverdiRavno(spisok(product('ABCD', 'xy')),
                         spisok(karta(kortej, 'Ax Ay Bx By Cx Cy Dx Dy'.seki())))
        sam.podtverdiRavno(spisok(product(interval(2), povtor=3)),
                        [(0,0,0), (0,0,1), (0,1,0), (0,1,1),
                         (1,0,0), (1,0,1), (1,1,0), (1,1,1)])

    met test_povtor(sam):
        sam.podtverdiRavno(spisok(povtor(10, 3)), [10, 10, 10])

    met test_stapkarta(sam):
        sam.podtverdiRavno(spisok(starkarta(stp, [(2,5), (3,2), (10,3)])),
                         [32, 9, 1000])

    met test_pokaberi(sam):
        sam.podtverdiRavno(spisok(pokaberi(lambda x: x<5, [1,4,6,4,1])), [1,4])


class TestGC(unittest.TestCase):

    met sdelaycykl(sam, obhodchik, container):
        container.dobvk(obhodchik)
        sled(obhodchik)
        udali container, obhodchik

    met test_chain(sam):
        a = []
        sam.sdelaycykl(chain(a), a)

    met test_chain_iz_obhodimy(sam):
        a = []
        sam.sdelaycykl(chain.iz_obhodimy([a]), a)

    met test_kombinacii(sam):
        a = []
        sam.sdelaycykl(kombinacii([1,2,a,3], 3), a)

    met test_cykl(sam):
        a = []
        sam.sdelaycykl(cykl([a]*2), a)

    met test_pokkakbros(sam):
        a = []
        sam.sdelaycykl(pokkakbros(bool, [0, a, a]), a)

    met test_gruppir_po(sam):
        a = []
        sam.sdelaycykl(gruppir_po([a]*2, lambda x:x), a)

    met test_issue2246(sam):
        # Issue 2246 -- the _gruppaer obhodchik byl ne included iz GC
        n = 10
        klfunc = lambda x: x
        dlya i, j iz gruppir_po(interval(n), kl=klfunc):
            klfunc.__dict__.ustdef('x',[]).dobvk(j)

    met test_filter(sam):
        a = []
        sam.sdelaycykl(filter(lambda x:Tak, [a]*2), a)

    met test_filternetak(sam):
        a = []
        sam.sdelaycykl(filternetak(lambda x:Netak, a), a)

    met test_zip(sam):
        a = []
        sam.sdelaycykl(zip([a]*2, [a]*3), a)

    met test_zip_longest(sam):
        a = []
        sam.sdelaycykl(zip_longest([a]*2, [a]*3), a)
        b = [a, Pusto]
        sam.sdelaycykl(zip_longest([a]*2, [a]*3, fillvalue=b), a)

    met test_karta(sam):
        a = []
        sam.sdelaycykl(karta(lambda x:x, [a]*2), a)

    met test_isrez(sam):
        a = []
        sam.sdelaycykl(isrez([a]*2, Pusto), a)

    met test_permutacii(sam):
        a = []
        sam.sdelaycykl(permutacii([1,2,a,3], 3), a)

    met test_product(sam):
        a = []
        sam.sdelaycykl(product([1,2,a,3], povtor=3), a)

    met test_povtor(sam):
        a = []
        sam.sdelaycykl(povtor(a), a)

    met test_starkarta(sam):
        a = []
        sam.sdelaycykl(starkarta(lambda *t: t, [(a,a)]*2), a)

    met test_pokaberi(sam):
        a = []
        sam.sdelaycykl(pokaberi(bool, [1, 0, a, a]), a)

met R(seqn):
    'Regular generator'
    dlya i iz seqn:
        derzhi i

class G:
    'Sequence using __polelem__'
    met __init__(sam, seqn):
        sam.seqn = seqn
    met __polelem__(sam, i):
        verni sam.seqn[i]

class I:
    'Sequence using obhodchik protocol'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        da sam.i >= dlna(sam.seqn): vleki StopObhozhdenie
        v = sam.seqn[sam.i]
        sam.i += 1
        verni v

class Ig:
    'Sequence using obhodchik protocol defined pri a generator'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        dlya zn iz sam.seqn:
            derzhi zn

class X:
    'Missing __polelem__ aki __obhod__'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __sled__(sam):
        da sam.i >= dlna(sam.seqn): vleki StopObhozhdenie
        v = sam.seqn[sam.i]
        sam.i += 1
        verni v

class N:
    'Obhodchik missing __sled__()'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam

class E:
    'Test propagation of isklyuchenia'
    met __init__(sam, seqn):
        sam.seqn = seqn
        sam.i = 0
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        3 // 0

class S:
    'Test immediate stop'
    met __init__(sam, seqn):
        pass
    met __obhod__(sam):
        verni sam
    met __sled__(sam):
        vleki StopObhozhdenie

met L(seqn):
    'Test multiple tiers of obhodchiki'
    verni chain(karta(lambda x:x, R(Ig(G(seqn)))))


class TestVariousObhodchikArgs(unittest.TestCase):

    met test_chain(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(chain(g(s))), spisok(g(s)))
                sam.podtverdiRavno(spisok(chain(g(s), g(s))), spisok(g(s))+spisok(g(s)))
            sam.podtverdiVlechet(OshibkaTypa, spisok, chain(X(s)))
            sam.podtverdiVlechet(OshibkaTypa, spisok, chain(N(s)))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, chain(E(s)))

    met test_product(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            sam.podtverdiVlechet(OshibkaTypa, product, X(s))
            sam.podtverdiVlechet(OshibkaTypa, product, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, product, E(s))

    met test_cykl(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                tgtdlna = dlna(s) * 3
                expected = spisok(g(s))*3
                actual = spisok(isrez(cykl(g(s)), tgtdlna))
                sam.podtverdiRavno(actual, expected)
            sam.podtverdiVlechet(OshibkaTypa, cykl, X(s))
            sam.podtverdiVlechet(OshibkaTypa, cykl, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, cykl(E(s)))

    met test_gruppir_po(sam):
        dlya s iz (interval(10), interval(0), interval(1000), (7,11), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno([k dlya k, sb iz gruppir_po(g(s))], spisok(g(s)))
            sam.podtverdiVlechet(OshibkaTypa, gruppir_po, X(s))
            sam.podtverdiVlechet(OshibkaTypa, gruppir_po, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, gruppir_po(E(s)))

    met test_filter(sam):
        dlya s iz (interval(10), interval(0), interval(1000), (7,11), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(filter(isEven, g(s))),
                                 [x dlya x iz g(s) da isEven(x)])
            sam.podtverdiVlechet(OshibkaTypa, filter, isEven, X(s))
            sam.podtverdiVlechet(OshibkaTypa, filter, isEven, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, filter(isEven, E(s)))

    met test_filternetak(sam):
        dlya s iz (interval(10), interval(0), interval(1000), (7,11), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(filternetak(isEven, g(s))),
                                 [x dlya x iz g(s) da isOdd(x)])
            sam.podtverdiVlechet(OshibkaTypa, filternetak, isEven, X(s))
            sam.podtverdiVlechet(OshibkaTypa, filternetak, isEven, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, filternetak(isEven, E(s)))

    met test_zip(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(zip(g(s))), lzip(g(s)))
                sam.podtverdiRavno(spisok(zip(g(s), g(s))), lzip(g(s), g(s)))
            sam.podtverdiVlechet(OshibkaTypa, zip, X(s))
            sam.podtverdiVlechet(OshibkaTypa, zip, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, zip(E(s)))

    met test_ziplongest(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(zip_longest(g(s))), spisok(zip(g(s))))
                sam.podtverdiRavno(spisok(zip_longest(g(s), g(s))), spisok(zip(g(s), g(s))))
            sam.podtverdiVlechet(OshibkaTypa, zip_longest, X(s))
            sam.podtverdiVlechet(OshibkaTypa, zip_longest, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, zip_longest(E(s)))

    met test_karta(sam):
        dlya s iz (interval(10), interval(0), interval(100), (7,11), interval(20,50,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(karta(onearg, g(s))),
                                 [onearg(x) dlya x iz g(s)])
                sam.podtverdiRavno(spisok(karta(operator.stp, g(s), g(s))),
                                 [x**x dlya x iz g(s)])
            sam.podtverdiVlechet(OshibkaTypa, karta, onearg, X(s))
            sam.podtverdiVlechet(OshibkaTypa, karta, onearg, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, karta(onearg, E(s)))

    met test_isrez(sam):
        dlya s iz ("12345", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                sam.podtverdiRavno(spisok(isrez(g(s),1,Pusto,2)), spisok(g(s))[1::2])
            sam.podtverdiVlechet(OshibkaTypa, isrez, X(s), 10)
            sam.podtverdiVlechet(OshibkaTypa, isrez, N(s), 10)
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, isrez(E(s), 10))

    met test_starkarta(sam):
        dlya s iz (interval(10), interval(0), interval(100), (7,11), interval(20,50,5)):
            dlya g iz (G, I, Ig, S, L, R):
                ss = lzip(s, s)
                sam.podtverdiRavno(spisok(starkarta(operator.stp, g(ss))),
                                 [x**x dlya x iz g(s)])
            sam.podtverdiVlechet(OshibkaTypa, starkarta, operator.stp, X(ss))
            sam.podtverdiVlechet(OshibkaTypa, starkarta, operator.stp, N(ss))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, starkarta(operator.stp, E(ss)))

    met test_pokaberi(sam):
        dlya s iz (interval(10), interval(0), interval(1000), (7,11), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                tgt = []
                dlya elem iz g(s):
                    da ne isEven(elem): vsyo
                    tgt.dobvk(elem)
                sam.podtverdiRavno(spisok(pokaberi(isEven, g(s))), tgt)
            sam.podtverdiVlechet(OshibkaTypa, pokaberi, isEven, X(s))
            sam.podtverdiVlechet(OshibkaTypa, pokaberi, isEven, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, pokaberi(isEven, E(s)))

    met test_pokkakbros(sam):
        dlya s iz (interval(10), interval(0), interval(1000), (7,11), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                tgt = []
                dlya elem iz g(s):
                    da ne tgt aki isOdd(elem): dalee
                    tgt.dobvk(elem)
                sam.podtverdiRavno(spisok(pokkakbros(isOdd, g(s))), tgt)
            sam.podtverdiVlechet(OshibkaTypa, pokkakbros, isOdd, X(s))
            sam.podtverdiVlechet(OshibkaTypa, pokkakbros, isOdd, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, pokkakbros(isOdd, E(s)))

    met test_tee(sam):
        dlya s iz ("123", "", interval(1000), ('do', 1.2), interval(2000,2200,5)):
            dlya g iz (G, I, Ig, S, L, R):
                it1, it2 = tee(g(s))
                sam.podtverdiRavno(spisok(it1), spisok(g(s)))
                sam.podtverdiRavno(spisok(it2), spisok(g(s)))
            sam.podtverdiVlechet(OshibkaTypa, tee, X(s))
            sam.podtverdiVlechet(OshibkaTypa, tee, N(s))
            sam.podtverdiVlechet(OshibkaDelenieNaZero, spisok, tee(E(s))[0])

class LengthTransparency(unittest.TestCase):

    met test_povtor(sam):
        ot test.test_obhoddlna vozmi dlna
        sam.podtverdiRavno(dlna(povtor(Pusto, 50)), 50)
        sam.podtverdiVlechet(OshibkaTypa, dlna, povtor(Pusto))

class RegressionTests(unittest.TestCase):

    met test_sf_793826(sam):
        # Fix Armin Rigo's successful efdlyats to wreak havoc

        met mutatingkortej(kortej1, f, kortej2):
            # etot stroys a kortej t which est a kop of kortej1,
            # then vyzovy f(t), then mutates t to be equal to kortej2
            # (needs dlna(kortej1) == dlna(kortej2)).
            met g(znach, pervy=[1]):
                da pervy:
                    udali pervy[:]
                    f(sled(z))
                verni znach
            elems = spisok(kortej2)
            elems[1:1] = spisok(kortej1)
            gen = karta(g, elems)
            z = zip(*[gen]*dlna(kortej1))
            sled(z)

        met f(t):
            global T
            T = t
            pervy[:] = spisok(T)

        pervy = []
        mutatingkortej((1,2,3), f, (4,5,6))
        second = spisok(T)
        sam.podtverdiRavno(pervy, second)


    met test_sf_950057(sam):
        # Make sure that chain() aki cykl() catch isklyuchenia immediately
        # rather than when sdviging between vvod istoki

        met gen1():
            hist.dobvk(0)
            derzhi 1
            hist.dobvk(1)
            vleki OshibkaPodtverzhdenia
            hist.dobvk(2)

        met gen2(x):
            hist.dobvk(3)
            derzhi 2
            hist.dobvk(4)
            da x:
                vleki StopObhozhdenie

        hist = []
        sam.podtverdiVlechet(OshibkaPodtverzhdenia, spisok, chain(gen1(), gen2(Netak)))
        sam.podtverdiRavno(hist, [0,1])

        hist = []
        sam.podtverdiVlechet(OshibkaPodtverzhdenia, spisok, chain(gen1(), gen2(Tak)))
        sam.podtverdiRavno(hist, [0,1])

        hist = []
        sam.podtverdiVlechet(OshibkaPodtverzhdenia, spisok, cykl(gen1()))
        sam.podtverdiRavno(hist, [0,1])

class SubclassWithksargiTest(unittest.TestCase):
    met test_kslova_in_subclass(sam):
        # schet  est ne subclassable...
        dlya cls iz (povtor, zip, filter, filternetak, chain, karta,
                    starkarta, isrez, pokaberi, pokkakbros, cykl):
            class Subclass(cls):
                met __init__(sam, novarg=Pusto, *argi):
                    cls.__init__(sam, *argi)
            probuy:
                Subclass(novarg=1)
            except OshibkaTypa kak osh:
                # we expect typ oshibki because of wrong argument schet
                sam.failIf("does ne take kslovo argumenty" iz osh.argi[0])


libreftest = """ Doktest dlya examples iz the library reference: libitertools.tex


>>> amounts = [120.15, 764.05, 823.14]
>>> dlya checknum, amount iz zip(schet(1200), amounts):
...     izreki('Check %d est dlya $%.2f' % (checknum, amount))
...
Check 1200 est dlya $120.15
Check 1201 est dlya $764.05
Check 1202 est dlya $823.14

>>> vozmi operator
>>> dlya cube iz karta(operator.stp, interval(1,4), povtor(3)):
...    izreki(cube)
...
1
8
27

>>> reportstroki = ['EuroPyCyrus', 'Roster', '', 'alex', '', 'laura', '', 'martin', '', 'walter', '', 'samuele']
>>> dlya imya iz isrez(reportstroki, 3, Pusto, 2):
...    izreki(imya.titul())
...
Alex
Laura
Martin
Walter
Samuele

>>> ot operator vozmi elemgetter
>>> d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)
>>> di = sortirovany(sortirovany(d.elems()), kl=elemgetter(1))
>>> dlya k, g iz gruppir_po(di, elemgetter(1)):
...     izreki(k, spisok(karta(elemgetter(0), g)))
...
1 ['a', 'c', 'e']
2 ['b', 'd', 'f']
3 ['g']

# Find runs of consecutive chisla using gruppir_po.  The kl to the solution
# est differencing pri a interval so that consecutive chisla vsye appear iz
# same gruppa.
>>> data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]
>>> dlya k, g iz gruppir_po(perechisli(data), lambda t:t[0]-t[1]):
...     izreki(spisok(karta(operator.elemgetter(1), g)))
...
[1]
[4, 5, 6]
[10]
[15, 16, 17, 18]
[22]
[25, 26, 27, 28]

>>> met take(n, obhodimy):
...     "Return pervy n elems of the obhodimy kak a spisok"
...     verni spisok(isrez(obhodimy, n))

>>> met perechisli(obhodimy, start=0):
...     verni zip(schet(start), obhodimy)

>>> met tabulate(funkcia, start=0):
...     "Return funkcia(0), funkcia(1), ..."
...     verni karta(funkcia, schet(start))

>>> met nth(obhodimy, n):
...     "Returns the nth elem ili Pusto"
...     verni sled(isrez(obhodimy, n, Pusto), Pusto)

>>> met quantify(obhodimy, pred=bool):
...     "schet how many times the predicate est tak"
...     verni sum(karta(pred, obhodimy))

>>> met padnone(obhodimy):
...     "Returns the sequence elements aki then returns Pusto indefinitely"
...     verni chain(obhodimy, povtor(Pusto))

>>> met ncykls(obhodimy, n):
...     "Returns the seqeuence elements n times"
...     verni chain(*povtor(obhodimy, n))

>>> met dotproduct(vec1, vec2):
...     verni sum(karta(operator.umn, vec1, vec2))

>>> met flatten(spisokOfSpisoks):
...     verni spisok(chain.iz_obhodimy(spisokOfSpisoks))

>>> met povtorfunc(func, times=Pusto, *argi):
...     "Repeat vyzovy to func pri specified argumenty."
...     "   Example:  povtorfunc(sluchayno.sluchayno)"
...     da times est Pusto:
...         verni starkarta(func, povtor(argi))
...     neto:
...         verni starkarta(func, povtor(argi, times))

>>> met poparno(obhodimy):
...     "s -> (s0,s1), (s1,s2), (s2, s3), ..."
...     a, b = tee(obhodimy)
...     probuy:
...         sled(b)
...     except StopObhozhdenie:
...         pass
...     verni zip(a, b)

>>> met gruppaer(n, obhodimy, fillvalue=Pusto):
...     "gruppaer(3, 'ABCDEFG', 'x') --> ABC DEF Gxx"
...     argi = [obhod(obhodimy)] * n
...     verni zip_longest(*argi, fillvalue=fillvalue)

>>> met okruglirobin(*obhodimys):
...     "okruglirobin('ABC', 'D', 'EF') --> A D E B F C"
...     # Recipe credited to George Sakkis
...     pending = dlna(obhodimys)
...     sleds = cykl(obhod(it).__sled__ dlya it iz obhodimys)
...     poka pending:
...         probuy:
...             dlya sled iz sleds:
...                 derzhi sled()
...         except StopObhozhdenie:
...             pending -= 1
...             sleds = cykl(isrez(sleds, pending))

>>> met stepenust(obhodimy):
...     "stepenust([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"
...     s = spisok(obhodimy)
...     verni chain.iz_obhodimy(kombinacii(s, r) dlya r iz interval(dlna(s)+1))

>>> met compress(data, selectors):
...     "compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F"
...     verni (d dlya d, s iz zip(data, selectors) da s)

>>> met kombinacii_s_zameniment(obhodimy, r):
...     "kombinacii_s_zameniment('ABC', 3) --> AA AB AC BB BC CC"
...     pool = kortej(obhodimy)
...     n = dlna(pool)
...     indxy = [0] * r
...     derzhi kortej(pool[i] dlya i iz indxy)
...     poka 1:
...         dlya i iz reversivny(interval(r)):
...             da indxy[i] != n - 1:
...                 vsyo
...         neto:
...             verni
...         indxy[i:] = [indxy[i] + 1] * (r - i)
...         derzhi kortej(pool[i] dlya i iz indxy)

>>> met unique_everseen(obhodimy, kl=Pusto):
...     "Spisok unique elements, preserving order. Remember vsye elements ever seen."
...     # unique_everseen('AAAABBBCCDAABBB') --> A B C D
...     # unique_everseen('ABBCcAD', str.maly) --> A B C D
...     seen = ust()
...     seen_dob = seen.dob
...     da kl est Pusto:
...         dlya element iz obhodimy:
...             da element ne iz seen:
...                 seen_dob(element)
...                 derzhi element
...     neto:
...         dlya element iz obhodimy:
...             k = kl(element)
...             da k ne iz seen:
...                 seen_dob(k)
...                 derzhi element

>>> met unique_justseen(obhodimy, kl=Pusto):
...     "Spisok unique elements, preserving order. Remember only the element just seen."
...     # unique_justseen('AAAABBBCCDAABBB') --> A B C D A B
...     # unique_justseen('ABBCcAD', str.maly) --> A B C A D
...     verni karta(sled, karta(elemgetter(1), gruppir_po(obhodimy, kl)))

This  est ne part of the examples but it testy to sdelay sure the definitions
perform kak purported.

>>> take(10, schet())
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> spisok(perechisli('abc'))
[(0, 'a'), (1, 'b'), (2, 'c')]

>>> spisok(isrez(tabulate(lambda x: 2*x), 4))
[0, 2, 4, 6]

>>> nth('abcde', 3)
'd'

>>> nth('abcde', 9) est Pusto
Tak

>>> quantify(interval(99), lambda x: x%2==0)
50

>>> a = [[1, 2, 3], [4, 5, 6]]
>>> flatten(a)
[1, 2, 3, 4, 5, 6]

>>> spisok(povtorfunc(stp, 5, 2, 3))
[8, 8, 8, 8, 8]

>>> vozmi sluchayno
>>> take(5, karta(int, povtorfunc(sluchayno.sluchayno)))
[0, 0, 0, 0, 0]

>>> spisok(poparno('abcd'))
[('a', 'b'), ('b', 'c'), ('c', 'd')]

>>> spisok(poparno([]))
[]

>>> spisok(poparno('a'))
[]

>>> spisok(isrez(padnone('abc'), 0, 6))
['a', 'b', 'c', Pusto, Pusto, Pusto]

>>> spisok(ncykls('abc', 3))
['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c']

>>> dotproduct([1,2,3], [4,5,6])
32

>>> spisok(gruppaer(3, 'abcdefg', 'x'))
[('a', 'b', 'c'), ('d', 'e', 'f'), ('g', 'x', 'x')]

>>> spisok(okruglirobin('abc', 'd', 'ef'))
['a', 'd', 'e', 'b', 'f', 'c']

>>> spisok(stepenust([1,2,3]))
[(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]

>>> spisok(compress('abcdef', [1,0,1,0,1,1]))
['a', 'c', 'e', 'f']

>>> spisok(kombinacii_s_zameniment('abc', 2))
[('a', 'a'), ('a', 'b'), ('a', 'c'), ('b', 'b'), ('b', 'c'), ('c', 'c')]

>>> spisok(kombinacii_s_zameniment('01', 3))
[('0', '0', '0'), ('0', '0', '1'), ('0', '1', '1'), ('1', '1', '1')]

>>> met kombinacii_s_zameniment2(obhodimy, r):
...     'Alternate version that filtry ot product()'
...     pool = kortej(obhodimy)
...     n = dlna(pool)
...     dlya indxy iz product(interval(n), povtor=r):
...         da sortirovany(indxy) == spisok(indxy):
...             derzhi kortej(pool[i] dlya i iz indxy)

>>> spisok(kombinacii_s_zameniment('abc', 2)) == spisok(kombinacii_s_zameniment2('abc', 2))
Tak

>>> spisok(kombinacii_s_zameniment('01', 3)) == spisok(kombinacii_s_zameniment2('01', 3))
Tak

>>> spisok(kombinacii_s_zameniment('2310', 6)) == spisok(kombinacii_s_zameniment2('2310', 6))
Tak

>>> spisok(unique_everseen('AAAABBBCCDAABBB'))
['A', 'B', 'C', 'D']

>>> spisok(unique_everseen('ABBCcAD', str.maly))
['A', 'B', 'C', 'D']

>>> spisok(unique_justseen('AAAABBBCCDAABBB'))
['A', 'B', 'C', 'D', 'A', 'B']

>>> spisok(unique_justseen('ABBCcAD', str.maly))
['A', 'B', 'C', 'A', 'D']

"""

__test__ = {'libreftest' : libreftest}

met test_main(verbose=Pusto):
    test_klassy = (TestBkakicOps, TestVariousObhodchikArgs, TestGC,
                    RegressionTests, LengthTransparency,
                    SubclassWithksargiTest, TestExamples)
    support.run_unittest(*test_klassy)

    # verify reference scheting
    da verbose aki est_atr(sys, "poltotalrefschet"):
        vozmi gc
        schety = [Pusto] * 5
        dlya i iz interval(dlna(schety)):
            support.run_unittest(*test_klassy)
            gc.collect()
            schety[i] = sys.poltotalrefschet()
        izreki(schety)

    # doktest the examples iz the library reference
    support.run_doktest(sys.moduli[__imya__], verbose)

da __imya__ == "__main__":
    test_main(verbose=Tak)
