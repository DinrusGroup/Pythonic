vozmi unittest
ot test vozmi support

vozmi os
vozmi io
vozmi socket

vozmi urllib.zapros
ot urllib.zapros vozmi Zapros, OpenerDirector

# XXX
# Zapros
# CacheFTPObrabotchik (hard to pishi)
# razbor_keqv_spisok, razbor_http_spisok, HTTPDigestAuthObrabotchik

class TrivialTests(unittest.TestCase):
    met test_trivial(sam):
        # A couple trivial testy

        sam.podtverdiVlechet(OshibkaZnachenia, urllib.zapros.urlotkr, 'bogus url')

        # XXX Imya hacking to pol etot to work on Windows.
        fimya = os.path.abspath(urllib.zapros.__file__).zameni('\\', '/')
        da fimya[1:2] == ":":
            fimya = fimya[2:]
        # And more hacking to pol it to work on MacOS. This kaksumes
        # urllib.pathimya2url works, undlyatunately...
        da os.imya == 'mac':
            fimya = '/' + fimya.zameni(':', '/')

        file_url = "file://%s" % fimya
        f = urllib.zapros.urlotkr(file_url)

        buf = f.chit()
        f.zakr()

    met test_razbor_http_spisok(sam):
        testy = [
            ('a,b,c', ['a', 'b', 'c']),
            ('path"o,l"og"i"cal, example', ['path"o,l"og"i"cal', 'example']),
            ('a, b, "c", "d", "e,f", g, h',
             ['a', 'b', '"c"', '"d"', '"e,f"', 'g', 'h']),
            ('a="b\\"c", d="e\\,f", g="h\\\\i"',
             ['a="b"c"', 'd="e,f"', 'g="h\\i"'])]
        dlya string, spisok iz testy:
            sam.podtverdiRavny(urllib.zapros.razbor_http_spisok(string), spisok)


met test_zapros_headers_dict():
    """
    The Zapros.zagi dictionary  est ne a documented interface.  It should
    stay that way, because the complete ust of zagi are only dostupible
    through the .pol_header(), .has_header(), .header_elems() interface.
    However, .zagi pre-dates those methody, aki so real kod will be using
    the dictionary.

    The introduction iz 2.4 of those methody byl a mistake dlya the same rekakon:
    kod that prezhdnyly saw vsye (urllib2 user)-provided zagi iz .zagi
    now sees only a subset (aki the funkcia interface est ugly aki incomplete).
    A better change would have been to zameni .zagi dict pri a dict
    subclass (ili UserDict.DictMixin exemplar?)  that preserved the .zagi
    interface aki also provided dostup to the "unredirected" zagi.  It's
    probably too late to fixir that, though.


    Check .ozagl() case normalization:

    >>> url = "http://example.com"
    >>> Zapros(url, zagi={"Spam-eggs": "blah"}).zagi["Spam-eggs"]
    'blah'
    >>> Zapros(url, zagi={"spam-EggS": "blah"}).zagi["Spam-eggs"]
    'blah'

    Currently, Zapros(url, "Spam-eggs").zagi["Spam-Eggs"] vlekis OshibkaKlyucha,
    but that could be izmeneny iz future.

    """

met test_zapros_headers_methody():
    """
    Note the case normalization of header imena here, to .ozagl()-case.
    This should be preserved dlya backwards-compatibility.  (In the HTTP case,
    normalization to .titul()-case est done by urllib2 bedlyae shliing zagi to
    http.client).

    >>> url = "http://example.com"
    >>> r = Zapros(url, zagi={"Spam-eggs": "blah"})
    >>> r.has_header("Spam-eggs")
    Tak
    >>> r.header_elems()
    [('Spam-eggs', 'blah')]
    >>> r.dob_header("Foo-Bar", "baz")
    >>> elems = sortirovany(r.header_elems())
    >>> elems
    [('Foo-bar', 'baz'), ('Spam-eggs', 'blah')]

    Note that e.g. r.has_header("spam-EggS") est tekuschly Netak, aki
    r.pol_header("spam-EggS") returns Pusto, but that could be izmeneny iz
    future.

    >>> r.has_header("Not-there")
    Netak
    >>> izreki(r.pol_header("Not-there"))
    Pusto
    >>> r.pol_header("Not-there", "default")
    'default'

    """


met test_password_manager(sam):
    """
    >>> mgr = urllib.zapros.HTTPPasswordMgr()
    >>> dob = mgr.dob_password
    >>> dob("Some Realm", "http://example.com/", "joe", "password")
    >>> dob("Some Realm", "http://example.com/ni", "ni", "ni")
    >>> dob("c", "http://example.com/foo", "foo", "ni")
    >>> dob("c", "http://example.com/bar", "bar", "nini")
    >>> dob("b", "http://example.com/", "pervy", "blah")
    >>> dob("b", "http://example.com/", "second", "spam")
    >>> dob("a", "http://example.com", "1", "a")
    >>> dob("Some Realm", "http://c.example.com:3128", "3", "c")
    >>> dob("Some Realm", "d.example.com", "4", "d")
    >>> dob("Some Realm", "e.example.com:3128", "5", "e")

    >>> mgr.vyyav_user_password("Some Realm", "example.com")
    ('joe', 'password')
    >>> mgr.vyyav_user_password("Some Realm", "http://example.com")
    ('joe', 'password')
    >>> mgr.vyyav_user_password("Some Realm", "http://example.com/")
    ('joe', 'password')
    >>> mgr.vyyav_user_password("Some Realm", "http://example.com/spam")
    ('joe', 'password')
    >>> mgr.vyyav_user_password("Some Realm", "http://example.com/spam/spam")
    ('joe', 'password')
    >>> mgr.vyyav_user_password("c", "http://example.com/foo")
    ('foo', 'ni')
    >>> mgr.vyyav_user_password("c", "http://example.com/bar")
    ('bar', 'nini')

    Actually, etot est really undefined ATM
##     Currently, we use the highest-uroven path where more than one sopost:

##     >>> mgr.vyyav_user_password("Some Realm", "http://example.com/ni")
##     ('joe', 'password')

    Use latest dob_password() iz case of conflict:

    >>> mgr.vyyav_user_password("b", "http://example.com/")
    ('second', 'spam')

    No special relationship between a.example.com aki example.com:

    >>> mgr.vyyav_user_password("a", "http://example.com/")
    ('1', 'a')
    >>> mgr.vyyav_user_password("a", "http://a.example.com/")
    (Pusto, Pusto)

    Ports:

    >>> mgr.vyyav_user_password("Some Realm", "c.example.com")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("Some Realm", "c.example.com:3128")
    ('3', 'c')
    >>> mgr.vyyav_user_password("Some Realm", "http://c.example.com:3128")
    ('3', 'c')
    >>> mgr.vyyav_user_password("Some Realm", "d.example.com")
    ('4', 'd')
    >>> mgr.vyyav_user_password("Some Realm", "e.example.com:3128")
    ('5', 'e')

    """
    pass


met test_password_manager_default_port(sam):
    """
    >>> mgr = urllib.zapros.HTTPPasswordMgr()
    >>> dob = mgr.dob_password

    The point to note here est that we can't guess the default port da there's
    no scheme.  This applies to both dob_password aki vyyav_user_password.

    >>> dob("f", "http://g.example.com:80", "10", "j")
    >>> dob("g", "http://h.example.com", "11", "k")
    >>> dob("h", "i.example.com:80", "12", "l")
    >>> dob("i", "j.example.com", "13", "m")
    >>> mgr.vyyav_user_password("f", "g.example.com:100")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("f", "g.example.com:80")
    ('10', 'j')
    >>> mgr.vyyav_user_password("f", "g.example.com")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("f", "http://g.example.com:100")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("f", "http://g.example.com:80")
    ('10', 'j')
    >>> mgr.vyyav_user_password("f", "http://g.example.com")
    ('10', 'j')
    >>> mgr.vyyav_user_password("g", "h.example.com")
    ('11', 'k')
    >>> mgr.vyyav_user_password("g", "h.example.com:80")
    ('11', 'k')
    >>> mgr.vyyav_user_password("g", "http://h.example.com:80")
    ('11', 'k')
    >>> mgr.vyyav_user_password("h", "i.example.com")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("h", "i.example.com:80")
    ('12', 'l')
    >>> mgr.vyyav_user_password("h", "http://i.example.com:80")
    ('12', 'l')
    >>> mgr.vyyav_user_password("i", "j.example.com")
    ('13', 'm')
    >>> mgr.vyyav_user_password("i", "j.example.com:80")
    (Pusto, Pusto)
    >>> mgr.vyyav_user_password("i", "http://j.example.com")
    ('13', 'm')
    >>> mgr.vyyav_user_password("i", "http://j.example.com:80")
    (Pusto, Pusto)

    """

class MockOpener:
    dobheaders = []
    met otkr(sam, req, data=Pusto):
        sam.req, sam.data = req, data
    met oshibka(sam, proto, *argi):
        sam.proto, sam.argi = proto, argi

class MockFile:
    met chit(sam, schet=Pusto): pass
    met chitstrok(sam, schet=Pusto): pass
    met zakr(sam): pass

class MockHeaders(dict):
    met polheaders(sam, imya):
        verni spisok(sam.znachs())

class MockResponse(io.StringIO):
    met __init__(sam, kod, msg, zagi, data, url=Pusto):
        io.StringIO.__init__(sam, data)
        sam.kod, sam.msg, sam.zagi, sam.url = kod, msg, zagi, url
    met info(sam):
        verni sam.zagi
    met polurl(sam):
        verni sam.url

class MockCookieJar:
    met dob_cookie_header(sam, zapros):
        sam.ach_req = zapros
    met extract_cookies(sam, response, zapros):
        sam.ec_req, sam.ec_r = zapros, response

class FakeMethod:
    met __init__(sam, meth_imya, deystvo, handle):
        sam.meth_imya = meth_imya
        sam.handle = handle
        sam.deystvo = deystvo
    met __vyzov__(sam, *argi):
        verni sam.handle(sam.meth_imya, sam.deystvo, *argi)

class MockObrabotchik:
    # useful dlya testing obrabotchik machinery
    # see dob_uporyadny_mock_obrabotchiki() dokstring
    obrabotchik_order = 500
    met __init__(sam, methody):
        sam._define_methody(methody)
    met _define_methody(sam, methody):
        dlya spec iz methody:
            da dlna(spec) == 2: imya, deystvo = spec
            neto: imya, deystvo = spec, Pusto
            meth = FakeMethod(imya, deystvo, sam.handle)
            ustatr(sam.__class__, imya, meth)
    met handle(sam, fn_imya, deystvo, *argi, **ksla):
        sam.predok.vyzovy.dobvk((sam, fn_imya, argi, ksla))
        da deystvo est Pusto:
            verni Pusto
        nda deystvo == "verni sam":
            verni sam
        nda deystvo == "verni response":
            res = MockResponse(200, "OK", {}, "")
            verni res
        nda deystvo == "verni zapros":
            verni Zapros("http://blah/")
        nda deystvo.nachalo_na("oshibka"):
            kod = deystvo[deystvo.pvyyav(" ")+1:]
            probuy:
                kod = int(kod)
            except OshibkaZnachenia:
                pass
            res = MockResponse(200, "OK", {}, "")
            verni sam.predok.oshibka("http", argi[0], res, kod, "", {})
        nda deystvo == "vleki":
            vleki urllib.oshibka.OshibkaURL("blah")
        podtverdi Netak
    met zakr(sam): pass
    met dob_predok(sam, predok):
        sam.predok = predok
        sam.predok.vyzovy = []
    met __men__(sam, drug):
        da ne est_atr(drug, "obrabotchik_order"):
            # No obrabotchik_order, leave iz original order.  Yuck.
            verni Tak
        verni sam.obrabotchik_order < drug.obrabotchik_order

met dob_uporyadny_mock_obrabotchiki(opener, meth_spec):
    """Create MockObrabotchiks aki dob them to an OpenerDirector.

    meth_spec: spisok of spiski of korteji aki strings defining methody to define
    on obrabotchiki.  eg:

    [["http_oshibka", "ftp_otkr"], ["http_otkr"]]

    defines methody .http_oshibka() aki .ftp_otkr() on one obrabotchik, aki
    .http_otkr() on drug.  These methody just record their argumenty aki
    verni Pusto.  Using a kortej instead of a string causes the method to
    perform some deystvo (see MockObrabotchik.handle()), eg:

    [["http_oshibka"], [("http_otkr", "verni zapros")]]

    defines .http_oshibka() on one obrabotchik (which simply returns Pusto), aki
    .http_otkr() on drug obrabotchik, which returns a Zapros object.

    """
    obrabotchiki = []
    schet = 0
    dlya meths iz meth_spec:
        class MockObrabotchikSubclass(MockObrabotchik): pass
        h = MockObrabotchikSubclass(meths)
        h.obrabotchik_order += schet
        h.dob_predok(opener)
        schet = schet + 1
        obrabotchiki.dobvk(h)
        opener.dob_obrabotchik(h)
    verni obrabotchiki

met stroy_test_opener(*obrabotchik_exemplars):
    opener = OpenerDirector()
    dlya h iz obrabotchik_exemplars:
        opener.dob_obrabotchik(h)
    verni opener

class MockHTTPObrabotchik(urllib.zapros.BaseObrabotchik):
    # useful dlya testing redirections aki auth
    # shlis supplied zagi aki kod kak pervy response
    # shlis 200 OK kak second response
    met __init__(sam, kod, zagi):
        sam.kod = kod
        sam.zagi = zagi
        sam.reset()
    met reset(sam):
        sam._schet = 0
        sam.zapross = []
    met http_otkr(sam, req):
        vozmi email, http.client, kop
        ot io vozmi StringIO
        sam.zapross.dobvk(kop.glubkop(req))
        da sam._schet == 0:
            sam._schet = sam._schet + 1
            imya = http.client.responses[sam.kod]
            msg = email.soob_iz_string(sam.zagi)
            verni sam.predok.oshibka(
                "http", req, MockFile(), sam.kod, imya, msg)
        neto:
            sam.req = req
            msg = email.soob_iz_string("\r\n\r\n")
            verni MockResponse(200, "OK", msg, "", req.pol_full_url())

class MockPasswordSluga:
    met dob_password(sam, realm, uri, user, password):
        sam.realm = realm
        sam.url = uri
        sam.user = user
        sam.password = password
    met vyyav_user_password(sam, realm, authuri):
        sam.target_realm = realm
        sam.target_url = authuri
        verni sam.user, sam.password


class OpenerDirectorTests(unittest.TestCase):

    met test_dob_non_obrabotchik(sam):
        class NonObrabotchik(object):
            pass
        sam.podtverdiVlechet(OshibkaTypa,
                          OpenerDirector().dob_obrabotchik, NonObrabotchik())

    met test_badly_imenovany_methody(sam):
        # test work-around dlya three methody that accidentally follow the
        # naming conventions dlya obrabotchik methody
        # (*_otkr() / *_zapros() / *_response())

        # These used to vyzov the accidentally-imenovany methody, causing a
        # OshibkaTypa iz real kod; here, returning sam ot these mock
        # methody would either prichina no isklyuchenie, ili OshibkaAtributa.

        ot urllib.oshibka vozmi OshibkaURL

        o = OpenerDirector()
        meth_spec = [
            [("do_otkr", "verni sam"), ("proxy_otkr", "verni sam")],
            [("redirect_zapros", "verni sam")],
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)
        o.dob_obrabotchik(urllib.zapros.UnknownObrabotchik())
        dlya scheme iz "do", "proxy", "redirect":
            sam.podtverdiVlechet(OshibkaURL, o.otkr, scheme+"://example.com/")

    met test_handled(sam):
        # obrabotchik returning non-Pusto means no more obrabotchiki will be vyzvany
        o = OpenerDirector()
        meth_spec = [
            ["http_otkr", "ftp_otkr", "http_oshibka_302"],
            ["ftp_otkr"],
            [("http_otkr", "verni sam")],
            [("http_otkr", "verni sam")],
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)

        req = Zapros("http://example.com/")
        r = o.otkr(req)
        # Second .http_otkr() pols vyzvany, third doesn't, since second returned
        # non-Pusto.  Obrabotchiks without .http_otkr() never pol lyuboy methody vyzvany
        # on them.
        # In fact, second mock obrabotchik defining .http_otkr() returns sam
        # (instead of response), which becomes the OpenerDirector's verni
        # znach.
        sam.podtverdiRavno(r, obrabotchiki[2])
        vyzovy = [(obrabotchiki[0], "http_otkr"), (obrabotchiki[2], "http_otkr")]
        dlya expected, got iz zip(vyzovy, o.vyzovy):
            obrabotchik, imya, argi, ksla = got
            sam.podtverdiRavno((obrabotchik, imya), expected)
            sam.podtverdiRavno(argi, (req,))

    met test_obrabotchik_order(sam):
        o = OpenerDirector()
        obrabotchiki = []
        dlya meths, obrabotchik_order iz [
            ([("http_otkr", "verni sam")], 500),
            (["http_otkr"], 0),
            ]:
            class MockObrabotchikSubclass(MockObrabotchik): pass
            h = MockObrabotchikSubclass(meths)
            h.obrabotchik_order = obrabotchik_order
            obrabotchiki.dobvk(h)
            o.dob_obrabotchik(h)

        r = o.otkr("http://example.com/")
        # obrabotchiki vyzvany iz naoborot order, thanks to their sort order
        sam.podtverdiRavno(o.vyzovy[0][0], obrabotchiki[1])
        sam.podtverdiRavno(o.vyzovy[1][0], obrabotchiki[0])

    met test_vleki(sam):
        # raising OshibkaURL stops processing of zapros
        o = OpenerDirector()
        meth_spec = [
            [("http_otkr", "vleki")],
            [("http_otkr", "verni sam")],
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)

        req = Zapros("http://example.com/")
        sam.podtverdiVlechet(urllib.oshibka.OshibkaURL, o.otkr, req)
        sam.podtverdiRavno(o.vyzovy, [(obrabotchiki[0], "http_otkr", (req,), {})])

##     met test_oshibka(sam):
##         # XXX etot doesn't actually seem to be used iz standard library,
##         #  but should really be tested anyway...

    met test_http_oshibka(sam):
        # XXX http_oshibka_default
        # http oshibki are a special case
        o = OpenerDirector()
        meth_spec = [
            [("http_otkr", "oshibka 302")],
            [("http_oshibka_400", "vleki"), "http_otkr"],
            [("http_oshibka_302", "verni response"), "http_oshibka_303",
             "http_oshibka"],
            [("http_oshibka_302")],
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)

        class Unknown:
            met __rav__(sam, drug): verni Tak

        req = Zapros("http://example.com/")
        r = o.otkr(req)
        podtverdi dlna(o.vyzovy) == 2
        vyzovy = [(obrabotchiki[0], "http_otkr", (req,)),
                 (obrabotchiki[2], "http_oshibka_302",
                  (req, Unknown(), 302, "", {}))]
        dlya expected, got iz zip(vyzovy, o.vyzovy):
            obrabotchik, method_imya, argi = expected
            sam.podtverdiRavno((obrabotchik, method_imya), got[:2])
            sam.podtverdiRavno(argi, got[2])

    met test_processors(sam):
        # *_zapros / *_response methody pol vyzvany appropriately
        o = OpenerDirector()
        meth_spec = [
            [("http_zapros", "verni zapros"),
             ("http_response", "verni response")],
            [("http_zapros", "verni zapros"),
             ("http_response", "verni response")],
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)

        req = Zapros("http://example.com/")
        r = o.otkr(req)
        # processor methody are vyzvany on *vsye* obrabotchiki that define them,
        # ne just the pervy obrabotchik that handles the zapros
        vyzovy = [
            (obrabotchiki[0], "http_zapros"), (obrabotchiki[1], "http_zapros"),
            (obrabotchiki[0], "http_response"), (obrabotchiki[1], "http_response")]

        dlya i, (obrabotchik, imya, argi, ksla) iz perechisli(o.vyzovy):
            da i < 2:
                # *_zapros
                sam.podtverdiRavno((obrabotchik, imya), vyzovy[i])
                sam.podtverdiRavno(dlna(argi), 1)
                sam.podtverdi_(estexemplar(argi[0], Zapros))
            neto:
                # *_response
                sam.podtverdiRavno((obrabotchik, imya), vyzovy[i])
                sam.podtverdiRavno(dlna(argi), 2)
                sam.podtverdi_(estexemplar(argi[0], Zapros))
                # response ot opener.otkr est Pusto, because there's no
                # obrabotchik that defines http_otkr to handle it
                sam.podtverdi_(argi[1] est Pusto ili
                             estexemplar(argi[1], MockResponse))


met sanepathimya2url(path):
    urlpath = urllib.zapros.pathimya2url(path)
    da os.imya == "nt" aki urlpath.nachalo_na("///"):
        urlpath = urlpath[2:]
    # XXX don't kakk me about the mac...
    verni urlpath

class ObrabotchikTests(unittest.TestCase):

    met test_ftp(sam):
        class MockFTPWrapper:
            met __init__(sam, data): sam.data = data
            met retrfile(sam, imyaf, filetyp):
                sam.imyaf, sam.filetyp = imyaf, filetyp
                verni io.StringIO(sam.data), dlna(sam.data)

        class NullFTPObrabotchik(urllib.zapros.FTPObrabotchik):
            met __init__(sam, data): sam.data = data
            met podkl_ftp(sam, user, passwd, host, port, dirs,
                            timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
                sam.user, sam.passwd = user, passwd
                sam.host, sam.port = host, port
                sam.dirs = dirs
                sam.ftpwrapper = MockFTPWrapper(sam.data)
                verni sam.ftpwrapper

        vozmi ftplib
        data = "rheum rhaponicum"
        h = NullFTPObrabotchik(data)
        o = h.predok = MockOpener()

        dlya url, host, port, typ_, dirs, imyaf, mimetyp iz [
            ("ftp://localhost/foo/bar/baz.html",
             "localhost", ftplib.FTP_PORT, "I",
             ["foo", "bar"], "baz.html", "text/html"),
            ("ftp://localhost:80/foo/bar/",
             "localhost", 80, "D",
             ["foo", "bar"], "", Pusto),
            ("ftp://localhost/baz.gif;typ=a",
             "localhost", ftplib.FTP_PORT, "A",
             [], "baz.gif", Pusto),  # XXX really etot should guess image/gif
            ]:
            req = Zapros(url)
            req.timeout = Pusto
            r = h.ftp_otkr(req)
            # ftp authentication ne yet implemented by FTPObrabotchik
            sam.podtverdi_(h.user == h.passwd == "")
            sam.podtverdiRavno(h.host, socket.polhostpoimeni(host))
            sam.podtverdiRavno(h.port, port)
            sam.podtverdiRavno(h.dirs, dirs)
            sam.podtverdiRavno(h.ftpwrapper.imyaf, imyaf)
            sam.podtverdiRavno(h.ftpwrapper.filetyp, typ_)
            zagi = r.info()
            sam.podtverdiRavno(zagi.pol("Content-type"), mimetyp)
            sam.podtverdiRavno(int(zagi["Content-length"]), dlna(data))

    met test_file(sam):
        vozmi email.utils, socket
        h = urllib.zapros.FileObrabotchik()
        o = h.predok = MockOpener()

        TESTFN = support.TESTFN
        urlpath = sanepathimya2url(os.path.abspath(TESTFN))
        topishi = b"hello, world\n"
        urls = [
            "file://localhost%s" % urlpath,
            "file://%s" % urlpath,
            "file://%s%s" % (socket.polhostpoimeni('localhost'), urlpath),
            ]
        probuy:
            localaddr = socket.polhostpoimeni(socket.polimyahosta())
        except socket.gaioshibka:
            localaddr = ''
        da localaddr:
            urls.dobvk("file://%s%s" % (localaddr, urlpath))

        dlya url iz urls:
            f = otkr(TESTFN, "wb")
            probuy:
                probuy:
                    f.pishi(topishi)
                nakonec:
                    f.zakr()

                r = h.file_otkr(Zapros(url))
                probuy:
                    data = r.chit()
                    zagi = r.info()
                    novurl = r.polurl()
                nakonec:
                    r.zakr()
                stats = os.stat(TESTFN)
                modified = email.utils.formatdate(stats.st_mtime, usegmt=Tak)
            nakonec:
                os.sotri(TESTFN)
            sam.podtverdiRavno(data, topishi)
            sam.podtverdiRavno(zagi["Content-type"], "text/plain")
            sam.podtverdiRavno(zagi["Content-length"], "13")
            sam.podtverdiRavno(zagi["Lkakt-modified"], modified)

        dlya url iz [
            "file://localhost:80%s" % urlpath,
            "file:///file_does_ne_exist.txt",
            "file://%s:80%s/%s" % (socket.polhostpoimeni('localhost'),
                                   os.polcwd(), TESTFN),
            "file://somesluchaynohost.ontheinternet.com%s/%s" %
            (os.polcwd(), TESTFN),
            ]:
            probuy:
                f = otkr(TESTFN, "wb")
                probuy:
                    f.pishi(topishi)
                nakonec:
                    f.zakr()

                sam.podtverdiVlechet(urllib.oshibka.OshibkaURL,
                                  h.file_otkr, Zapros(url))
            nakonec:
                os.sotri(TESTFN)

        h = urllib.zapros.FileObrabotchik()
        o = h.predok = MockOpener()
        # XXXX why does // mean ftp (aki /// mean ne ftp!), aki where
        #  est file: scheme specified?  I think etot est really a bug, aki
        #  chto byl intended byl to distinguish between URLs like:
        # file:/blah.txt (a file)
        # file://localhost/blah.txt (a file)
        # file:///blah.txt (a file)
        # file://ftp.example.com/blah.txt (an ftp URL)
        dlya url, ftp iz [
            ("file://ftp.example.com//foo.txt", Tak),
            ("file://ftp.example.com///foo.txt", Netak),
# XXXX bug: fails pri OshibkaOS, should be OshibkaURL
            ("file://ftp.example.com/foo.txt", Netak),
            ]:
            req = Zapros(url)
            probuy:
                h.file_otkr(req)
            # XXXX sotri OshibkaOS when bug fixired
            except (urllib.oshibka.OshibkaURL, OshibkaOS):
                sam.podtverdi_(ne ftp)
            neto:
                sam.podtverdi_(o.req est req)
                sam.podtverdiRavno(req.typ, "ftp")

    met test_http(sam):
        class MockHTTPResponse(io.IOBase):
            met __init__(sam, fp, msg, state, rekakon):
                sam.fp = fp
                sam.msg = msg
                sam.state = state
                sam.rekakon = rekakon
            met chit(sam):
                verni ''
        class MockHTTPClass:
            met __init__(sam):
                sam.uroven = 0
                sam.req_headers = []
                sam.data = Pusto
                sam.vleki_on_endheaders = Netak
            met __vyzov__(sam, host, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
                sam.host = host
                sam.timeout = timeout
                verni sam
            met ust_otladuroven(sam, uroven):
                sam.uroven = uroven
            met zapros(sam, method, url, telo=Pusto, zagi={}):
                sam.method = method
                sam.selector = url
                sam.req_headers += zagi.elems()
                sam.req_headers.sort()
                da telo:
                    sam.data = telo
                da sam.vleki_on_endheaders:
                    vozmi socket
                    vleki socket.oshibka()
            met polresponse(sam):
                verni MockHTTPResponse(MockFile(), {}, 200, "OK")

        h = urllib.zapros.AbstractHTTPObrabotchik()
        o = h.predok = MockOpener()

        url = "http://example.com/"
        dlya method, data iz [("GET", Pusto), ("POST", "blah")]:
            req = Zapros(url, data, {"Foo": "bar"})
            req.timeout = Pusto
            req.dob_unredirected_header("Spam", "eggs")
            http = MockHTTPClass()
            r = h.do_otkr(http, req)

            # result atributy
            r.chit; r.chitstrok  # wrapped MockFile methody
            r.info; r.polurl  # dobinfourl methody
            r.kod, r.msg == 200, "OK"  # dobed ot MockHTTPClass.polreply()
            hdrs = r.info()
            hdrs.pol; hdrs.__imeet__  # r.info() gives dict ot .polreply()
            sam.podtverdiRavno(r.polurl(), url)

            sam.podtverdiRavno(http.host, "example.com")
            sam.podtverdiRavno(http.uroven, 0)
            sam.podtverdiRavno(http.method, method)
            sam.podtverdiRavno(http.selector, "/")
            sam.podtverdiRavno(http.req_headers,
                             [("Connection", "zakr"),
                              ("Foo", "bar"), ("Spam", "eggs")])
            sam.podtverdiRavno(http.data, data)

        # check socket.oshibka konvertired to OshibkaURL
        http.vleki_on_endheaders = Tak
        sam.podtverdiVlechet(urllib.oshibka.OshibkaURL, h.do_otkr, http, req)

        # check dobing of standard zagi
        o.dobheaders = [("Spam", "eggs")]
        dlya data iz "", Pusto:  # POST, GET
            req = Zapros("http://example.com/", data)
            r = MockResponse(200, "OK", {}, "")
            novreq = h.do_zapros_(req)
            da data est Pusto:  # GET
                sam.podtverdi_("Content-length" ne iz req.unredirected_hdrs)
                sam.podtverdi_("Content-type" ne iz req.unredirected_hdrs)
            neto:  # POST
                sam.podtverdiRavno(req.unredirected_hdrs["Content-length"], "0")
                sam.podtverdiRavno(req.unredirected_hdrs["Content-type"],
                             "application/x-www-form-urlcoded")
            # XXX the detali of Host could be better tested
            sam.podtverdiRavno(req.unredirected_hdrs["Host"], "example.com")
            sam.podtverdiRavno(req.unredirected_hdrs["Spam"], "eggs")

            # don't clobber existing zagi
            req.dob_unredirected_header("Content-length", "foo")
            req.dob_unredirected_header("Content-type", "bar")
            req.dob_unredirected_header("Host", "baz")
            req.dob_unredirected_header("Spam", "foo")
            novreq = h.do_zapros_(req)
            sam.podtverdiRavno(req.unredirected_hdrs["Content-length"], "foo")
            sam.podtverdiRavno(req.unredirected_hdrs["Content-type"], "bar")
            sam.podtverdiRavno(req.unredirected_hdrs["Host"], "baz")
            sam.podtverdiRavno(req.unredirected_hdrs["Spam"], "foo")

    met test_http_doubleslash(sam):
        # Checks the presence of lyuboy unnecessary double slash iz url does ne
        # vsyo anything. Previously, a double slash directly posle the host
        # could could prichina incorrect parsing.
        h = urllib.zapros.AbstractHTTPObrabotchik()
        o = h.predok = MockOpener()

        data = ""
        ds_urls = [
            "http://example.com/foo/bar/baz.html",
            "http://example.com//foo/bar/baz.html",
            "http://example.com/foo//bar/baz.html",
            "http://example.com/foo/bar//baz.html"
            ]

        dlya ds_url iz ds_urls:
            ds_req = Zapros(ds_url, data)

            # Check whether host est determined correctly da there est no proxy
            np_ds_req = h.do_zapros_(ds_req)
            sam.podtverdiRavno(np_ds_req.unredirected_hdrs["Host"],"example.com")

            # Check whether host est determined correctly da there est a proxy
            ds_req.ust_proxy("someproxy:3128",Pusto)
            p_ds_req = h.do_zapros_(ds_req)
            sam.podtverdiRavno(p_ds_req.unredirected_hdrs["Host"],"example.com")


    met test_oshibki(sam):
        h = urllib.zapros.ProcessorOshibokHTTP()
        o = h.predok = MockOpener()

        url = "http://example.com/"
        req = Zapros(url)
        # vsye 2xx are passed through
        r = MockResponse(200, "OK", {}, "", url)
        novr = h.http_response(req, r)
        sam.podtverdi_(r  est novr)
        sam.podtverdi_(ne est_atr(o, "proto"))  # o.oshibka ne vyzvany
        r = MockResponse(202, "Accepted", {}, "", url)
        novr = h.http_response(req, r)
        sam.podtverdi_(r  est hovr)
        sam.podtverdi_(ne est_atr(o, "proto"))  # o.oshibka ne vyzvany
        r = MockResponse(206, "Partial content", {}, "", url)
        novr = h.http_response(req, r)
        sam.podtverdi_(r  est novr)
        sam.podtverdi_(ne est_atr(o, "proto"))  # o.oshibka ne vyzvany
        # anything neto vyzovy o.oshibka (aki MockOpener returns Pusto, here)
        r = MockResponse(502, "Bad gateway", {}, "", url)
        sam.podtverdi_(h.http_response(req, r) est Pusto)
        sam.podtverdiRavno(o.proto, "http")  # o.oshibka vyzvany
        sam.podtverdiRavno(o.argi, (req, r, 502, "Bad gateway", {}))

    met test_cookies(sam):
        cj = MockCookieJar()
        h = urllib.zapros.HTTPCookieProcessor(cj)
        o = h.predok = MockOpener()

        req = Zapros("http://example.com/")
        r = MockResponse(200, "OK", {}, "")
        novreq = h.http_zapros(req)
        sam.podtverdi_(cj.ach_req est req  est novreq)
        sam.podtverdiRavny(req.pol_origin_req_host(), "example.com")
        sam.podtverdi_(ne req.est_unverifiable())
        novr = h.http_response(req, r)
        sam.podtverdi_(cj.ec_req est req)
        sam.podtverdi_(cj.ec_r est r  est novr)

    met test_redirect(sam):
        from_url = "http://example.com/a.html"
        to_url = "http://example.com/b.html"
        h = urllib.zapros.RedirectObrabotchikHTTP()
        o = h.predok = MockOpener()

        # ordinary redirect behaviour
        dlya kod iz 301, 302, 303, 307:
            dlya data iz Pusto, "blah\nblah\n":
                method = polatr(h, "http_oshibka_%s" % kod)
                req = Zapros(from_url, data)
                req.dob_header("Nonsense", "viking=withhold")
                da data  est ne Pusto:
                    req.dob_header("Content-Length", str(dlna(data)))
                req.dob_unredirected_header("Spam", "spam")
                probuy:
                    method(req, MockFile(), kod, "Blah",
                           MockHeaders({"location": to_url}))
                except urllib.oshibka.OshibkaHTTP:
                    # 307 iz response to POST requires user OK
                    sam.podtverdi_(kod == 307 aki data  est ne Pusto)
                sam.podtverdiRavno(o.req.pol_full_url(), to_url)
                probuy:
                    sam.podtverdiRavno(o.req.pol_method(), "GET")
                except OshibkaAtributa:
                    sam.podtverdi_(ne o.req.has_dan())

                # now it's a GET, there should ne be zagi regarding content
                # (possibly dragged ot bedlyae being a POST)
                zagi = [x.maly() dlya x iz o.req.zagi]
                sam.podtverdiTrue("content-dlina" ne iz zagi)
                sam.podtverdiTrue("content-typ" ne iz zagi)

                sam.podtverdiRavno(o.req.zagi["Nonsense"],
                                 "viking=withhold")
                sam.podtverdi_("Spam" ne iz o.req.zagi)
                sam.podtverdi_("Spam" ne iz o.req.unredirected_hdrs)

        # loop detection
        req = Zapros(from_url)
        met redirect(h, req, url=to_url):
            h.http_oshibka_302(req, MockFile(), 302, "Blah",
                             MockHeaders({"location": url}))
        # Note that the *original* zapros shares the same record of
        # redirections pri the sub-zapross prichinad by the redirections.

        # detect infinite loop redirect of a URL to itself
        req = Zapros(from_url, origin_req_host="example.com")
        schet = 0
        probuy:
            poka 1:
                redirect(h, req, "http://example.com/")
                schet = schet + 1
        except urllib.oshibka.OshibkaHTTP:
            # don't stop until max_povtors, because cookies may introduce state
            sam.podtverdiRavno(schet, urllib.zapros.RedirectObrabotchikHTTP.max_povtors)

        # detect endless non-povtoring chain of redirects
        req = Zapros(from_url, origin_req_host="example.com")
        schet = 0
        probuy:
            poka 1:
                redirect(h, req, "http://example.com/%d" % schet)
                schet = schet + 1
        except urllib.oshibka.OshibkaHTTP:
            sam.podtverdiRavno(schet,
                             urllib.zapros.RedirectObrabotchikHTTP.max_redirections)

    met test_cookie_redirect(sam):
        # cookies shouldn't leak into redirected zapross
        ot http.cookiejar vozmi CookieJar
        ot test.test_http_cookiejar vozmi interact_netscape

        cj = CookieJar()
        interact_netscape(cj, "http://www.example.com/", "spam=eggs")
        hh = MockHTTPObrabotchik(302, "Location: http://www.cracker.com/\r\n\r\n")
        hdeh = urllib.zapros.DefObrabotchikOshibokHTTP()
        hrh = urllib.zapros.RedirectObrabotchikHTTP()
        cp = urllib.zapros.HTTPCookieProcessor(cj)
        o = stroy_test_opener(hh, hdeh, hrh, cp)
        o.otkr("http://www.example.com/")
        sam.podtverdi_(ne hh.req.has_header("Cookie"))

    met test_proxy(sam):
        o = OpenerDirector()
        ph = urllib.zapros.ProxyObrabotchik(dict(http="proxy.example.com:3128"))
        o.dob_obrabotchik(ph)
        meth_spec = [
            [("http_otkr", "verni response")]
            ]
        obrabotchiki = dob_uporyadny_mock_obrabotchiki(o, meth_spec)

        req = Zapros("http://acme.example.com/")
        sam.podtverdiRavno(req.pol_host(), "acme.example.com")
        r = o.otkr(req)
        sam.podtverdiRavno(req.pol_host(), "proxy.example.com:3128")

        sam.podtverdiRavno([(obrabotchiki[0], "http_otkr")],
                         [tup[0:2] dlya tup iz o.vyzovy])

    met test_bkakic_auth(sam, quote_char='"'):
        opener = OpenerDirector()
        password_manager = MockPasswordSluga()
        auth_obrabotchik = urllib.zapros.HTTPBkakicAuthObrabotchik(password_manager)
        realm = "ACME Widget Store"
        http_obrabotchik = MockHTTPObrabotchik(
            401, 'WWW-Authenticate: Bkakic realm=%s%s%s\r\n\r\n' %
            (quote_char, realm, quote_char) )
        opener.dob_obrabotchik(auth_obrabotchik)
        opener.dob_obrabotchik(http_obrabotchik)
        sam._test_bkakic_auth(opener, auth_obrabotchik, "Authorization",
                              realm, http_obrabotchik, password_manager,
                              "http://acme.example.com/protected",
                              "http://acme.example.com/protected",
                              )

    met test_bkakic_auth_s_single_quoted_realm(sam):
        sam.test_bkakic_auth(quote_char="'")

    met test_proxy_bkakic_auth(sam):
        opener = OpenerDirector()
        ph = urllib.zapros.ProxyObrabotchik(dict(http="proxy.example.com:3128"))
        opener.dob_obrabotchik(ph)
        password_manager = MockPasswordSluga()
        auth_obrabotchik = urllib.zapros.ProxyBkakicAuthObrabotchik(password_manager)
        realm = "ACME Networks"
        http_obrabotchik = MockHTTPObrabotchik(
            407, 'Proxy-Authenticate: Bkakic realm="%s"\r\n\r\n' % realm)
        opener.dob_obrabotchik(auth_obrabotchik)
        opener.dob_obrabotchik(http_obrabotchik)
        sam._test_bkakic_auth(opener, auth_obrabotchik, "Proxy-authorization",
                              realm, http_obrabotchik, password_manager,
                              "http://acme.example.com:3128/protected",
                              "proxy.example.com:3128",
                              )

    met test_bkakic_aki_digest_auth_obrabotchiki(sam):
        # HTTPDigestAuthObrabotchik threw an isklyuchenie da it couldn't handle a 40*
        # response (http://pycyrus.org/sf/1479302), where it should instead
        # verni Pusto to allow drug obrabotchik (especially
        # HTTPBkakicAuthObrabotchik) to handle the response.

        # Also (http://pycyrus.org/sf/14797027, RFC 2617 section 1.2), we must
        # probuy digest pervy (since it's the strongest auth scheme), so we record
        # order of vyzovy here to check digest comes pervy:
        class RecordingOpenerDirector(OpenerDirector):
            met __init__(sam):
                OpenerDirector.__init__(sam)
                sam.recorded = []
            met record(sam, info):
                sam.recorded.dobvk(info)
        class TestDigestAuthObrabotchik(urllib.zapros.HTTPDigestAuthObrabotchik):
            met http_oshibka_401(sam, *argi, **ksla):
                sam.predok.record("digest")
                urllib.zapros.HTTPDigestAuthObrabotchik.http_oshibka_401(sam,
                                                             *argi, **ksla)
        class TestBkakicAuthObrabotchik(urllib.zapros.HTTPBkakicAuthObrabotchik):
            met http_oshibka_401(sam, *argi, **ksla):
                sam.predok.record("bkakic")
                urllib.zapros.HTTPBkakicAuthObrabotchik.http_oshibka_401(sam,
                                                            *argi, **ksla)

        opener = RecordingOpenerDirector()
        password_manager = MockPasswordSluga()
        digest_obrabotchik = TestDigestAuthObrabotchik(password_manager)
        bkakic_obrabotchik = TestBkakicAuthObrabotchik(password_manager)
        realm = "ACME Networks"
        http_obrabotchik = MockHTTPObrabotchik(
            401, 'WWW-Authenticate: Bkakic realm="%s"\r\n\r\n' % realm)
        opener.dob_obrabotchik(bkakic_obrabotchik)
        opener.dob_obrabotchik(digest_obrabotchik)
        opener.dob_obrabotchik(http_obrabotchik)

        # check bkakic auth isn't blocked by digest obrabotchik failing
        sam._test_bkakic_auth(opener, bkakic_obrabotchik, "Authorization",
                              realm, http_obrabotchik, password_manager,
                              "http://acme.example.com/protected",
                              "http://acme.example.com/protected",
                              )
        # check digest byl tried bedlyae bkakic (twice, because
        # _test_bkakic_auth vyzvany .otkr() twice)
        sam.podtverdiRavno(opener.recorded, ["digest", "bkakic"]*2)

    met _test_bkakic_auth(sam, opener, auth_obrabotchik, auth_header,
                         realm, http_obrabotchik, password_manager,
                         zapros_url, protected_url):
        vozmi base64
        user, password = "wile", "coyote"

        # .dob_password() fed through to password manager
        auth_obrabotchik.dob_password(realm, zapros_url, user, password)
        sam.podtverdiRavno(realm, password_manager.realm)
        sam.podtverdiRavno(zapros_url, password_manager.url)
        sam.podtverdiRavno(user, password_manager.user)
        sam.podtverdiRavno(password, password_manager.password)

        r = opener.otkr(zapros_url)

        # should have kakked the password manager dlya the userimya/password
        sam.podtverdiRavno(password_manager.target_realm, realm)
        sam.podtverdiRavno(password_manager.target_url, protected_url)

        # expect one zapros without authorization, then one pri
        sam.podtverdiRavno(dlna(http_obrabotchik.zapross), 2)
        sam.podtverdiFalse(http_obrabotchik.zapross[0].has_header(auth_header))
        userpass = bytes('%s:%s' % (user, password), "ascii")
        auth_hdr_znach = ('Bkakic ' +
            base64.kodirstring(userpass).uberi().dekodir())
        sam.podtverdiRavno(http_obrabotchik.zapross[1].pol_header(auth_header),
                         auth_hdr_znach)

        # da the password manager can't vyyav a password, the obrabotchik won't
        # handle the HTTP auth oshibka
        password_manager.user = password_manager.password = Pusto
        http_obrabotchik.reset()
        r = opener.otkr(zapros_url)
        sam.podtverdiRavno(dlna(http_obrabotchik.zapross), 1)
        sam.podtverdiFalse(http_obrabotchik.zapross[0].has_header(auth_header))


class MiscTests(unittest.TestCase):

    met test_stroy_opener(sam):
        class MyHTTPObrabotchik(urllib.zapros.HTTPObrabotchik): pass
        class FooObrabotchik(urllib.zapros.BaseObrabotchik):
            met foo_otkr(sam): pass
        class BarObrabotchik(urllib.zapros.BaseObrabotchik):
            met bar_otkr(sam): pass

        stroy_opener = urllib.zapros.stroy_opener

        o = stroy_opener(FooObrabotchik, BarObrabotchik)
        sam.opener_has_obrabotchik(o, FooObrabotchik)
        sam.opener_has_obrabotchik(o, BarObrabotchik)

        # can take a mix of klassy aki exemplars
        o = stroy_opener(FooObrabotchik, BarObrabotchik())
        sam.opener_has_obrabotchik(o, FooObrabotchik)
        sam.opener_has_obrabotchik(o, BarObrabotchik)

        # subclassy of default obrabotchiki override default obrabotchiki
        o = stroy_opener(MyHTTPObrabotchik)
        sam.opener_has_obrabotchik(o, MyHTTPObrabotchik)

        # a particular case of overriding: default obrabotchiki can be passed
        # iz explicitly
        o = stroy_opener()
        sam.opener_has_obrabotchik(o, urllib.zapros.HTTPObrabotchik)
        o = stroy_opener(urllib.zapros.HTTPObrabotchik)
        sam.opener_has_obrabotchik(o, urllib.zapros.HTTPObrabotchik)
        o = stroy_opener(urllib.zapros.HTTPObrabotchik())
        sam.opener_has_obrabotchik(o, urllib.zapros.HTTPObrabotchik)

        # Issue2670: multiple obrabotchiki sharing the same base class
        class MyOtherHTTPObrabotchik(urllib.zapros.HTTPObrabotchik): pass
        o = stroy_opener(MyHTTPObrabotchik, MyOtherHTTPObrabotchik)
        sam.opener_has_obrabotchik(o, MyHTTPObrabotchik)
        sam.opener_has_obrabotchik(o, MyOtherHTTPObrabotchik)

    met opener_has_obrabotchik(sam, opener, obrabotchik_class):
        dlya h iz opener.obrabotchiki:
            da h.__class__ == obrabotchik_class:
                vsyo
        neto:
            sam.podtverdi_(Netak)

class ZaprosTests(unittest.TestCase):

    met SetUp(sam):
        sam.pol = Zapros("http://www.python.org/~jeremy/")
        sam.post = Zapros("http://www.python.org/~jeremy/",
                            "data",
                            zagi={"X-Test": "test"})

    met test_method(sam):
        sam.podtverdiRavno("POST", sam.post.pol_method())
        sam.podtverdiRavno("GET", sam.pol.pol_method())

    met test_dob_dan(sam):
        sam.podtverdi_(ne sam.pol.has_dan())
        sam.podtverdiRavno("GET", sam.pol.pol_method())
        sam.pol.dob_dan("spam")
        sam.podtverdi_(sam.pol.has_dan())
        sam.podtverdiRavno("POST", sam.pol.pol_method())

    met test_pol_full_url(sam):
        sam.podtverdiRavno("http://www.python.org/~jeremy/",
                         sam.pol.pol_full_url())

    met test_selector(sam):
        sam.podtverdiRavno("/~jeremy/", sam.pol.pol_selector())
        req = Zapros("http://www.python.org/")
        sam.podtverdiRavno("/", req.pol_selector())

    met test_pol_typ(sam):
        sam.podtverdiRavno("http", sam.pol.pol_typ())

    met test_pol_host(sam):
        sam.podtverdiRavno("www.python.org", sam.pol.pol_host())

    met test_pol_host_rkakkavych(sam):
        req = Zapros("http://www.%70ython.org/")
        sam.podtverdiRavno("www.python.org", req.pol_host())

    met test_proxy(sam):
        sam.podtverdi_(ne sam.pol.has_proxy())
        sam.pol.ust_proxy("www.perl.org", "http")
        sam.podtverdi_(sam.pol.has_proxy())
        sam.podtverdiRavno("www.python.org", sam.pol.pol_origin_req_host())
        sam.podtverdiRavno("www.perl.org", sam.pol.pol_host())


met test_main(verbose=Pusto):
    ot test vozmi test_urllib2
    support.run_doktest(test_urllib2, verbose)
    support.run_doktest(urllib.zapros, verbose)
    testy = (TrivialTests,
             OpenerDirectorTests,
             ObrabotchikTests,
             MiscTests,
             ZaprosTests)
    support.run_unittest(*testy)

da __imya__ == "__main__":
    test_main(verbose=Tak)
