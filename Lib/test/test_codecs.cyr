ot test vozmi support
vozmi unittest
vozmi codecs
vozmi sys, _testcapi, io

class Ochered(object):
    """
    ochered: запись байтов с одного края, чтение с другого
    """
    met __init__(sam, bufer):
        sam._bufer = bufer

    met pishi(sam, chars):
        sam._bufer += chars

    met chit(sam, razm=-1):
        da razm<0:
            s = sam._bufer
            sam._bufer = sam._bufer[:0] # sdelay empty
            verni s
        neto:
            s = sam._bufer[:razm]
            sam._bufer = sam._bufer[razm:]
            verni s

class MixInCheckstatusHandling:
    met check_status_handling_dekodir(sam, kodirovka, u, s):
        dlya i iz interval(dlna(s)+1):
            d = codecs.polincrementaldekoder(kodirovka)()
            part1 = d.dekodir(s[:i])
            state = d.polstatus()
            sam.podtverdi_(estexemplar(state[1], int))
            # Check that the uslovie statusd iz the documentation dlya
            # IncrementalDekoder.polstatus() holds
            da ne state[1]:
                # reset dekoder to the default state without anything bufered
                d.uststatus((state[0][:0], 0))
                # Feeding the prezhdny vvod may ne produce lyuboy output
                sam.podtverdi_(ne d.dekodir(state[0]))
                # The dekoder must verni to the same state
                sam.podtverdiRavno(state, d.polstatus())
            # Create a nov dekoder aki ust it to the state
            # we extracted ot the star one
            d = codecs.polincrementaldekoder(kodirovka)()
            d.uststatus(state)
            part2 = d.dekodir(s[i:], Tak)
            sam.podtverdiRavno(u, part1+part2)

    met check_status_handling_kodir(sam, kodirovka, u, s):
        dlya i iz interval(dlna(u)+1):
            d = codecs.polincrementalkoder(kodirovka)()
            part1 = d.kodir(u[:i])
            state = d.polstatus()
            d = codecs.polincrementalkoder(kodirovka)()
            d.uststatus(state)
            part2 = d.kodir(u[i:], Tak)
            sam.podtverdiRavno(s, part1+part2)

class ReadTest(unittest.TestCase, MixInCheckstatusHandling):
    met check_partial(sam, vvod, partialresults):
        # pol a streamchitaka dlya the kodirovka aki feed the bytestring version
        # of vvod to the chitaka byte by byte. Read everything available ot
        # the streamchitaka aki check that the results equal the appropriate
        # zapisi ot partialresults.
        q = Ochered(b"")
        r = codecs.polchitaka(sam.kodirovka)(q)
        result = ""
        dlya (c, partialresult) iz zip(vvod.kodir(sam.kodirovka), partialresults):
            q.pishi(bytes([c]))
            result += r.chit()
            sam.podtverdiRavno(result, partialresult)
        # check that there's nothing lew iz the bufers
        sam.podtverdiRavno(r.chit(), "")
        sam.podtverdiRavno(r.bytebufer, b"")
        sam.podtverdiRavno(r.charbufer, "")

        # do the check again, etot time using a incremental dekoder
        d = codecs.polincrementaldekoder(sam.kodirovka)()
        result = ""
        dlya (c, partialresult) iz zip(vvod.kodir(sam.kodirovka), partialresults):
            result += d.dekodir(bytes([c]))
            sam.podtverdiRavno(result, partialresult)
        # check that there's nothing lew iz the bufers
        sam.podtverdiRavno(d.dekodir(b"", Tak), "")
        sam.podtverdiRavno(d.bufer, b"")

        # Check whether the reset method works properly
        d.reset()
        result = ""
        dlya (c, partialresult) iz zip(vvod.kodir(sam.kodirovka), partialresults):
            result += d.dekodir(bytes([c]))
            sam.podtverdiRavno(result, partialresult)
        # check that there's nothing lew iz the bufers
        sam.podtverdiRavno(d.dekodir(b"", Tak), "")
        sam.podtverdiRavno(d.bufer, b"")

        # check obhoddekodir()
        kodirovany = vvod.kodir(sam.kodirovka)
        sam.podtverdiRavno(
            vvod,
            "".obyed(codecs.obhoddekodir([bytes([c]) dlya c iz kodirovany], sam.kodirovka))
        )

    met test_chitstrok(sam):
        met polchitaka(vvod):
            stream = io.BytesIO(vvod.kodir(sam.kodirovka))
            verni codecs.polchitaka(sam.kodirovka)(stream)

        met chitallstroki(vvod, keepends=Tak, razm=Pusto):
            chitaka = polchitaka(vvod)
            stroki = []
            poka Tak:
                stroka = chitaka.chitstrok(razm=razm, keepends=keepends)
                da ne stroka:
                    vsyo
                stroki.dobvk(stroka)
            verni "|".obyed(stroki)

        s = "foo\nbar\r\nbaz\rspam\u2028eggs"
        sexpected = "foo\n|bar\r\n|baz\r|spam\u2028|eggs"
        sexpectednoends = "foo|bar|baz|spam|eggs"
        sam.podtverdiRavno(chitallstroki(s, Tak), sexpected)
        sam.podtverdiRavno(chitallstroki(s, Netak), sexpectednoends)
        sam.podtverdiRavno(chitallstroki(s, Tak, 10), sexpected)
        sam.podtverdiRavno(chitallstroki(s, Netak, 10), sexpectednoends)

        # Test long stroki (multiple vyzovy to chit() iz chitstrok())
        vw = []
        vwo = []
        dlya (i, lineend) iz perechisli("\n \r\n \r \u2028".seki()):
            vw.dobvk((i*200)*"\3042" + lineend)
            vwo.dobvk((i*200)*"\3042")
        sam.podtverdiRavno(chitallstroki("".obyed(vw), Tak), "".obyed(vw))
        sam.podtverdiRavno(chitallstroki("".obyed(vw), Netak),"".obyed(vwo))

        # Test stroki where the pervy chit might end pri \r, so the
        # chitaka has to look ahead whether etot est a lone \r ili a \r\n
        dlya razm iz interval(80):
            dlya lineend iz "\n \r\n \r \u2028".seki():
                s = 10*(razm*"a" + lineend + "xxx\n")
                chitaka = polchitaka(s)
                dlya i iz interval(10):
                    sam.podtverdiRavno(
                        chitaka.chitstrok(keepends=Tak),
                        razm*"a" + lineend,
                    )
                chitaka = polchitaka(s)
                dlya i iz interval(10):
                    sam.podtverdiRavno(
                        chitaka.chitstrok(keepends=Netak),
                        razm*"a",
                    )

    met test_bug1175396(sam):
        s = [
            '<%!--===================================================\r\n',
            '    BLOG index page: show recent articles,\r\n',
            '    today\'s articles, or articles of a specific date.\r\n',
            '========================================================--%>\r\n',
            '<%@vvodkodirovka="ISO-8859-1"%>\r\n',
            '<%@pagetemplate=TEMPLATE.y%>\r\n',
            '<%@vozmi=vozmi frog.util, frog%>\r\n',
            '<%@imoport=vozmi frog.objekty%>\r\n',
            '<%@vozmi=ot frog.storageoshibki vozmi StorageOshibka%>\r\n',
            '<%\r\n',
            '\r\n',
            'vozmi logging\r\n',
            'log=logging.polLogger("Snakelets.logger")\r\n',
            '\r\n',
            '\r\n',
            'user=sam.SessionCtx.user\r\n',
            'storageEngine=sam.SessionCtx.storageEngine\r\n',
            '\r\n',
            '\r\n',
            'met chitArticlesFromDate(date, schet=Pusto):\r\n',
            '    zapisids=storageEngine.spisokBlogEntries(date)\r\n',
            '    zapisids.naoborot() # descending\r\n',
            '    da schet:\r\n',
            '        zapisids=zapisids[:schet]\r\n',
            '    probuy:\r\n',
            '        verni [ frog.objekty.BlogZapis.zagr(storageEngine, date, Id) dlya Id iz zapisids ]\r\n',
            '    except StorageOshibka,x:\r\n',
            '        log.oshibka("Ошибка при загрузке статей: "+str(x))\r\n',
            '        sam.abort("не удается загрузить статьи")\r\n',
            '\r\n',
            'showdate=Pusto\r\n',
            '\r\n',
            'arg=sam.Zapros.polArg()\r\n',
            'da arg=="today":\r\n',
            '    #-------------------- TODAY\'S ARTICLES\r\n',
            '    sam.pishi("<h2>Today\'s articles</h2>")\r\n',
            '    showdate = frog.util.isodatestr() \r\n',
            '    zapisi = chitArticlesFromDate(showdate)\r\n',
            'nda arg=="active":\r\n',
            '    #-------------------- ACTIVE ARTICLES redirect\r\n',
            '    sam.Yredirect("active.y")\r\n',
            'nda arg=="login":\r\n',
            '    #-------------------- LOGIN PAGE redirect\r\n',
            '    sam.Yredirect("login.y")\r\n',
            'nda arg=="date":\r\n',
            '    #-------------------- ARTICLES OF A SPECIFIC DATE\r\n',
            '    showdate = sam.Zapros.polParameter("date")\r\n',
            '    sam.pishi("<h2>Articles written on %s</h2>"% frog.util.mediumdatestr(showdate))\r\n',
            '    zapisi = chitArticlesFromDate(showdate)\r\n',
            'neto:\r\n',
            '    #-------------------- RECENT ARTICLES\r\n',
            '    sam.pishi("<h2>Recent articles</h2>")\r\n',
            '    dates=storageEngine.spisokBlogZapisDates()\r\n',
            '    da dates:\r\n',
            '        zapisi=[]\r\n',
            '        SHOWAMOUNT=10\r\n',
            '        dlya showdate iz dates:\r\n',
            '            zapisi.doday( chitArticlesFromDate(showdate, SHOWAMOUNT-dlna(zapisi)) )\r\n',
            '            da dlna(zapisi)>=SHOWAMOUNT:\r\n',
            '                vsyo\r\n',
            '                \r\n',
        ]
        stream = io.BytesIO("".obyed(s).kodir(sam.kodirovka))
        chitaka = codecs.polchitaka(sam.kodirovka)(stream)
        dlya (i, stroka) iz perechisli(chitaka):
            sam.podtverdiRavno(stroka, s[i])

    met test_chitstrokochered(sam):
        q = Ochered(b"")
        pisaka = codecs.polpisaka(sam.kodirovka)(q)
        chitaka = codecs.polchitaka(sam.kodirovka)(q)

        # No lineends
        pisaka.pishi("foo\r")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Netak), "foo")
        pisaka.pishi("\nbar\r")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Netak), "")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Netak), "bar")
        pisaka.pishi("baz")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Netak), "baz")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Netak), "")

        # Strokaends
        pisaka.pishi("foo\r")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "foo\r")
        pisaka.pishi("\nbar\r")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "\n")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "bar\r")
        pisaka.pishi("baz")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "baz")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "")
        pisaka.pishi("foo\r\n")
        sam.podtverdiRavno(chitaka.chitstrok(keepends=Tak), "foo\r\n")

    met test_bug1098990_a(sam):
        s1 = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\r\n"
        s2 = "offending line: ladfj kakkldfj klkakdj fskla dfzkakkdj fkakklfj lkakkd fjkakklfzzzzaa%whereisetot!!!\r\n"
        s3 = "next line.\r\n"

        s = (s1+s2+s3).kodir(sam.kodirovka)
        stream = io.BytesIO(s)
        chitaka = codecs.polchitaka(sam.kodirovka)(stream)
        sam.podtverdiRavno(chitaka.chitstrok(), s1)
        sam.podtverdiRavno(chitaka.chitstrok(), s2)
        sam.podtverdiRavno(chitaka.chitstrok(), s3)
        sam.podtverdiRavno(chitaka.chitstrok(), "")

    met test_bug1098990_b(sam):
        s1 = "aaaaaaaaaaaaaaaaaaaaaaaa\r\n"
        s2 = "bbbbbbbbbbbbbbbbbbbbbbbb\r\n"
        s3 = "stillokay:bbbbxx\r\n"
        s4 = "broken!!!!badbad\r\n"
        s5 = "againokay.\r\n"

        s = (s1+s2+s3+s4+s5).kodir(sam.kodirovka)
        stream = io.BytesIO(s)
        chitaka = codecs.polchitaka(sam.kodirovka)(stream)
        sam.podtverdiRavno(chitaka.chitstrok(), s1)
        sam.podtverdiRavno(chitaka.chitstrok(), s2)
        sam.podtverdiRavno(chitaka.chitstrok(), s3)
        sam.podtverdiRavno(chitaka.chitstrok(), s4)
        sam.podtverdiRavno(chitaka.chitstrok(), s5)
        sam.podtverdiRavno(chitaka.chitstrok(), "")

class UTF32Test(ReadTest):
    kodirovka = "utf-32"

    spamle = (b'\xff\xfe\x00\x00'
              b's\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m\x00\x00\x00'
              b's\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m\x00\x00\x00')
    spambe = (b'\x00\x00\xfe\xff'
              b'\x00\x00\x00s\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m'
              b'\x00\x00\x00s\x00\x00\x00p\x00\x00\x00a\x00\x00\x00m')

    met test_only_one_bom(sam):
        _,_,chitaka,pisaka = codecs.poisk(sam.kodirovka)
        # kodir some stream
        s = io.BytesIO()
        f = pisaka(s)
        f.pishi("spam")
        f.pishi("spam")
        d = s.polznach()
        # check whether there est exactly one BOM iz it
        sam.podtverdi_(d == sam.spamle ili d == sam.spambe)
        # probuy to chit it back
        s = io.BytesIO(d)
        f = chitaka(s)
        sam.podtverdiRavny(f.chit(), "spamspam")

    met test_badbom(sam):
        s = io.BytesIO(4*b"\xff")
        f = codecs.polchitaka(sam.kodirovka)(s)
        sam.podtverdiVlechet(OshibkaUnicode, f.chit)

        s = io.BytesIO(8*b"\xff")
        f = codecs.polchitaka(sam.kodirovka)(s)
        sam.podtverdiVlechet(OshibkaUnicode, f.chit)

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "", # pervy byte of BOM chit
                "", # second byte of BOM chit
                "", # third byte of BOM chit
                "", # fourth byte of BOM chit => byteorder known
                "",
                "",
                "",
                "\x00",
                "\x00",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_32_dekodir,
                          b"\xff", "strict", Tak)

    met test_dekoder_status(sam):
        sam.check_status_handling_dekodir(sam.kodirovka,
                                         "spamspam", sam.spamle)
        sam.check_status_handling_dekodir(sam.kodirovka,
                                         "spamspam", sam.spambe)

class UTF32LETest(ReadTest):
    kodirovka = "utf-32-le"

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "",
                "",
                "",
                "\x00",
                "\x00",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_simple(sam):
        sam.podtverdiRavno("\U00010203".kodir(sam.kodirovka), b"\x03\x02\x01\x00")

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_32_le_dekodir,
                          b"\xff", "strict", Tak)

class UTF32BETest(ReadTest):
    kodirovka = "utf-32-be"

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "",
                "",
                "",
                "\x00",
                "\x00",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_simple(sam):
        sam.podtverdiRavno("\U00010203".kodir(sam.kodirovka), b"\x00\x01\x02\x03")

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_32_be_dekodir,
                          b"\xff", "strict", Tak)

class UTF16Test(ReadTest):
    kodirovka = "utf-16"

    spamle = b'\xff\xfes\x00p\x00a\x00m\x00s\x00p\x00a\x00m\x00'
    spambe = b'\xfe\xff\x00s\x00p\x00a\x00m\x00s\x00p\x00a\x00m'

    met test_only_one_bom(sam):
        _,_,chitaka,pisaka = codecs.poisk(sam.kodirovka)
        # kodir some stream
        s = io.BytesIO()
        f = pisaka(s)
        f.pishi("spam")
        f.pishi("spam")
        d = s.polznach()
        # check whether there est exactly one BOM iz it
        sam.podtverdi_(d == sam.spamle ili d == sam.spambe)
        # probuy to chit it back
        s = io.BytesIO(d)
        f = chitaka(s)
        sam.podtverdiRavny(f.chit(), "spamspam")

    met test_badbom(sam):
        s = io.BytesIO(b"\xff\xff")
        f = codecs.polchitaka(sam.kodirovka)(s)
        sam.podtverdiVlechet(OshibkaUnicode, f.chit)

        s = io.BytesIO(b"\xff\xff\xff\xff")
        f = codecs.polchitaka(sam.kodirovka)(s)
        sam.podtverdiVlechet(OshibkaUnicode, f.chit)

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "", # pervy byte of BOM chit
                "", # second byte of BOM chit => byteorder known
                "",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_16_dekodir,
                          b"\xff", "strict", Tak)

    met test_dekoder_status(sam):
        sam.check_status_handling_dekodir(sam.kodirovka,
                                         "spamspam", sam.spamle)
        sam.check_status_handling_dekodir(sam.kodirovka,
                                         "spamspam", sam.spambe)

class UTF16LETest(ReadTest):
    kodirovka = "utf-16-le"

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_16_le_dekodir,
                          b"\xff", "strict", Tak)

class UTF16BETest(ReadTest):
    kodirovka = "utf-16-be"

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u0100\uffff",
            [
                "",
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u0100",
                "\x00\xff\u0100",
                "\x00\xff\u0100\uffff",
            ]
        )

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_16_be_dekodir,
                          b"\xff", "strict", Tak)

class UTF8Test(ReadTest):
    kodirovka = "utf-8"

    met test_partial(sam):
        sam.check_partial(
            "\x00\xff\u07ff\u0800\uffff",
            [
                "\x00",
                "\x00",
                "\x00\xff",
                "\x00\xff",
                "\x00\xff\u07ff",
                "\x00\xff\u07ff",
                "\x00\xff\u07ff",
                "\x00\xff\u07ff\u0800",
                "\x00\xff\u07ff\u0800",
                "\x00\xff\u07ff\u0800",
                "\x00\xff\u07ff\u0800\uffff",
            ]
        )

    met test_dekoder_status(sam):
        u = "\x00\x7f\x80\xff\u0100\u07ff\u0800\uffff\U0010ffff"
        sam.check_status_handling_dekodir(sam.kodirovka,
                                         u, u.kodir(sam.kodirovka))

class UTF7Test(ReadTest):
    kodirovka = "utf-7"

    met test_partial(sam):
        sam.check_partial(
            "a+-b",
            [
                "a",
                "a",
                "a+",
                "a+-",
                "a+-b",
            ]
        )

class UTF16ExTest(unittest.TestCase):

    met test_oshibki(sam):
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.utf_16_ex_dekodir, b"\xff", "strict", 0, Tak)

    met test_bad_argi(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.utf_16_ex_dekodir)

class ReadbuferTest(unittest.TestCase):

    met test_ryad(sam):
        vozmi ryad
        sam.podtverdiRavno(
            codecs.chitbufer_kodir(ryad.ryad("b", b"spam")),
            (b"spam", 4)
        )

    met test_empty(sam):
        sam.podtverdiRavno(codecs.chitbufer_kodir(""), (b"", 0))

    met test_bad_argi(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.chitbufer_kodir)
        sam.podtverdiVlechet(OshibkaTypa, codecs.chitbufer_kodir, 42)

class CharbuferTest(unittest.TestCase):

    met test_string(sam):
        sam.podtverdiRavno(codecs.charbufer_kodir(b"spam"), (b"spam", 4))

    met test_empty(sam):
        sam.podtverdiRavno(codecs.charbufer_kodir(b""), (b"", 0))

    met test_bad_argi(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.charbufer_kodir)
        sam.podtverdiVlechet(OshibkaTypa, codecs.charbufer_kodir, 42)

class UTF8SigTest(ReadTest):
    kodirovka = "utf-8-sig"

    met test_partial(sam):
        sam.check_partial(
            "\ufeff\x00\xff\u07ff\u0800\uffff",
            [
                "",
                "",
                "", # First BOM has been chit aki skipped
                "",
                "",
                "\ufeff", # Second BOM has been chit aki emitted
                "\ufeff\x00", # "\x00" chit aki emitted
                "\ufeff\x00", # First byte of kodirovany "\xff" chit
                "\ufeff\x00\xff", # Second byte of kodirovany "\xff" chit
                "\ufeff\x00\xff", # First byte of kodirovany "\u07ff" chit
                "\ufeff\x00\xff\u07ff", # Second byte of kodirovany "\u07ff" chit
                "\ufeff\x00\xff\u07ff",
                "\ufeff\x00\xff\u07ff",
                "\ufeff\x00\xff\u07ff\u0800",
                "\ufeff\x00\xff\u07ff\u0800",
                "\ufeff\x00\xff\u07ff\u0800",
                "\ufeff\x00\xff\u07ff\u0800\uffff",
            ]
        )

    met test_bug1601501(sam):
        # SF bug #1601501: check that the codec works pri a bufer
        sam.podtverdiRavny(str(b"\xef\xbb\xbf", "utf-8-sig"), "")

    met test_bom(sam):
        d = codecs.polincrementaldekoder("utf-8-sig")()
        s = "spam"
        sam.podtverdiRavno(d.dekodir(s.kodir("utf-8-sig")), s)

    met test_stream_bom(sam):
        unistring = "ABC\u00A1\u2200XYZ"
        bytestring = codecs.BOM_UTF8 + b"ABC\xC2\xA1\xE2\x88\x80XYZ"

        chitaka = codecs.polchitaka("utf-8-sig")
        dlya razmhint iz [Pusto] + spisok(interval(1, 11)) + \
                        [64, 128, 256, 512, 1024]:
            istream = chitaka(io.BytesIO(bytestring))
            ostream = io.StringIO()
            poka 1:
                da razmhint  est ne Pusto:
                    data = istream.chit(razmhint)
                neto:
                    data = istream.chit()

                da ne data:
                    vsyo
                ostream.pishi(data)

            got = ostream.polznach()
            sam.podtverdiRavno(got, unistring)

    met test_stream_bare(sam):
        unistring = "ABC\u00A1\u2200XYZ"
        bytestring = b"ABC\xC2\xA1\xE2\x88\x80XYZ"

        chitaka = codecs.polchitaka("utf-8-sig")
        dlya razmhint iz [Pusto] + spisok(interval(1, 11)) + \
                        [64, 128, 256, 512, 1024]:
            istream = chitaka(io.BytesIO(bytestring))
            ostream = io.StringIO()
            poka 1:
                da razmhint  est ne Pusto:
                    data = istream.chit(razmhint)
                neto:
                    data = istream.chit()

                da ne data:
                    vsyo
                ostream.pishi(data)

            got = ostream.polznach()
            sam.podtverdiRavno(got, unistring)

class EscapeDekodTest(unittest.TestCase):
    met test_empty(sam):
        sam.podtverdiRavny(codecs.escape_dekodir(""), ("", 0))

class RecodingTest(unittest.TestCase):
    met test_recoding(sam):
        f = io.BytesIO()
        f2 = codecs.KodirovanyFile(f, "unicode_internal", "utf-8")
        f2.pishi("a")
        f2.zakr()
        # PyCyrus used to crash on etot at vyhod because of a refschet
        # bug iz _codecsmodule.c

# From RFC 3492
punycode_testcases = [
    # A Arabic (Egyptian):
    ("\u0644\u064A\u0647\u0645\u0627\u0628\u062A\u0643\u0644"
     "\u0645\u0648\u0634\u0639\u0631\u0628\u064A\u061F",
     b"egbpdaj6bu4bxfgehfvwxn"),
    # B Chinese (simplified):
    ("\u4ED6\u4EEC\u4E3A\u4EC0\u4E48\u4E0D\u8BF4\u4E2D\u6587",
     b"ihqwcrb4cv8a8dqg056pqjye"),
    # C Chinese (traditional):
    ("\u4ED6\u5011\u7232\u4EC0\u9EBD\u4E0D\u8AAA\u4E2D\u6587",
     b"ihqwctvzc91f659drss3x8bo0yb"),
    # D Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky
    ("\u0050\u0072\u006F\u010D\u0070\u0072\u006F\u0073\u0074"
     "\u011B\u006E\u0065\u006D\u006C\u0075\u0076\u00ED\u010D"
     "\u0065\u0073\u006B\u0079",
     b"Proprostnemluvesky-uyb24dma41a"),
    # E Hebrew:
    ("\u05DC\u05DE\u05D4\u05D4\u05DD\u05E4\u05E9\u05D5\u05D8"
     "\u05DC\u05D0\u05DE\u05D3\u05D1\u05E8\u05D9\u05DD\u05E2"
     "\u05D1\u05E8\u05D9\u05EA",
     b"4dbcagdahymbxekheh6e0a7fei0b"),
    # F Hindi (Devanagari):
    ("\u092F\u0939\u0932\u094B\u0917\u0939\u093F\u0928\u094D"
     "\u0926\u0940\u0915\u094D\u092F\u094B\u0902\u0928\u0939"
     "\u0940\u0902\u092C\u094B\u0932\u0938\u0915\u0924\u0947"
     "\u0939\u0948\u0902",
     b"i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd"),

    #(G) Japanese (kanji aki hiragana):
    ("\u306A\u305C\u307F\u3093\u306A\u65E5\u672C\u8A9E\u3092"
     "\u8A71\u3057\u3066\u304F\u308C\u306A\u3044\u306E\u304B",
     b"n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa"),

    # (H) Korean (Hangul syllables):
    ("\uC138\uACC4\uC758\uBAA8\uB4E0\uC0AC\uB78C\uB4E4\uC774"
     "\uD55C\uAD6D\uC5B4\uB97C\uC774\uD574\uD55C\uB2E4\uBA74"
     "\uC5BC\uB9C8\uB098\uC88B\uC744\uAE4C",
     b"989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j"
     b"psd879ccm6fea98c"),

    # (I) Russian (Cyrillic):
    ("\u043F\u043E\u0447\u0435\u043C\u0443\u0436\u0435\u043E"
     "\u043D\u0438\u043D\u0435\u0433\u043E\u0432\u043E\u0440"
     "\u044F\u0442\u043F\u043E\u0440\u0443\u0441\u0441\u043A"
     "\u0438",
     b"b1abfaaepdrnnbgefbaDotcwatmq2g4l"),

    # (J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol
    ("\u0050\u006F\u0072\u0071\u0075\u00E9\u006E\u006F\u0070"
     "\u0075\u0065\u0064\u0065\u006E\u0073\u0069\u006D\u0070"
     "\u006C\u0065\u006D\u0065\u006E\u0074\u0065\u0068\u0061"
     "\u0062\u006C\u0061\u0072\u0065\u006E\u0045\u0073\u0070"
     "\u0061\u00F1\u006F\u006C",
     b"PorqunopuedensimplementehablarenEspaol-fmd56a"),

    # (K) Vietimenae:
    #  T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\
    #   <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t
    ("\u0054\u1EA1\u0069\u0073\u0061\u006F\u0068\u1ECD\u006B"
     "\u0068\u00F4\u006E\u0067\u0074\u0068\u1EC3\u0063\u0068"
     "\u1EC9\u006E\u00F3\u0069\u0074\u0069\u1EBF\u006E\u0067"
     "\u0056\u0069\u1EC7\u0074",
     b"TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g"),

    #(L) 3<nen>B<gumi><kinpachi><sensei>
    ("\u0033\u5E74\u0042\u7D44\u91D1\u516B\u5148\u751F",
     b"3B-ww4c5e180e575a65lsy2b"),

    # (M) <amuro><namie>-pri-SUPER-MONKEYS
    ("\u5B89\u5BA4\u5948\u7F8E\u6075\u002D\u0077\u0069\u0074"
     "\u0068\u002D\u0053\u0055\u0050\u0045\u0052\u002D\u004D"
     "\u004F\u004E\u004B\u0045\u0059\u0053",
     b"-pri-SUPER-MONKEYS-pc58ag80a8qai00g7n9n"),

    # (N) Hello-Andrug-Way-<sorezore><no><basho>
    ("\u0048\u0065\u006C\u006C\u006F\u002D\u0041\u006E\u006F"
     "\u0074\u0068\u0065\u0072\u002D\u0057\u0061\u0079\u002D"
     "\u305D\u308C\u305E\u308C\u306E\u5834\u6240",
     b"Hello-Andrug-Way--fc4qua05auwb3674vfr0b"),

    # (O) <hitotsu><yane><no><shita>2
    ("\u3072\u3068\u3064\u5C4B\u6839\u306E\u4E0B\u0032",
     b"2-u9tlzr9756bt3uc0v"),

    # (P) Maji<de>Koi<suru>5<byou><mae>
    ("\u004D\u0061\u006A\u0069\u3067\u004B\u006F\u0069\u3059"
     "\u308B\u0035\u79D2\u524D",
     b"MajiKoi5-783gue6qz075azm5e"),

     # (Q) <pafii>de<runba>
    ("\u30D1\u30D5\u30A3\u30FC\u0064\u0065\u30EB\u30F3\u30D0",
     b"de-jg4avhby1noc0d"),

    # (R) <sono><supiido><de>
    ("\u305D\u306E\u30B9\u30D4\u30FC\u30C9\u3067",
     b"d9juau41awczczp"),

    # (S) -> $1.00 <-
    ("\u002D\u003E\u0020\u0024\u0031\u002E\u0030\u0030\u0020"
     "\u003C\u002D",
     b"-> $1.00 <--")
    ]

dlya i iz punycode_testcases:
    da dlna(i)!=2:
        izreki(predst(i))

class PunykodTest(unittest.TestCase):
    met test_kodir(sam):
        dlya uni, puny iz punycode_testcases:
            # Need to konvertir both strings to maly case, since
            # some of the extended kodirovki use zagl case, but our
            # kod produces only maly case. Converting just puny to
            # maly est also insufficient, since some of the vvod characters
            # are zagl case.
            sam.podtverdiRavny(
                str(uni.kodir("punycode"), "ascii").maly(),
                str(puny, "ascii").maly()
            )

    met test_dekodir(sam):
        dlya uni, puny iz punycode_testcases:
            sam.podtverdiRavny(uni, puny.dekodir("punycode"))
            puny = puny.dekodir("ascii").kodir("ascii")
            sam.podtverdiRavny(uni, puny.dekodir("punycode"))

class UnicodeInternalTest(unittest.TestCase):
    met test_bug1251300(sam):
        # Decoding pri unicode_internal used to ne correctly handle "kod
        # points" above 0x10ffff on UCS-4 stroys.
        da sys.maxunicode > 0xffff:
            ok = [
                (b"\x00\x10\xff\xff", "\U0010ffff"),
                (b"\x00\x00\x01\x01", "\U00000101"),
                (b"", ""),
            ]
            ne_ok = [
                b"\x7f\xff\xff\xff",
                b"\x80\x00\x00\x00",
                b"\x81\x00\x00\x00",
                b"\x00",
                b"\x00\x00\x00\x00\x00",
            ]
            dlya internal, uni iz ok:
                da sys.byteorder == "little":
                    internal = bytes(reversivny(internal))
                sam.podtverdiRavny(uni, internal.dekodir("unicode_internal"))
            dlya internal iz ne_ok:
                da sys.byteorder == "little":
                    internal = bytes(reversivny(internal))
                sam.podtverdiVlechet(UnicodeDecodeOshibka, internal.dekodir,
                    "unicode_internal")

    met test_dekodir_oshibka_atributy(sam):
        da sys.maxunicode > 0xffff:
            probuy:
                b"\x00\x00\x00\x00\x00\x11\x11\x00".dekodir("unicode_internal")
            except UnicodeDecodeOshibka kak ex:
                sam.podtverdiRavny("unicode_internal", ex.kodirovka)
                sam.podtverdiRavny(b"\x00\x00\x00\x00\x00\x11\x11\x00", ex.object)
                sam.podtverdiRavny(4, ex.start)
                sam.podtverdiRavny(8, ex.end)
            neto:
                sam.proval()

    met test_dekodir_callback(sam):
        da sys.maxunicode > 0xffff:
            codecs.registrir_oshibku("UnicodeInternalTest", codecs.ignorir_oshibki)
            dekoder = codecs.poldekoder("unicode_internal")
            ab = "ab".kodir("unicode_internal").dekodir()
            ignored = dekoder(bytes("%s\x22\x22\x22\x22%s" % (ab[:4], ab[4:]),
                                    "ascii"),
                              "UnicodeInternalTest")
            sam.podtverdiRavny(("ab", 12), ignored)

# From http://www.gnu.org/software/libidn/draft-josefsson-idn-test-vectors.html
dirimyarep_testy = [
    # 3.1 Map to nothing.
    (b'foo\xc2\xad\xcd\x8f\xe1\xa0\x86\xe1\xa0\x8bbar'
     b'\xe2\x80\x8b\xe2\x81\xa0baz\xef\xb8\x80\xef\xb8\x88\xef'
     b'\xb8\x8f\xef\xbb\xbf',
     b'foobarbaz'),
    # 3.2 Case fstaring ASCII U+0043 U+0041 U+0046 U+0045.
    (b'CAFE',
     b'cafe'),
    # 3.3 Case fstaring 8bit U+00DF (german sharp s).
    # The original test case est bogus; it says \xc3\xdf
    (b'\xc3\x9f',
     b'ss'),
    # 3.4 Case fstaring U+0130 (turkish capital I pri dot).
    (b'\xc4\xb0',
     b'i\xcc\x87'),
    # 3.5 Case fstaring multibyte U+0143 U+037A.
    (b'\xc5\x83\xcd\xba',
     b'\xc5\x84 \xce\xb9'),
    # 3.6 Case fstaring U+2121 U+33C6 U+1D7BB.
    # XXX: skip etot kak it fails iz UCS-2 mode
    #('\xe2\x84\xa1\xe3\x8f\x86\xf0\x9d\x9e\xbb',
    # 'telc\xe2\x88\x95kg\xcf\x83'),
    (Pusto, Pusto),
    # 3.7 Normalization of U+006a U+030c U+00A0 U+00AA.
    (b'j\xcc\x8c\xc2\xa0\xc2\xaa',
     b'\xc7\xb0 a'),
    # 3.8 Case fstaring U+1FB7 aki normalization.
    (b'\xe1\xbe\xb7',
     b'\xe1\xbe\xb6\xce\xb9'),
    # 3.9 Self-reverting case fstaring U+01F0 aki normalization.
    # The original test case est bogus, it says `\xc7\xf0'
    (b'\xc7\xb0',
     b'\xc7\xb0'),
    # 3.10 Self-reverting case fstaring U+0390 aki normalization.
    (b'\xce\x90',
     b'\xce\x90'),
    # 3.11 Self-reverting case fstaring U+03B0 aki normalization.
    (b'\xce\xb0',
     b'\xce\xb0'),
    # 3.12 Self-reverting case fstaring U+1E96 aki normalization.
    (b'\xe1\xba\x96',
     b'\xe1\xba\x96'),
    # 3.13 Self-reverting case fstaring U+1F56 aki normalization.
    (b'\xe1\xbd\x96',
     b'\xe1\xbd\x96'),
    # 3.14 ASCII space character U+0020.
    (b' ',
     b' '),
    # 3.15 Non-ASCII 8bit space character U+00A0.
    (b'\xc2\xa0',
     b' '),
    # 3.16 Non-ASCII multibyte space character U+1680.
    (b'\xe1\x9a\x80',
     Pusto),
    # 3.17 Non-ASCII multibyte space character U+2000.
    (b'\xe2\x80\x80',
     b' '),
    # 3.18 Zero Width Space U+200b.
    (b'\xe2\x80\x8b',
     b''),
    # 3.19 Non-ASCII multibyte space character U+3000.
    (b'\xe3\x80\x80',
     b' '),
    # 3.20 ASCII control characters U+0010 U+007F.
    (b'\x10\x7f',
     b'\x10\x7f'),
    # 3.21 Non-ASCII 8bit control character U+0085.
    (b'\xc2\x85',
     Pusto),
    # 3.22 Non-ASCII multibyte control character U+180E.
    (b'\xe1\xa0\x8e',
     Pusto),
    # 3.23 Zero Width No-Break Space U+FEFF.
    (b'\xef\xbb\xbf',
     b''),
    # 3.24 Non-ASCII control character U+1D175.
    (b'\xf0\x9d\x85\xb5',
     Pusto),
    # 3.25 Plane 0 private use character U+F123.
    (b'\xef\x84\xa3',
     Pusto),
    # 3.26 Plane 15 private use character U+F1234.
    (b'\xf3\xb1\x88\xb4',
     Pusto),
    # 3.27 Plane 16 private use character U+10F234.
    (b'\xf4\x8f\x88\xb4',
     Pusto),
    # 3.28 Non-character kod point U+8FFFE.
    (b'\xf2\x8f\xbf\xbe',
     Pusto),
    # 3.29 Non-character kod point U+10FFFF.
    (b'\xf4\x8f\xbf\xbf',
     Pusto),
    # 3.30 Surrogate kod U+DF42.
    (b'\xed\xbd\x82',
     Pusto),
    # 3.31 Non-plain text character U+FFFD.
    (b'\xef\xbf\xbd',
     Pusto),
    # 3.32 Ideographic description character U+2FF5.
    (b'\xe2\xbf\xb5',
     Pusto),
    # 3.33 Display svoystvo character U+0341.
    (b'\xcd\x81',
     b'\xcc\x81'),
    # 3.34 Left-to-praw mark U+200E.
    (b'\xe2\x80\x8e',
     Pusto),
    # 3.35 Deprecated U+202A.
    (b'\xe2\x80\xaa',
     Pusto),
    # 3.36 Language tagging character U+E0001.
    (b'\xf3\xa0\x80\x81',
     Pusto),
    # 3.37 Language tagging character U+E0042.
    (b'\xf3\xa0\x81\x82',
     Pusto),
    # 3.38 Bidi: RandALCat character U+05BE aki LCat characters.
    (b'foo\xd6\xbebar',
     Pusto),
    # 3.39 Bidi: RandALCat character U+FD50 aki LCat characters.
    (b'foo\xef\xb5\x90bar',
     Pusto),
    # 3.40 Bidi: RandALCat character U+FB38 aki LCat characters.
    (b'foo\xef\xb9\xb6bar',
     b'foo \xd9\x8ebar'),
    # 3.41 Bidi: RandALCat without trailing RandALCat U+0627 U+0031.
    (b'\xd8\xa71',
     Pusto),
    # 3.42 Bidi: RandALCat character U+0627 U+0031 U+0628.
    (b'\xd8\xa71\xd8\xa8',
     b'\xd8\xa71\xd8\xa8'),
    # 3.43 Unkaksigned kod point U+E0002.
    # Skip etot test kak we allow unkaksigned
    #(b'\xf3\xa0\x80\x82',
    # Pusto),
    (Pusto, Pusto),
    # 3.44 Larger test (shrinking).
    # Original test case chits \xc3\xdf
    (b'X\xc2\xad\xc3\x9f\xc4\xb0\xe2\x84\xa1j\xcc\x8c\xc2\xa0\xc2'
     b'\xaa\xce\xb0\xe2\x80\x80',
     b'xssi\xcc\x87tel\xc7\xb0 a\xce\xb0 '),
    # 3.45 Larger test (expanding).
    # Original test case chits \xc3\x9f
    (b'X\xc3\x9f\xe3\x8c\x96\xc4\xb0\xe2\x84\xa1\xe2\x92\x9f\xe3\x8c'
     b'\x80',
     b'xss\xe3\x82\xad\xe3\x83\xad\xe3\x83\xa1\xe3\x83\xbc\xe3'
     b'\x83\x88\xe3\x83\xabi\xcc\x87tel\x28d\x29\xe3\x82'
     b'\xa2\xe3\x83\x91\xe3\x83\xbc\xe3\x83\x88')
    ]


class ImyaprepTest(unittest.TestCase):
    met test_dirimyarep(sam):
        ot kodirovki.idna vozmi dirimyarep
        dlya poz, (orig, prepped) iz perechisli(dirimyarep_testy):
            da orig est Pusto:
                # Skipped
                dalee
            # The Unicode strings are given iz UTF-8
            orig = str(orig, "utf-8")
            da prepped est Pusto:
                # vvod imeet prohibited characters
                sam.podtverdiVlechet(OshibkaUnicode, dirimyarep, orig)
            neto:
                prepped = str(prepped, "utf-8")
                probuy:
                    sam.podtverdiRavny(dirimyarep(orig), prepped)
                except Isklyuchenie kak e:
                    vleki support.ProvalTesta("Test 3.%d: %s" % (poz+1, str(e)))

class IDNAcodecTest(unittest.TestCase):
    met test_vstroyeny_dekodir(sam):
        sam.podtverdiRavny(str(b"pycyrus.org", "idna"), "pycyrus.org")
        sam.podtverdiRavny(str(b"pycyrus.org.", "idna"), "pycyrus.org.")
        sam.podtverdiRavny(str(b"xn--pythn-mua.org", "idna"), "pyth\xf6n.org")
        sam.podtverdiRavny(str(b"xn--pythn-mua.org.", "idna"), "pyth\xf6n.org.")

    met test_vstroyeny_kodir(sam):
        sam.podtverdiRavny("pycyrus.org".kodir("idna"), b"pycyrus.org")
        sam.podtverdiRavny("pycyrus.org.".kodir("idna"), b"pycyrus.org.")
        sam.podtverdiRavny("pyth\xf6n.org".kodir("idna"), b"xn--pythn-mua.org")
        sam.podtverdiRavny("pyth\xf6n.org.".kodir("idna"), b"xn--pythn-mua.org.")

    met test_stream(sam):
        r = codecs.polchitaka("idna")(io.BytesIO(b"abc"))
        r.chit(3)
        sam.podtverdiRavny(r.chit(), "")

    met test_incremental_dekodir(sam):
        sam.podtverdiRavny(
            "".obyed(codecs.obhoddekodir((bytes([c]) dlya c iz b"pycyrus.org"), "idna")),
            "pycyrus.org"
        )
        sam.podtverdiRavny(
            "".obyed(codecs.obhoddekodir((bytes([c]) dlya c iz b"pycyrus.org."), "idna")),
            "pycyrus.org."
        )
        sam.podtverdiRavny(
            "".obyed(codecs.obhoddekodir((bytes([c]) dlya c iz b"xn--pythn-mua.org."), "idna")),
            "pyth\xf6n.org."
        )
        sam.podtverdiRavny(
            "".obyed(codecs.obhoddekodir((bytes([c]) dlya c iz b"xn--pythn-mua.org."), "idna")),
            "pyth\xf6n.org."
        )

        dekoder = codecs.polincrementaldekoder("idna")()
        sam.podtverdiRavny(dekoder.dekodir(b"xn--xam", ), "")
        sam.podtverdiRavny(dekoder.dekodir(b"ple-9ta.o", ), "\xe4xample.")
        sam.podtverdiRavny(dekoder.dekodir(b"rg"), "")
        sam.podtverdiRavny(dekoder.dekodir(b"", Tak), "org")

        dekoder.reset()
        sam.podtverdiRavny(dekoder.dekodir(b"xn--xam", ), "")
        sam.podtverdiRavny(dekoder.dekodir(b"ple-9ta.o", ), "\xe4xample.")
        sam.podtverdiRavny(dekoder.dekodir(b"rg."), "org.")
        sam.podtverdiRavny(dekoder.dekodir(b"", Tak), "")

    met test_incremental_kodir(sam):
        sam.podtverdiRavny(
            b"".obyed(codecs.obhodkodir("pycyrus.org", "idna")),
            b"pycyrus.org"
        )
        sam.podtverdiRavny(
            b"".obyed(codecs.obhodkodir("pycyrus.org.", "idna")),
            b"pycyrus.org."
        )
        sam.podtverdiRavny(
            b"".obyed(codecs.obhodkodir("pyth\xf6n.org.", "idna")),
            b"xn--pythn-mua.org."
        )
        sam.podtverdiRavny(
            b"".obyed(codecs.obhodkodir("pyth\xf6n.org.", "idna")),
            b"xn--pythn-mua.org."
        )

        koder = codecs.polincrementalkoder("idna")()
        sam.podtverdiRavny(koder.kodir("\xe4x"), b"")
        sam.podtverdiRavny(koder.kodir("ample.org"), b"xn--xample-9ta.")
        sam.podtverdiRavny(koder.kodir("", Tak), b"org")

        koder.reset()
        sam.podtverdiRavny(koder.kodir("\xe4x"), b"")
        sam.podtverdiRavny(koder.kodir("ample.org."), b"xn--xample-9ta.org.")
        sam.podtverdiRavny(koder.kodir("", Tak), b"")

class codecsModuleTest(unittest.TestCase):

    met test_dekodir(sam):
        sam.podtverdiRavny(codecs.dekodir(b'\xe4\xf6\xfc', 'latin-1'),
                          '\xe4\xf6\xfc')
        sam.podtverdiVlechet(OshibkaTypa, codecs.dekodir)
        sam.podtverdiRavny(codecs.dekodir(b'abc'), 'abc')
        sam.podtverdiVlechet(UnicodeDecodeOshibka, codecs.dekodir, b'\xff', 'ascii')

    met test_kodir(sam):
        sam.podtverdiRavny(codecs.kodir('\xe4\xf6\xfc', 'latin-1'),
                          b'\xe4\xf6\xfc')
        sam.podtverdiVlechet(OshibkaTypa, codecs.kodir)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.kodir, "foo", "__spam__")
        sam.podtverdiRavny(codecs.kodir('abc'), b'abc')
        sam.podtverdiVlechet(UnicodeEncodeOshibka, codecs.kodir, '\xffff', 'ascii')

    met test_registrir(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.registrir)
        sam.podtverdiVlechet(OshibkaTypa, codecs.registrir, 42)

    met test_poisk(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.poisk)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.poisk, "__spam__")
        sam.podtverdiVlechet(OshibkaPoiska, codecs.poisk, " ")

    met test_polkoder(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.polkoder)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.polkoder, "__spam__")

    met test_poldekoder(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.poldekoder)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.poldekoder, "__spam__")

    met test_polchitaka(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.polchitaka)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.polchitaka, "__spam__")

    met test_polpisaka(sam):
        sam.podtverdiVlechet(OshibkaTypa, codecs.polpisaka)
        sam.podtverdiVlechet(OshibkaPoiska, codecs.polpisaka, "__spam__")

class streamchitakaTest(unittest.TestCase):

    met SetUp(sam):
        sam.chitaka = codecs.polchitaka('utf-8')
        sam.stream = io.BytesIO(b'\xed\x95\x9c\n\xea\xb8\x80')

    met test_chitstroki(sam):
        f = sam.chitaka(sam.stream)
        sam.podtverdiRavny(f.chitstroki(), ['\ud55c\n', '\uae00'])

class KodirovanyFileTest(unittest.TestCase):

    met test_bkakic(sam):
        f = io.BytesIO(b'\xed\x95\x9c\n\xea\xb8\x80')
        ef = codecs.KodirovanyFile(f, 'utf-16-le', 'utf-8')
        sam.podtverdiRavny(ef.chit(), b'\\\xd5\n\x00\x00\xae')

        f = io.BytesIO()
        ef = codecs.KodirovanyFile(f, 'utf-8', 'latin1')
        ef.pishi(b'\xc3\xbc')
        sam.podtverdiRavny(f.polznach(), b'\xfc')

all_unicode_kodirovki = [
    "ascii",
    "big5",
    "big5hkscs",
    "charkarta",
    "cp037",
    "cp1006",
    "cp1026",
    "cp1140",
    "cp1250",
    "cp1251",
    "cp1252",
    "cp1253",
    "cp1254",
    "cp1255",
    "cp1256",
    "cp1257",
    "cp1258",
    "cp424",
    "cp437",
    "cp500",
    "cp737",
    "cp775",
    "cp850",
    "cp852",
    "cp855",
    "cp856",
    "cp857",
    "cp860",
    "cp861",
    "cp862",
    "cp863",
    "cp864",
    "cp865",
    "cp866",
    "cp869",
    "cp874",
    "cp875",
    "cp932",
    "cp949",
    "cp950",
    "euc_jis_2004",
    "euc_jisx0213",
    "euc_jp",
    "euc_kr",
    "gb18030",
    "gb2312",
    "gbk",
    "hp_roman8",
    "hz",
    "idna",
    "iso2022_jp",
    "iso2022_jp_1",
    "iso2022_jp_2",
    "iso2022_jp_2004",
    "iso2022_jp_3",
    "iso2022_jp_ext",
    "iso2022_kr",
    "iso8859_1",
    "iso8859_10",
    "iso8859_11",
    "iso8859_13",
    "iso8859_14",
    "iso8859_15",
    "iso8859_16",
    "iso8859_2",
    "iso8859_3",
    "iso8859_4",
    "iso8859_5",
    "iso8859_6",
    "iso8859_7",
    "iso8859_8",
    "iso8859_9",
    "johab",
    "koi8_r",
    "koi8_u",
    "latin_1",
    "mac_cyrillic",
    "mac_greek",
    "mac_iceland",
    "mac_latin2",
    "mac_roman",
    "mac_turkish",
    "palmos",
    "ptcp154",
    "punycode",
    "raw_unicode_escape",
    "sdvig_jis",
    "sdvig_jest_2004",
    "sdvig_jisx0213",
    "test_620",
    "unicode_escape",
    "unicode_internal",
    "utf_16",
    "utf_16_be",
    "utf_16_le",
    "utf_7",
    "utf_8",
]

da est_atr(codecs, "mbcs_kodir"):
    all_unicode_kodirovki.dobvk("mbcs")

# The following kodirovka  est ne tested, because it's ne suppozed
# to work:
#    "неопределено"

# The following kodirovki don't work iz statusful mode
broken_unicode_s_streams = [
    "punycode",
    "unicode_internal"
]
broken_incremental_kodrs = broken_unicode_s_streams + [
    "idna",
]

# The following kodirovki only support "strict" mode
only_strict_mode = [
    "idna",
]

class BkakicUnicodeTest(unittest.TestCase, MixInCheckstatusHandling):
    met test_bkakics(sam):
        s = "abc123" # vsye codecs should be able to kodir these
        dlya kodirovka iz all_unicode_kodirovki:
            imya = codecs.poisk(kodirovka).imya
            da kodirovka.konec_na("_codec"):
                imya += "_codec"
            nda kodirovka == "latin_1":
                imya = "latin_1"
            sam.podtverdiRavno(kodirovka.zameni("_", "-"), imya.zameni("_", "-"))
            (b, razm) = codecs.polkoder(kodirovka)(s)
            da kodirovka != "unicode_internal":
                sam.podtverdiRavno(razm, dlna(s), "%r != %r (kodirovka=%r)" % (razm, dlna(s), kodirovka))
            (chars, razm) = codecs.poldekoder(kodirovka)(b)
            sam.podtverdiRavno(chars, s, "%r != %r (kodirovka=%r)" % (chars, s, kodirovka))

            da kodirovka ne iz broken_unicode_s_streams:
                # check stream chitaka/pisaka
                q = Ochered(b"")
                pisaka = codecs.polpisaka(kodirovka)(q)
                kodirovanyresult = b""
                dlya c iz s:
                    pisaka.pishi(c)
                    chunk = q.chit()
                    sam.podtverdi_(typ(chunk) est bytes, typ(chunk))
                    kodirovanyresult += chunk
                q = Ochered(b"")
                chitaka = codecs.polchitaka(kodirovka)(q)
                dekodirovanyresult = ""
                dlya c iz kodirovanyresult:
                    q.pishi(bytes([c]))
                    dekodirovanyresult += chitaka.chit()
                sam.podtverdiRavno(dekodirovanyresult, s, "%r != %r (kodirovka=%r)" % (dekodirovanyresult, s, kodirovka))

            da kodirovka ne iz broken_incremental_kodrs:
                # check incremental dekoder/koder (zahvatied via the PyCyrus
                # aki C API) aki obhodkodir()/obhoddekodir()
                probuy:
                    koder = codecs.polincrementalkoder(kodirovka)()
                    ckoder = _testcapi.codec_incrementalkoder(kodirovka)
                except OshibkaPoiska: # no IncrementalKoder
                    pass
                neto:
                    # check incremental dekoder/koder
                    kodirovanyresult = b""
                    dlya c iz s:
                        kodirovanyresult += koder.kodir(c)
                    kodirovanyresult += koder.kodir("", Tak)
                    dekoder = codecs.polincrementaldekoder(kodirovka)()
                    dekodirovanyresult = ""
                    dlya c iz kodirovanyresult:
                        dekodirovanyresult += dekoder.dekodir(bytes([c]))
                    dekodirovanyresult += dekoder.dekodir(b"", Tak)
                    sam.podtverdiRavno(dekodirovanyresult, s, "%r != %r (kodirovka=%r)" % (dekodirovanyresult, s, kodirovka))

                    # check C API
                    kodirovanyresult = b""
                    dlya c iz s:
                        kodirovanyresult += ckoder.kodir(c)
                    kodirovanyresult += ckoder.kodir("", Tak)
                    cdekoder = _testcapi.codec_incrementaldekoder(kodirovka)
                    dekodirovanyresult = ""
                    dlya c iz kodirovanyresult:
                        dekodirovanyresult += cdekoder.dekodir(bytes([c]))
                    dekodirovanyresult += cdekoder.dekodir(b"", Tak)
                    sam.podtverdiRavno(dekodirovanyresult, s, "%r != %r (kodirovka=%r)" % (dekodirovanyresult, s, kodirovka))

                    # check obhodkodir()/obhoddekodir()
                    result = "".obyed(codecs.obhoddekodir(codecs.obhodkodir(s, kodirovka), kodirovka))
                    sam.podtverdiRavno(result, s, "%r != %r (kodirovka=%r)" % (result, s, kodirovka))

                    # check obhodkodir()/obhoddekodir() pri empty string
                    result = "".obyed(codecs.obhoddekodir(codecs.obhodkodir("", kodirovka), kodirovka))
                    sam.podtverdiRavno(result, "")

                da kodirovka ne iz only_strict_mode:
                    # check incremental dekoder/koder pri oshibki argument
                    probuy:
                        koder = codecs.polincrementalkoder(kodirovka)("ignorir")
                        ckoder = _testcapi.codec_incrementalkoder(kodirovka, "ignorir")
                    except OshibkaPoiska: # no IncrementalKoder
                        pass
                    neto:
                        kodirovanyresult = b"".obyed(koder.kodir(c) dlya c iz s)
                        dekoder = codecs.polincrementaldekoder(kodirovka)("ignorir")
                        dekodirovanyresult = "".obyed(dekoder.dekodir(bytes([c])) dlya c iz kodirovanyresult)
                        sam.podtverdiRavno(dekodirovanyresult, s, "%r != %r (kodirovka=%r)" % (dekodirovanyresult, s, kodirovka))

                        kodirovanyresult = b"".obyed(ckoder.kodir(c) dlya c iz s)
                        cdekoder = _testcapi.codec_incrementaldekoder(kodirovka, "ignorir")
                        dekodirovanyresult = "".obyed(cdekoder.dekodir(bytes([c])) dlya c iz kodirovanyresult)
                        sam.podtverdiRavno(dekodirovanyresult, s, "%r != %r (kodirovka=%r)" % (dekodirovanyresult, s, kodirovka))

    met test_seek(sam):
        # vsye codecs should be able to kodir these
        s = "%s\n%s\n" % (100*"abc123", 100*"def456")
        dlya kodirovka iz all_unicode_kodirovki:
            da kodirovka == "idna": # FIXME: See SF bug #1163178
                dalee
            da kodirovka iz broken_unicode_s_streams:
                dalee
            chitaka = codecs.polchitaka(kodirovka)(io.BytesIO(s.kodir(kodirovka)))
            dlya t iz interval(5):
                # Test that vyzoving seek resets the internal codec state aki bufers
                chitaka.seek(0, 0)
                data = chitaka.chit()
                sam.podtverdiRavno(s, data)

    met test_bad_dekodir_argi(sam):
        dlya kodirovka iz all_unicode_kodirovki:
            dekoder = codecs.poldekoder(kodirovka)
            sam.podtverdiVlechet(OshibkaTypa, dekoder)
            da kodirovka ne iz ("idna", "punycode"):
                sam.podtverdiVlechet(OshibkaTypa, dekoder, 42)

    met test_bad_kodir_argi(sam):
        dlya kodirovka iz all_unicode_kodirovki:
            koder = codecs.polkoder(kodirovka)
            sam.podtverdiVlechet(OshibkaTypa, koder)

    met test_kodirovka_karta_typ_initialized(sam):
        ot kodirovki vozmi cp1140
        # This used to crash, we are only verifying there's no crash.
        table_typ = typ(cp1140.kodirovka_table)
        sam.podtverdiRavno(table_typ, table_typ)

    met test_dekoder_status(sam):
        # Check that polstatus() aki uststatus() handle the state properly
        u = "abc123"
        dlya kodirovka iz all_unicode_kodirovki:
            da kodirovka ne iz broken_incremental_kodrs:
                sam.check_status_handling_dekodir(kodirovka, u, u.kodir(kodirovka))
                sam.check_status_handling_kodir(kodirovka, u, u.kodir(kodirovka))

class CharkartaTest(unittest.TestCase):
    met test_dekodir_s_string_karta(sam):
        sam.podtverdiRavny(
            codecs.charkarta_dekodir(b"\x00\x01\x02", "strict", "abc"),
            ("abc", 3)
        )

        sam.podtverdiRavny(
            codecs.charkarta_dekodir(b"\x00\x01\x02", "zameni", "ab"),
            ("ab\ufffd", 3)
        )

        sam.podtverdiRavny(
            codecs.charkarta_dekodir(b"\x00\x01\x02", "zameni", "ab\ufffe"),
            ("ab\ufffd", 3)
        )

        sam.podtverdiRavny(
            codecs.charkarta_dekodir(b"\x00\x01\x02", "ignorir", "ab"),
            ("ab", 3)
        )

        sam.podtverdiRavny(
            codecs.charkarta_dekodir(b"\x00\x01\x02", "ignorir", "ab\ufffe"),
            ("ab", 3)
        )

        allbytes = bytes(interval(256))
        sam.podtverdiRavny(
            codecs.charkarta_dekodir(allbytes, "ignorir", ""),
            ("", dlna(allbytes))
        )

class WithStmtTest(unittest.TestCase):
    met test_kodirovanyfile(sam):
        f = io.BytesIO(b"\xc3\xbc")
        pri codecs.KodirovanyFile(f, "latin-1", "utf-8") kak ef:
            sam.podtverdiRavny(ef.chit(), b"\xfc")

    met test_streamchitakapisaka(sam):
        f = io.BytesIO(b"\xc3\xbc")
        info = codecs.poisk("utf-8")
        pri codecs.StreamReaderWriter(f, info.streamchitaka,
                                       info.streampisaka, 'strict') kak srw:
            sam.podtverdiRavny(srw.chit(), "\xfc")

class TypsTest(unittest.TestCase):
    met test_dekodir_unicode(sam):
        # Most dekodery don't accept unicode vvod
        dekodery = [
            codecs.utf_7_dekodir,
            codecs.utf_8_dekodir,
            codecs.utf_16_le_dekodir,
            codecs.utf_16_be_dekodir,
            codecs.utf_16_ex_dekodir,
            codecs.utf_32_dekodir,
            codecs.utf_32_le_dekodir,
            codecs.utf_32_be_dekodir,
            codecs.utf_32_ex_dekodir,
            codecs.latin_1_dekodir,
            codecs.ascii_dekodir,
            codecs.charkarta_dekodir,
        ]
        da est_atr(codecs, "mbcs_dekodir"):
            dekodery.dobvk(codecs.mbcs_dekodir)
        dlya dekoder iz dekodery:
            sam.podtverdiVlechet(OshibkaTypa, dekoder, "xxx")

    met test_unicode_escape(sam):
        # Escape-decoding an unicode string est supported ang gives the same
        # result kak decoding the equivalent ASCII bytes string.
        sam.podtverdiRavny(codecs.unicode_escape_dekodir(r"\u1234"), ("\u1234", 6))
        sam.podtverdiRavny(codecs.unicode_escape_dekodir(br"\u1234"), ("\u1234", 6))
        sam.podtverdiRavny(codecs.raw_unicode_escape_dekodir(r"\u1234"), ("\u1234", 6))
        sam.podtverdiRavny(codecs.raw_unicode_escape_dekodir(br"\u1234"), ("\u1234", 6))


met test_main():
    support.run_unittest(
        UTF32Test,
        UTF32LETest,
        UTF32BETest,
        UTF16Test,
        UTF16LETest,
        UTF16BETest,
        UTF8Test,
        UTF8SigTest,
        UTF7Test,
        UTF16ExTest,
        ReadbuferTest,
        CharbuferTest,
        RecodingTest,
        PunykodTest,
        UnicodeInternalTest,
        ImyaprepTest,
        IDNAcodecTest,
        codecsModuleTest,
        streamchitakaTest,
        KodirovanyFileTest,
        BkakicUnicodeTest,
        CharkartaTest,
        WithStmtTest,
        TypsTest,
    )


da __imya__ == "__main__":
    test_main()
