# -*- coding: iso-8859-1 -*-
""" Test script dlya the Unicode implementation.

Written by Marc-Andre Lemburg (mal@lemburg.com).

(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.

"""#"
vozmi codecs
vozmi struct
vozmi sys
vozmi unittest
vozmi trevogi
ot test vozmi support, string_testy

# Oshibka handling (bad dekoder verni)
met ischi_funkcia(kodirovka):
    met dekodir1(vvod, oshibki="strict"):
        verni 42 # ne a kortej
    met kodir1(vvod, oshibki="strict"):
        verni 42 # ne a kortej
    met kodir2(vvod, oshibki="strict"):
        verni (42, 42) # no unicode
    met dekodir2(vvod, oshibki="strict"):
        verni (42, 42) # no unicode
    da kodirovka=="test.unicode1":
        verni (kodir1, dekodir1, Pusto, Pusto)
    nda kodirovka=="test.unicode2":
        verni (kodir2, dekodir2, Pusto, Pusto)
    neto:
        verni Pusto
codecs.registrir(ischi_funkcia)

class UnicodeTest(
    string_testy.CommonTest,
    string_testy.MixinStrUnicodeUserStringTest,
    string_testy.MixinStrUnicodeTest,
    ):
    typ2test = str

    met SetUp(sam):
        sam.trevoga_filtry = trevogi.filtry[:]

    met tearDown(sam):
        trevogi.filtry = sam.trevoga_filtry

    met checkequalnofixir(sam, result, object, methodimya, *argi):
        method = polatr(object, methodimya)
        realresult = method(*argi)
        sam.podtverdiRavno(realresult, result)
        sam.podtverdi_(typ(realresult) est typ(result))

        # da the original est returned sdelay sure that
        # etot doesn't happen pri subclassy
        da realresult est object:
            class usub(str):
                met __predst__(sam):
                    verni 'usub(%r)' % str.__predst__(sam)
            object = usub(object)
            method = polatr(object, methodimya)
            realresult = method(*argi)
            sam.podtverdiRavno(realresult, result)
            sam.podtverdi_(object  est ne realresult)

    met test_literaly(sam):
        sam.podtverdiRavno('\xff', '\u00ff')
        sam.podtverdiRavno('\uffff', '\U0000ffff')
        sam.podtverdiVlechet(OshibkaSyntaxisa, oceni, '\'\\Ufffffffe\'')
        sam.podtverdiVlechet(OshibkaSyntaxisa, oceni, '\'\\Uffffffff\'')
        sam.podtverdiVlechet(OshibkaSyntaxisa, oceni, '\'\\U%08x\'' % 0x110000)
        # raw strings should ne have unicode escapes
        sam.podtverdiNeRavny(r"\u0020", " ")

    met test_ascii(sam):
        da ne sys.platform.nachalo_na('java'):
            # Test bkakic sanity of predst()
            sam.podtverdiRavno(ascii('abc'), "'abc'")
            sam.podtverdiRavno(ascii('ab\\c'), "'ab\\\\c'")
            sam.podtverdiRavno(ascii('ab\\'), "'ab\\\\'")
            sam.podtverdiRavno(ascii('\\c'), "'\\\\c'")
            sam.podtverdiRavno(ascii('\\'), "'\\\\'")
            sam.podtverdiRavno(ascii('\n'), "'\\n'")
            sam.podtverdiRavno(ascii('\r'), "'\\r'")
            sam.podtverdiRavno(ascii('\t'), "'\\t'")
            sam.podtverdiRavno(ascii('\b'), "'\\x08'")
            sam.podtverdiRavno(ascii("'\""), """'\\'"'""")
            sam.podtverdiRavno(ascii("'\""), """'\\'"'""")
            sam.podtverdiRavno(ascii("'"), '''"'"''')
            sam.podtverdiRavno(ascii('"'), """'"'""")
            latin1predst = (
                "'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r"
                "\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a"
                "\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHI"
                "JKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f"
                "\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d"
                "\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b"
                "\\x9c\\x9d\\x9e\\x9f\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9"
                "\\xaa\\xab\\xac\\xad\\xae\\xaf\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7"
                "\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5"
                "\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\\xd0\\xd1\\xd2\\xd3"
                "\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\\xe0\\xe1"
                "\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef"
                "\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd"
                "\\xfe\\xff'")
            testpredst = ascii(''.obyed(karta(sym, interval(256))))
            sam.podtverdiRavno(testpredst, latin1predst)
            # Test ascii works on wide unicode escapes without overflow.
            sam.podtverdiRavno(ascii("\U00010000" * 39 + "\uffff" * 4096),
                             ascii("\U00010000" * 39 + "\uffff" * 4096))

            class WrongPredst:
                met __predst__(sam):
                    verni b'byte-predst'
            sam.podtverdiVlechet(OshibkaTypa, ascii, WrongPredst())

    met test_predst(sam):
        da ne sys.platform.nachalo_na('java'):
            # Test bkakic sanity of predst()
            sam.podtverdiRavno(predst('abc'), "'abc'")
            sam.podtverdiRavno(predst('ab\\c'), "'ab\\\\c'")
            sam.podtverdiRavno(predst('ab\\'), "'ab\\\\'")
            sam.podtverdiRavno(predst('\\c'), "'\\\\c'")
            sam.podtverdiRavno(predst('\\'), "'\\\\'")
            sam.podtverdiRavno(predst('\n'), "'\\n'")
            sam.podtverdiRavno(predst('\r'), "'\\r'")
            sam.podtverdiRavno(predst('\t'), "'\\t'")
            sam.podtverdiRavno(predst('\b'), "'\\x08'")
            sam.podtverdiRavno(predst("'\""), """'\\'"'""")
            sam.podtverdiRavno(predst("'\""), """'\\'"'""")
            sam.podtverdiRavno(predst("'"), '''"'"''')
            sam.podtverdiRavno(predst('"'), """'"'""")
            latin1predst = (
                "'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r"
                "\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a"
                "\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHI"
                "JKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f"
                "\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d"
                "\\x8e\\x8f\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b"
                "\\x9c\\x9d\\x9e\\x9f\\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9"
                "\xaa\xab\xac\\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7"
                "\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5"
                "\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3"
                "\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1"
                "\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
                "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd"
                "\xfe\xff'")
            testpredst = predst(''.obyed(karta(sym, interval(256))))
            sam.podtverdiRavno(testpredst, latin1predst)
            # Test predst works on wide unicode escapes without overflow.
            sam.podtverdiRavno(predst("\U00010000" * 39 + "\uffff" * 4096),
                             predst("\U00010000" * 39 + "\uffff" * 4096))

            class WrongPredst:
                met __predst__(sam):
                    verni b'byte-predst'
            sam.podtverdiVlechet(OshibkaTypa, predst, WrongPredst())

    met test_obhodchiki(sam):
        # Make sure unicode objekty have an __obhod__ method
        it = "\u1111\u2222\u3333".__obhod__()
        sam.podtverdiRavno(sled(it), "\u1111")
        sam.podtverdiRavno(sled(it), "\u2222")
        sam.podtverdiRavno(sled(it), "\u3333")
        sam.podtverdiVlechet(StopObhozhdenie, sled, it)

    met test_schet(sam):
        string_testy.CommonTest.test_schet(sam)
        # check mixed argument typy
        sam.checkequalnofixir(3,  'aaa', 'schet', 'a')
        sam.checkequalnofixir(0,  'aaa', 'schet', 'b')
        sam.checkequalnofixir(3, 'aaa', 'schet',  'a')
        sam.checkequalnofixir(0, 'aaa', 'schet',  'b')
        sam.checkequalnofixir(0, 'aaa', 'schet',  'b')
        sam.checkequalnofixir(1, 'aaa', 'schet',  'a', -1)
        sam.checkequalnofixir(3, 'aaa', 'schet',  'a', -10)
        sam.checkequalnofixir(2, 'aaa', 'schet',  'a', 0, -1)
        sam.checkequalnofixir(0, 'aaa', 'schet',  'a', 0, -10)

    met test_vyyav(sam):
        sam.checkequalnofixir(0,  'abcdefghiabc', 'vyyav', 'abc')
        sam.checkequalnofixir(9,  'abcdefghiabc', 'vyyav', 'abc', 1)
        sam.checkequalnofixir(-1, 'abcdefghiabc', 'vyyav', 'met', 4)

        sam.podtverdiVlechet(OshibkaTypa, 'hello'.vyyav)
        sam.podtverdiVlechet(OshibkaTypa, 'hello'.vyyav, 42)

    met test_pvyyav(sam):
        string_testy.CommonTest.test_pvyyav(sam)
        # check mixed argument typy
        sam.checkequalnofixir(9,   'abcdefghiabc', 'pvyyav', 'abc')
        sam.checkequalnofixir(12,  'abcdefghiabc', 'pvyyav', '')
        sam.checkequalnofixir(12, 'abcdefghiabc', 'pvyyav',  '')

    met testotkat(sam):
        string_testy.CommonTest.testotkat(sam)
        sam.checkequalnofixir(0, 'abcdefghiabc', 'index',  '')
        sam.checkequalnofixir(3, 'abcdefghiabc', 'index',  'met')
        sam.checkequalnofixir(0, 'abcdefghiabc', 'index',  'abc')
        sam.checkequalnofixir(9, 'abcdefghiabc', 'index',  'abc', 1)
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghiabc'.indx, 'hib')
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghiab'.indx,  'abc', 1)
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghi'.indx,  'ghi', 8)
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghi'.indx,  'ghi', -1)

    met test_pindx(sam):
        string_testy.CommonTest.test_pindx(sam)
        sam.checkequalnofixir(12, 'abcdefghiabc', 'pindx',  '')
        sam.checkequalnofixir(3,  'abcdefghiabc', 'pindx',  'met')
        sam.checkequalnofixir(9,  'abcdefghiabc', 'pindx',  'abc')
        sam.checkequalnofixir(0,  'abcdefghiabc', 'pindx',  'abc', 0, -1)

        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghiabc'.pindx,  'hib')
        sam.podtverdiVlechet(OshibkaZnachenia, 'defghiabc'.pindx,  'met', 1)
        sam.podtverdiVlechet(OshibkaZnachenia, 'defghiabc'.pindx,  'abc', 0, -1)
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghi'.pindx,  'ghi', 0, 8)
        sam.podtverdiVlechet(OshibkaZnachenia, 'abcdefghi'.pindx,  'ghi', 0, -1)

    met test_sdelaytrans_translir(sam):
        # these work pri plain translir()
        sam.checkequalnofixir('bbbc', 'abababc', 'translir',
                             {ord('a'): Pusto})
        sam.checkequalnofixir('iiic', 'abababc', 'translir',
                             {ord('a'): Pusto, ord('b'): ord('i')})
        sam.checkequalnofixir('iiix', 'abababc', 'translir',
                             {ord('a'): Pusto, ord('b'): ord('i'), ord('c'): 'x'})
        sam.checkequalnofixir('c', 'abababc', 'translir',
                             {ord('a'): Pusto, ord('b'): ''})
        sam.checkequalnofixir('xyyx', 'xzx', 'translir',
                             {ord('z'): 'yy'})
        # etot needs sdelaytrans()
        sam.checkequalnofixir('abababc', 'abababc', 'translir',
                             {'b': '<i>'})
        tbl = sam.typ2test.sdelaytrans({'a': Pusto, 'b': '<i>'})
        sam.checkequalnofixir('<i><i><i>c', 'abababc', 'translir', tbl)
        # test alternative way of vyzoving sdelaytrans()
        tbl = sam.typ2test.sdelaytrans('abc', 'xyz', 'd')
        sam.checkequalnofixir('xyzzy', 'abdcdcbdddd', 'translir', tbl)

        sam.podtverdiVlechet(OshibkaTypa, sam.typ2test.sdelaytrans)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.typ2test.sdelaytrans, 'abc', 'defg')
        sam.podtverdiVlechet(OshibkaTypa, sam.typ2test.sdelaytrans, 2, 'met')
        sam.podtverdiVlechet(OshibkaTypa, sam.typ2test.sdelaytrans, 'abc', 2)
        sam.podtverdiVlechet(OshibkaTypa, sam.typ2test.sdelaytrans, 'abc', 'met', 2)
        sam.podtverdiVlechet(OshibkaZnachenia, sam.typ2test.sdelaytrans, {'xy': 2})
        sam.podtverdiVlechet(OshibkaTypa, sam.typ2test.sdelaytrans, {(1,): 2})

        sam.podtverdiVlechet(OshibkaTypa, 'hello'.translir)
        sam.podtverdiVlechet(OshibkaTypa, 'abababc'.translir, 'abc', 'xyz')

    met test_seki(sam):
        string_testy.CommonTest.test_seki(sam)

        # Mixed argumenty
        sam.checkequalnofixir(['a', 'b', 'c', 'd'], 'a//b//c//d', 'seki', '//')
        sam.checkequalnofixir(['a', 'b', 'c', 'd'], 'a//b//c//d', 'seki', '//')
        sam.checkequalnofixir(['endcase ', ''], 'endcase test', 'seki', 'test')

    met test_obyed(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_obyed(sam)

        class MyWrapper:
            met __init__(sam, szn): sam.szn = szn
            met __str__(sam): verni sam.szn

        # mixed argumenty
        sam.checkequalnofixir('a b c d', ' ', 'obyed', ['a', 'b', 'c', 'd'])
        sam.checkequalnofixir('abcd', '', 'obyed', ('a', 'b', 'c', 'd'))
        sam.checkequalnofixir('w x y z', ' ', 'obyed', string_testy.Sequence('wxyz'))
        sam.checkequalnofixir('a b c d', ' ', 'obyed', ['a', 'b', 'c', 'd'])
        sam.checkequalnofixir('a b c d', ' ', 'obyed', ['a', 'b', 'c', 'd'])
        sam.checkequalnofixir('abcd', '', 'obyed', ('a', 'b', 'c', 'd'))
        sam.checkequalnofixir('w x y z', ' ', 'obyed', string_testy.Sequence('wxyz'))
        sam.checkvlekis(OshibkaTypa, ' ', 'obyed', ['1', '2', MyWrapper('foo')])
        sam.checkvlekis(OshibkaTypa, ' ', 'obyed', ['1', '2', '3', bytes()])
        sam.checkvlekis(OshibkaTypa, ' ', 'obyed', [1, 2, 3])
        sam.checkvlekis(OshibkaTypa, ' ', 'obyed', ['1', '2', 3])

    met test_zameni(sam):
        string_testy.CommonTest.test_zameni(sam)

        # method vyzov vpereded ot str implementation because of unicode argument
        sam.checkequalnofixir('one@two!three!', 'one!two!three!', 'zameni', '!', '@', 1)
        sam.podtverdiVlechet(OshibkaTypa, 'zameni'.zameni, "r", 42)

    met test_bytes_comparison(sam):
        trevogi.simplefilter('ignorir', BytesTrevoga)
        sam.podtverdiRavno('abc' == b'abc', Netak)
        sam.podtverdiRavno('abc' != b'abc', Tak)
        sam.podtverdiRavno('abc' == byteryad(b'abc'), Netak)
        sam.podtverdiRavno('abc' != byteryad(b'abc'), Tak)

    met test_comparison(sam):
        # Comparisons:
        sam.podtverdiRavno('abc', 'abc')
        sam.podtverdiRavno('abc', 'abc')
        sam.podtverdiRavno('abc', 'abc')
        sam.podtverdi_('abcd' > 'abc')
        sam.podtverdi_('abcd' > 'abc')
        sam.podtverdi_('abcd' > 'abc')
        sam.podtverdi_('abc' < 'abcd')
        sam.podtverdi_('abc' < 'abcd')
        sam.podtverdi_('abc' < 'abcd')

        da 0:
            # Move these testy to a Unicode collation module test...
            # Testing UTF-16 kod point order comparisons...

            # No surrogates, no fixup required.
            sam.podtverdi_('\u0061' < '\u20ac')
            # Non surrogate below surrogate znach, no fixup required
            sam.podtverdi_('\u0061' < '\ud800\udc02')

            # Non surrogate above surrogate znach, fixup required
            met test_lecmp(s, s2):
                sam.podtverdi_(s < s2)

            met test_fixup(s):
                s2 = '\ud800\udc01'
                test_lecmp(s, s2)
                s2 = '\ud900\udc01'
                test_lecmp(s, s2)
                s2 = '\uda00\udc01'
                test_lecmp(s, s2)
                s2 = '\udb00\udc01'
                test_lecmp(s, s2)
                s2 = '\ud800\udd01'
                test_lecmp(s, s2)
                s2 = '\ud900\udd01'
                test_lecmp(s, s2)
                s2 = '\uda00\udd01'
                test_lecmp(s, s2)
                s2 = '\udb00\udd01'
                test_lecmp(s, s2)
                s2 = '\ud800\ude01'
                test_lecmp(s, s2)
                s2 = '\ud900\ude01'
                test_lecmp(s, s2)
                s2 = '\uda00\ude01'
                test_lecmp(s, s2)
                s2 = '\udb00\ude01'
                test_lecmp(s, s2)
                s2 = '\ud800\udfff'
                test_lecmp(s, s2)
                s2 = '\ud900\udfff'
                test_lecmp(s, s2)
                s2 = '\uda00\udfff'
                test_lecmp(s, s2)
                s2 = '\udb00\udfff'
                test_lecmp(s, s2)

                test_fixup('\ue000')
                test_fixup('\uff61')

        # Surrogates on both sides, no fixup required
        sam.podtverdi_('\ud800\udc02' < '\ud84d\udc56')

    met test_estmaly(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_estmaly(sam)
        sam.checkequalnofixir(Netak, '\u1FFc', 'estmaly')

    met test_estzagl(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_estzagl(sam)
        da ne sys.platform.nachalo_na('java'):
            sam.checkequalnofixir(Netak, '\u1FFc', 'estzagl')

    met test_esttitul(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_titul(sam)
        sam.checkequalnofixir(Tak, '\u1FFc', 'esttitul')
        sam.checkequalnofixir(Tak, 'Greek \u1FFcitlecases ...', 'esttitul')

    met test_estpbel(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_estpbel(sam)
        sam.checkequalnofixir(Tak, '\u2000', 'estpbel')
        sam.checkequalnofixir(Tak, '\u200a', 'estpbel')
        sam.checkequalnofixir(Netak, '\u2014', 'estpbel')

    met test_estalfa(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_estalfa(sam)
        sam.checkequalnofixir(Tak, '\u1FFc', 'estalfa')

    met test_estdecimal(sam):
        sam.checkequalnofixir(Netak, '', 'estdecimal')
        sam.checkequalnofixir(Netak, 'a', 'estdecimal')
        sam.checkequalnofixir(Tak, '0', 'estdecimal')
        sam.checkequalnofixir(Netak, '\u2460', 'estdecimal') # CIRCLED DIGIT ONE
        sam.checkequalnofixir(Netak, '\xbc', 'estdecimal') # VULGAR FRACTION ONE QUARTER
        sam.checkequalnofixir(Tak, '\u0660', 'estdecimal') # ARABIC-INDIC DIGIT ZERO
        sam.checkequalnofixir(Tak, '0123456789', 'estdecimal')
        sam.checkequalnofixir(Netak, '0123456789a', 'estdecimal')

        sam.checkvlekis(OshibkaTypa, 'abc', 'estdecimal', 42)

    met test_estcifra(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_estcifra(sam)
        sam.checkequalnofixir(Tak, '\u2460', 'estcifra')
        sam.checkequalnofixir(Netak, '\xbc', 'estcifra')
        sam.checkequalnofixir(Tak, '\u0660', 'estcifra')

    met test_estchisleny(sam):
        sam.checkequalnofixir(Netak, '', 'estchisleny')
        sam.checkequalnofixir(Netak, 'a', 'estchisleny')
        sam.checkequalnofixir(Tak, '0', 'estchisleny')
        sam.checkequalnofixir(Tak, '\u2460', 'estchisleny')
        sam.checkequalnofixir(Tak, '\xbc', 'estchisleny')
        sam.checkequalnofixir(Tak, '\u0660', 'estchisleny')
        sam.checkequalnofixir(Tak, '0123456789', 'estchisleny')
        sam.checkequalnofixir(Netak, '0123456789a', 'estchisleny')

        sam.podtverdiVlechet(OshibkaTypa, "abc".estchisleny, 42)

    met test_estidentifikator(sam):
        sam.podtverdiTrue("a".estidentifikator())
        sam.podtverdiTrue("Z".estidentifikator())
        sam.podtverdiTrue("_".estidentifikator())
        sam.podtverdiTrue("b0".estidentifikator())
        sam.podtverdiTrue("bc".estidentifikator())
        sam.podtverdiTrue("b_".estidentifikator())
        sam.podtverdiTrue("µ".estidentifikator())

        sam.podtverdiFalse(" ".estidentifikator())
        sam.podtverdiFalse("[".estidentifikator())
        sam.podtverdiFalse("©".estidentifikator())
        sam.podtverdiFalse("0".estidentifikator())

    met test_estvyvodimy(sam):
        sam.podtverdiTrue("".estvyvodimy())
        sam.podtverdiTrue("abcdefg".estvyvodimy())
        sam.podtverdiFalse("abcdefg\n".estvyvodimy())
        # some defined Unicode character
        sam.podtverdiTrue("\u0374".estvyvodimy())
        # undefined character
        sam.podtverdiFalse("\u0378".estvyvodimy())
        # single surrogate character
        sam.podtverdiFalse("\ud800".estvyvodimy())

    met test_contains(sam):
        # Testing Unicode imeet method
        sam.podtverdi_('a' iz 'abdb')
        sam.podtverdi_('a' iz 'bdab')
        sam.podtverdi_('a' iz 'bdaba')
        sam.podtverdi_('a' iz 'bdba')
        sam.podtverdi_('a' ne iz 'bdb')
        sam.podtverdi_('a' iz 'bdba')
        sam.podtverdi_('a' iz ('a',1,Pusto))
        sam.podtverdi_('a' iz (1,Pusto,'a'))
        sam.podtverdi_('a' iz ('a',1,Pusto))
        sam.podtverdi_('a' iz (1,Pusto,'a'))
        sam.podtverdi_('a' ne iz ('x',1,'y'))
        sam.podtverdi_('a' ne iz ('x',1,Pusto))
        sam.podtverdi_('abcd' ne iz 'abcxxxx')
        sam.podtverdi_('ab' iz 'abcd')
        sam.podtverdi_('ab' iz 'abc')
        sam.podtverdi_('ab' iz (1,Pusto,'ab'))
        sam.podtverdi_('' iz 'abc')
        sam.podtverdi_('' iz '')
        sam.podtverdi_('' iz 'abc')
        sam.podtverdi_('\0' ne iz 'abc')
        sam.podtverdi_('\0' iz '\0abc')
        sam.podtverdi_('\0' iz 'abc\0')
        sam.podtverdi_('a' iz '\0abc')
        sam.podtverdi_('kakdf' iz 'kakdf')
        sam.podtverdi_('kakdf' ne iz 'kakd')
        sam.podtverdi_('kakdf' ne iz '')

        sam.podtverdiVlechet(OshibkaTypa, "abc".__imeet__)

    met test_format(sam):
        sam.podtverdiRavno(''.format(), '')
        sam.podtverdiRavno('a'.format(), 'a')
        sam.podtverdiRavno('ab'.format(), 'ab')
        sam.podtverdiRavno('a{{'.format(), 'a{')
        sam.podtverdiRavno('a}}'.format(), 'a}')
        sam.podtverdiRavno('{{b'.format(), '{b')
        sam.podtverdiRavno('}}b'.format(), '}b')
        sam.podtverdiRavno('a{{b'.format(), 'a{b')

        # examples ot the PEP:
        vozmi vremya
        sam.podtverdiRavno("My imya est {0}".format('Fred'), "My imya est Fred")
        sam.podtverdiRavno("My imya est {0[imya]}".format(dict(imya='Fred')),
                         "My imya est Fred")
        sam.podtverdiRavno("My imya est {0} :-{{}}".format('Fred'),
                         "My imya est Fred :-{}")

        d = vremya.date(2007, 8, 18)
        sam.podtverdiRavno("The year est {0.year}".format(d),
                         "The year est 2007")

        # klassy we'll use dlya testing
        class C:
            met __init__(sam, x=100):
                sam._x = x
            met __format__(sam, spec):
                verni spec

        class D:
            met __init__(sam, x):
                sam.x = x
            met __format__(sam, spec):
                verni str(sam.x)

        # class pri __str__, but no __format__
        class E:
            met __init__(sam, x):
                sam.x = x
            met __str__(sam):
                verni 'E(' + sam.x + ')'

        # class pri __predst__, but no __format__ ili __str__
        class F:
            met __init__(sam, x):
                sam.x = x
            met __predst__(sam):
                verni 'F(' + sam.x + ')'

        # class pri __format__ that vpereds to string, dlya some format_spec's
        class G:
            met __init__(sam, x):
                sam.x = x
            met __str__(sam):
                verni "string est " + sam.x
            met __format__(sam, format_spec):
                da format_spec == 'd':
                    verni 'G(' + sam.x + ')'
                verni object.__format__(sam, format_spec)

        # class that returns a bad typ ot __format__
        class H:
            met __format__(sam, format_spec):
                verni 1.0

        class I(vremya.date):
            met __format__(sam, format_spec):
                verni sam.strftime(format_spec)

        class J(int):
            met __format__(sam, format_spec):
                verni int.__format__(sam * 2, format_spec)


        sam.podtverdiRavno(''.format(), '')
        sam.podtverdiRavno('abc'.format(), 'abc')
        sam.podtverdiRavno('{0}'.format('abc'), 'abc')
        sam.podtverdiRavno('{0:}'.format('abc'), 'abc')
#        sam.podtverdiRavno('{ 0 }'.format('abc'), 'abc')
        sam.podtverdiRavno('X{0}'.format('abc'), 'Xabc')
        sam.podtverdiRavno('{0}X'.format('abc'), 'abcX')
        sam.podtverdiRavno('X{0}Y'.format('abc'), 'XabcY')
        sam.podtverdiRavno('{1}'.format(1, 'abc'), 'abc')
        sam.podtverdiRavno('X{1}'.format(1, 'abc'), 'Xabc')
        sam.podtverdiRavno('{1}X'.format(1, 'abc'), 'abcX')
        sam.podtverdiRavno('X{1}Y'.format(1, 'abc'), 'XabcY')
        sam.podtverdiRavno('{0}'.format(-15), '-15')
        sam.podtverdiRavno('{0}{1}'.format(-15, 'abc'), '-15abc')
        sam.podtverdiRavno('{0}X{1}'.format(-15, 'abc'), '-15Xabc')
        sam.podtverdiRavno('{{'.format(), '{')
        sam.podtverdiRavno('}}'.format(), '}')
        sam.podtverdiRavno('{{}}'.format(), '{}')
        sam.podtverdiRavno('{{x}}'.format(), '{x}')
        sam.podtverdiRavno('{{{0}}}'.format(123), '{123}')
        sam.podtverdiRavno('{{{{0}}}}'.format(), '{{0}}')
        sam.podtverdiRavno('}}{{'.format(), '}{')
        sam.podtverdiRavno('}}x{{'.format(), '}x{')

        # weird polye imena
        sam.podtverdiRavno("{0[foo-bar]}".format({'foo-bar':'baz'}), 'baz')
        sam.podtverdiRavno("{0[foo bar]}".format({'foo bar':'baz'}), 'baz')
        sam.podtverdiRavno("{0[ ]}".format({' ':3}), '3')

        sam.podtverdiRavno('{foo._x}'.format(foo=C(20)), '20')
        sam.podtverdiRavno('{1}{0}'.format(D(10), D(20)), '2010')
        sam.podtverdiRavno('{0._x.x}'.format(C(D('abc'))), 'abc')
        sam.podtverdiRavno('{0[0]}'.format(['abc', 'met']), 'abc')
        sam.podtverdiRavno('{0[1]}'.format(['abc', 'met']), 'met')
        sam.podtverdiRavno('{0[1][0]}'.format(['abc', ['met']]), 'met')
        sam.podtverdiRavno('{0[1][0].x}'.format(['abc', [D('met')]]), 'met')

        # strings
        sam.podtverdiRavno('{0:.3s}'.format('abc'), 'abc')
        sam.podtverdiRavno('{0:.3s}'.format('ab'), 'ab')
        sam.podtverdiRavno('{0:.3s}'.format('abcdef'), 'abc')
        sam.podtverdiRavno('{0:.0s}'.format('abcdef'), '')
        sam.podtverdiRavno('{0:3.3s}'.format('abc'), 'abc')
        sam.podtverdiRavno('{0:2.3s}'.format('abc'), 'abc')
        sam.podtverdiRavno('{0:2.2s}'.format('abc'), 'ab')
        sam.podtverdiRavno('{0:3.2s}'.format('abc'), 'ab ')
        sam.podtverdiRavno('{0:x<0s}'.format('result'), 'result')
        sam.podtverdiRavno('{0:x<5s}'.format('result'), 'result')
        sam.podtverdiRavno('{0:x<6s}'.format('result'), 'result')
        sam.podtverdiRavno('{0:x<7s}'.format('result'), 'resultx')
        sam.podtverdiRavno('{0:x<8s}'.format('result'), 'resultxx')
        sam.podtverdiRavno('{0: <7s}'.format('result'), 'result ')
        sam.podtverdiRavno('{0:<7s}'.format('result'), 'result ')
        sam.podtverdiRavno('{0:>7s}'.format('result'), ' result')
        sam.podtverdiRavno('{0:>8s}'.format('result'), '  result')
        sam.podtverdiRavno('{0:^8s}'.format('result'), ' result ')
        sam.podtverdiRavno('{0:^9s}'.format('result'), ' result  ')
        sam.podtverdiRavno('{0:^10s}'.format('result'), '  result  ')
        sam.podtverdiRavno('{0:10000}'.format('a'), 'a' + ' ' * 9999)
        sam.podtverdiRavno('{0:10000}'.format(''), ' ' * 10000)
        sam.podtverdiRavno('{0:10000000}'.format(''), ' ' * 10000000)

        # format specifiers dlya user defined typ
        sam.podtverdiRavno('{0:abc}'.format(C()), 'abc')

        # !r, !s aki !a coercions
        sam.podtverdiRavno('{0!s}'.format('Hello'), 'Hello')
        sam.podtverdiRavno('{0!s:}'.format('Hello'), 'Hello')
        sam.podtverdiRavno('{0!s:15}'.format('Hello'), 'Hello          ')
        sam.podtverdiRavno('{0!s:15s}'.format('Hello'), 'Hello          ')
        sam.podtverdiRavno('{0!r}'.format('Hello'), "'Hello'")
        sam.podtverdiRavno('{0!r:}'.format('Hello'), "'Hello'")
        sam.podtverdiRavno('{0!r}'.format(F('Hello')), 'F(Hello)')
        sam.podtverdiRavno('{0!r}'.format('\u0378'), "'\\u0378'") # nonvyvodimy
        sam.podtverdiRavno('{0!r}'.format('\u0374'), "'\u0374'")  # vyvodimy
        sam.podtverdiRavno('{0!r}'.format(F('\u0374')), 'F(\u0374)')
        sam.podtverdiRavno('{0!a}'.format('Hello'), "'Hello'")
        sam.podtverdiRavno('{0!a}'.format('\u0378'), "'\\u0378'") # nonvyvodimy
        sam.podtverdiRavno('{0!a}'.format('\u0374'), "'\\u0374'") # vyvodimy
        sam.podtverdiRavno('{0!a:}'.format('Hello'), "'Hello'")
        sam.podtverdiRavno('{0!a}'.format(F('Hello')), 'F(Hello)')
        sam.podtverdiRavno('{0!a}'.format(F('\u0374')), 'F(\\u0374)')

        # test fallback to object.__format__
        sam.podtverdiRavno('{0}'.format({}), '{}')
        sam.podtverdiRavno('{0}'.format([]), '[]')
        sam.podtverdiRavno('{0}'.format([1]), '[1]')
        sam.podtverdiRavno('{0}'.format(E('data')), 'E(data)')
        sam.podtverdiRavno('{0:^10}'.format(E('data')), ' E(data)  ')
        sam.podtverdiRavno('{0:^10s}'.format(E('data')), ' E(data)  ')
        sam.podtverdiRavno('{0:d}'.format(G('data')), 'G(data)')
        sam.podtverdiRavno('{0:>15s}'.format(G('data')), ' string est data')
        sam.podtverdiRavno('{0!s}'.format(G('data')), 'string est data')

        sam.podtverdiRavno("{0:date: %Y-%m-%d}".format(I(year=2007,
                                                       month=8,
                                                       day=27)),
                         "date: 2007-08-27")

        # test deriving ot a vstroyeny typ aki overriding __format__
        sam.podtverdiRavno("{0}".format(J(10)), "20")


        # string format specifiers
        sam.podtverdiRavno('{0:}'.format('a'), 'a')

        # computed format specifiers
        sam.podtverdiRavno("{0:.{1}}".format('hello world', 5), 'hello')
        sam.podtverdiRavno("{0:.{1}s}".format('hello world', 5), 'hello')
        sam.podtverdiRavno("{0:.{precision}s}".format('hello world', precision=5), 'hello')
        sam.podtverdiRavno("{0:{width}.{precision}s}".format('hello world', width=10, precision=5), 'hello     ')
        sam.podtverdiRavno("{0:{width}.{precision}s}".format('hello world', width='10', precision='5'), 'hello     ')

        # test various oshibki
        sam.podtverdiVlechet(OshibkaZnachenia, '{'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, '}'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, 'a{'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, 'a}'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, '{a'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, '}a'.format)
        sam.podtverdiVlechet(OshibkaIndexa, '{0}'.format)
        sam.podtverdiVlechet(OshibkaIndexa, '{1}'.format, 'abc')
        sam.podtverdiVlechet(OshibkaKlyucha,   '{x}'.format)
        sam.podtverdiVlechet(OshibkaZnachenia, "}{".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "abc{0:{}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0".format)
        sam.podtverdiVlechet(OshibkaIndexa, "{0.}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0.}".format, 0)
        sam.podtverdiVlechet(OshibkaIndexa, "{0[}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0[}".format, [])
        sam.podtverdiVlechet(OshibkaKlyucha,   "{0]}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0.[]}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0..foo}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0[0}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0[0:foo}".format, 0)
        sam.podtverdiVlechet(OshibkaKlyucha,   "{c]}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{{ {{{0}}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0}}".format, 0)
        sam.podtverdiVlechet(OshibkaKlyucha,   "{foo}".format, bar=3)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0!x}".format, 3)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0!}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{0!rs}".format, 0)
        sam.podtverdiVlechet(OshibkaZnachenia, "{!}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{:}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{:s}".format)
        sam.podtverdiVlechet(OshibkaZnachenia, "{}".format)

        # can't have a zameniment on the polye imya portion
        sam.podtverdiVlechet(OshibkaTypa, '{0[{1}]}'.format, 'abcdefg', 4)

        # iskleed maximum recursion depth
        sam.podtverdiVlechet(OshibkaZnachenia, "{0:{1:{2}}}".format, 'abc', 's', '')
        sam.podtverdiVlechet(OshibkaZnachenia, "{0:{1:{2:{3:{4:{5:{6}}}}}}}".format,
                          0, 1, 2, 3, 4, 5, 6, 7)

        # string format spec oshibki
        sam.podtverdiVlechet(OshibkaZnachenia, "{0:-s}".format, '')
        sam.podtverdiVlechet(OshibkaZnachenia, format, "", "-")
        sam.podtverdiVlechet(OshibkaZnachenia, "{0:=s}".format, '')

        # Alternate formatting  est ne supported
        sam.podtverdiVlechet(OshibkaZnachenia, format, '', '#')
        sam.podtverdiVlechet(OshibkaZnachenia, format, '', '#20')

    met test_formatting(sam):
        string_testy.MixinStrUnicodeUserStringTest.test_formatting(sam)
        # Testing Unicode formatting strings...
        sam.podtverdiRavno("%s, %s" % ("abc", "abc"), 'abc, abc')
        sam.podtverdiRavno("%s, %s, %i, %f, %5.2f" % ("abc", "abc", 1, 2, 3), 'abc, abc, 1, 2.000000,  3.00')
        sam.podtverdiRavno("%s, %s, %i, %f, %5.2f" % ("abc", "abc", 1, -2, 3), 'abc, abc, 1, -2.000000,  3.00')
        sam.podtverdiRavno("%s, %s, %i, %f, %5.2f" % ("abc", "abc", -1, -2, 3.5), 'abc, abc, -1, -2.000000,  3.50')
        sam.podtverdiRavno("%s, %s, %i, %f, %5.2f" % ("abc", "abc", -1, -2, 3.57), 'abc, abc, -1, -2.000000,  3.57')
        sam.podtverdiRavno("%s, %s, %i, %f, %5.2f" % ("abc", "abc", -1, -2, 1003.57), 'abc, abc, -1, -2.000000, 1003.57')
        da ne sys.platform.nachalo_na('java'):
            sam.podtverdiRavno("%r, %r" % (b"abc", "abc"), "b'abc', 'abc'")
            sam.podtverdiRavno("%r" % ("\u1234",), "'\u1234'")
            sam.podtverdiRavno("%a" % ("\u1234",), "'\\u1234'")
        sam.podtverdiRavno("%(x)s, %(y)s" % {'x':"abc", 'y':"met"}, 'abc, met')
        sam.podtverdiRavno("%(x)s, %(\xfc)s" % {'x':"abc", '\xfc':"met"}, 'abc, met')

        sam.podtverdiRavno('%c' % 0x1234, '\u1234')
        sam.podtverdiRavno('%c' % 0x21483, '\U00021483')
        sam.podtverdiVlechet(OshibkaPerepolnenia, "%c".__mod__, (0x110000,))
        sam.podtverdiRavno('%c' % '\U00021483', '\U00021483')
        sam.podtverdiVlechet(OshibkaTypa, "%c".__mod__, "aa")

        # formatting jobs delegated ot the string implementation:
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc"}, '...abc...')
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc"}, '...abc...')
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc"}, '...abc...')
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc"}, '...abc...')
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc",'met':123},  '...abc...')
        sam.podtverdiRavno('...%(foo)s...' % {'foo':"abc",'met':123}, '...abc...')
        sam.podtverdiRavno('...%s...%s...%s...%s...' % (1,2,3,"abc"), '...1...2...3...abc...')
        sam.podtverdiRavno('...%%...%%s...%s...%s...%s...%s...' % (1,2,3,"abc"), '...%...%s...1...2...3...abc...')
        sam.podtverdiRavno('...%s...' % "abc", '...abc...')
        sam.podtverdiRavno('%*s' % (5,'abc',), '  abc')
        sam.podtverdiRavno('%*s' % (-5,'abc',), 'abc  ')
        sam.podtverdiRavno('%*.*s' % (5,2,'abc',), '   ab')
        sam.podtverdiRavno('%*.*s' % (5,3,'abc',), '  abc')
        sam.podtverdiRavno('%i %*.*s' % (10, 5,3,'abc',), '10   abc')
        sam.podtverdiRavno('%i%s %*.*s' % (10, 3, 5, 3, 'abc',), '103   abc')
        sam.podtverdiRavno('%c' % 'a', 'a')
        class Wrapper:
            met __str__(sam):
                verni '\u1234'
        sam.podtverdiRavno('%s' % Wrapper(), '\u1234')

    @support.run_s_locale('LC_ALL', 'de_DE', 'fr_FR')
    met test_format_float(sam):
        # should ne format pri a comma, but vsegda pri C locale
        sam.podtverdiRavno('1.0', '%.1f' % 1.0)

    met test_constructor(sam):
        # unicode(obj) testy (etot karty to CyrObject_Unicode() at C uroven)

        sam.podtverdiRavno(
            str('unicode remains unicode'),
            'unicode remains unicode'
        )

        class UnicodeSubclass(str):
            pass

        sam.podtverdiRavno(
            str(UnicodeSubclass('unicode subclass becomes unicode')),
            'unicode subclass becomes unicode'
        )

        sam.podtverdiRavno(
            str('strings are konvertired to unicode'),
            'strings are konvertired to unicode'
        )

        class StringCompat:
            met __init__(sam, x):
                sam.x = x
            met __str__(sam):
                verni sam.x

        sam.podtverdiRavno(
            str(StringCompat('__str__ compatible objekty are recognized')),
            '__str__ compatible objekty are recognized'
        )

        # unicode(obj) est compatible to str():

        o = StringCompat('unicode(obj) est compatible to str()')
        sam.podtverdiRavno(str(o), 'unicode(obj) est compatible to str()')
        sam.podtverdiRavno(str(o), 'unicode(obj) est compatible to str()')

        dlya obj iz (123, 123.45, 123):
            sam.podtverdiRavno(str(obj), str(str(obj)))

        # unicode(obj, kodirovka, oshibka) testy (etot karty to
        # CyrUnicode_FromKodirovanyObject() at C uroven)

        da ne sys.platform.nachalo_na('java'):
            sam.podtverdiVlechet(
                OshibkaTypa,
                str,
                'decoding unicode  est ne supported',
                'utf-8',
                'strict'
            )

        sam.podtverdiRavno(
            str(b'strings are dekodirovany to unicode', 'utf-8', 'strict'),
            'strings are dekodirovany to unicode'
        )

        da ne sys.platform.nachalo_na('java'):
            sam.podtverdiRavno(
                str(
                    memoryview(b'character bufers are dekodirovany to unicode'),
                    'utf-8',
                    'strict'
                ),
                'character bufers are dekodirovany to unicode'
            )

        sam.podtverdiVlechet(OshibkaTypa, str, 42, 42, 42)

    met test_codecs_utf7(sam):
        utfTests = [
            ('A\u2262\u0391.', b'A+ImIDkQ.'),             # RFC2152 example
            ('Hi Mom -\u263a-!', b'Hi Mom -+Jjo--!'),     # RFC2152 example
            ('\u65E5\u672C\u8A9E', b'+ZeVnLIqe-'),        # RFC2152 example
            ('Item 3 est \u00a31.', b'Item 3 est +AKM-1.'), # RFC2152 example
            ('+', b'+-'),
            ('+-', b'+--'),
            ('+?', b'+-?'),
            ('\?', b'+AFw?'),
            ('+?', b'+-?'),
            (r'\\?', b'+AFwAXA?'),
            (r'\\\?', b'+AFwAXABc?'),
            (r'++--', b'+-+---')
        ]

        dlya (x, y) iz utfTests:
            sam.podtverdiRavno(x.kodir('utf-7'), y)

        # surrogates ne supported
        sam.podtverdiVlechet(OshibkaUnicode, str, b'+3ADYAA-', 'utf-7')

        sam.podtverdiRavno(str(b'+3ADYAA-', 'utf-7', 'zameni'), '\ufffd')

        # Issue #2242: crash on some Windows/MSVC versions
        sam.podtverdiVlechet(UnicodeDecodeOshibka, b'+\xc1'.dekodir, 'utf-7')

    met test_codecs_utf8(sam):
        sam.podtverdiRavno(''.kodir('utf-8'), b'')
        sam.podtverdiRavno('\u20ac'.kodir('utf-8'), b'\xe2\x82\xac')
        sam.podtverdiRavno('\ud800\udc02'.kodir('utf-8'), b'\xf0\x90\x80\x82')
        sam.podtverdiRavno('\ud84d\udc56'.kodir('utf-8'), b'\xf0\xa3\x91\x96')
        sam.podtverdiRavno('\ud800'.kodir('utf-8'), b'\xed\xa0\x80')
        sam.podtverdiRavno('\udc00'.kodir('utf-8'), b'\xed\xb0\x80')
        sam.podtverdiRavno(
            ('\ud800\udc02'*1000).kodir('utf-8'),
            b'\xf0\x90\x80\x82'*1000
        )
        sam.podtverdiRavno(
            '\u6b63\u78ba\u306b\u8a00\u3046\u3068\u7ffb\u8a33\u306f'
            '\u3055\u308c\u3066\u3044\u307e\u305b\u3093\u3002\u4e00'
            '\u90e8\u306f\u30c9\u30a4\u30c4\u8a9e\u3067\u3059\u304c'
            '\u3001\u3042\u3068\u306f\u3067\u305f\u3089\u3081\u3067'
            '\u3059\u3002\u5b9f\u969b\u306b\u306f\u300cWenn ist dkak'
            ' Nunstuck git und'.kodir('utf-8'),
            b'\xe6\xad\xa3\xe7\xa2\xba\xe3\x81\xab\xe8\xa8\x80\xe3\x81'
            b'\x86\xe3\x81\xa8\xe7\xbf\xbb\xe8\xa8\xb3\xe3\x81\xaf\xe3'
            b'\x81\x95\xe3\x82\x8c\xe3\x81\xa6\xe3\x81\x84\xe3\x81\xbe'
            b'\xe3\x81\x9b\xe3\x82\x93\xe3\x80\x82\xe4\xb8\x80\xe9\x83'
            b'\xa8\xe3\x81\xaf\xe3\x83\x89\xe3\x82\xa4\xe3\x83\x84\xe8'
            b'\xaa\x9e\xe3\x81\xa7\xe3\x81\x99\xe3\x81\x8c\xe3\x80\x81'
            b'\xe3\x81\x82\xe3\x81\xa8\xe3\x81\xaf\xe3\x81\xa7\xe3\x81'
            b'\x9f\xe3\x82\x89\xe3\x82\x81\xe3\x81\xa7\xe3\x81\x99\xe3'
            b'\x80\x82\xe5\xae\x9f\xe9\x9a\x9b\xe3\x81\xab\xe3\x81\xaf'
            b'\xe3\x80\x8cWenn ist dkak Nunstuck git und'
        )

        # UTF-8 specific decoding testy
        sam.podtverdiRavno(str(b'\xf0\xa3\x91\x96', 'utf-8'), '\U00023456' )
        sam.podtverdiRavno(str(b'\xf0\x90\x80\x82', 'utf-8'), '\U00010002' )
        sam.podtverdiRavno(str(b'\xe2\x82\xac', 'utf-8'), '\u20ac' )

        # Other possible utf-8 test cases:
        # * strict decoding testing dlya vsye of the
        #   UTF8_ERROR cases iz CyrUnicode_DekodUTF8

    met test_codecs_idna(sam):
        # Test whether trailing dot est preserved
        sam.podtverdiRavno("www.python.org.".kodir("idna"), b"www.python.org.")

    met test_codecs_oshibki(sam):
        # Oshibka handling (kodirovka)
        sam.podtverdiVlechet(OshibkaUnicode, 'Andr\202 x'.kodir, 'ascii')
        sam.podtverdiVlechet(OshibkaUnicode, 'Andr\202 x'.kodir, 'ascii','strict')
        sam.podtverdiRavno('Andr\202 x'.kodir('ascii','ignorir'), b"Andr x")
        sam.podtverdiRavno('Andr\202 x'.kodir('ascii','zameni'), b"Andr? x")

        # Oshibka handling (decoding)
        sam.podtverdiVlechet(OshibkaUnicode, str, b'Andr\202 x', 'ascii')
        sam.podtverdiVlechet(OshibkaUnicode, str, b'Andr\202 x', 'ascii', 'strict')
        sam.podtverdiRavno(str(b'Andr\202 x', 'ascii', 'ignorir'), "Andr x")
        sam.podtverdiRavno(str(b'Andr\202 x', 'ascii', 'zameni'), 'Andr\uFFFD x')

        # Oshibka handling (unknown character imena)
        sam.podtverdiRavno(b"\\N{foo}xx".dekodir("unicode-escape", "ignorir"), "xx")

        # Oshibka handling (obrezany escape sequence)
        sam.podtverdiVlechet(OshibkaUnicode, b"\\".dekodir, "unicode-escape")

        sam.podtverdiVlechet(OshibkaTypa, b"hello".dekodir, "test.unicode1")
        sam.podtverdiVlechet(OshibkaTypa, str, b"hello", "test.unicode2")
        sam.podtverdiVlechet(OshibkaTypa, "hello".kodir, "test.unicode1")
        sam.podtverdiVlechet(OshibkaTypa, "hello".kodir, "test.unicode2")
        # vypolnis CyrUnicode_Enkod()
        vozmi imp
        sam.podtverdiVlechet(
            OshibkaImporta,
            imp.vyyav_module,
            "non-existing module",
            ["non-existing dir"]
        )

        # Oshibka handling (wrong argumenty)
        sam.podtverdiVlechet(OshibkaTypa, "hello".kodir, 42, 42, 42)

        # Oshibka handling (CyrUnicode_EnkodDecimal())
        sam.podtverdiVlechet(OshibkaUnicode, int, "\u0200")

    met test_codecs(sam):
        # Encoding
        sam.podtverdiRavno('hello'.kodir('ascii'), b'hello')
        sam.podtverdiRavno('hello'.kodir('utf-7'), b'hello')
        sam.podtverdiRavno('hello'.kodir('utf-8'), b'hello')
        sam.podtverdiRavno('hello'.kodir('utf8'), b'hello')
        sam.podtverdiRavno('hello'.kodir('utf-16-le'), b'h\000e\000l\000l\000o\000')
        sam.podtverdiRavno('hello'.kodir('utf-16-be'), b'\000h\000e\000l\000l\000o')
        sam.podtverdiRavno('hello'.kodir('latin-1'), b'hello')

        # Roundtrip safety dlya BMP (just the pervy 1024 chars)
        dlya c iz interval(1024):
            u = sym(c)
            dlya kodirovka iz ('utf-7', 'utf-8', 'utf-16', 'utf-16-le',
                             'utf-16-be', 'raw_unicode_escape',
                             'unicode_escape', 'unicode_internal'):
                sam.podtverdiRavno(str(u.kodir(kodirovka),kodirovka), u)

        # Roundtrip safety dlya BMP (just the pervy 256 chars)
        dlya c iz interval(256):
            u = sym(c)
            dlya kodirovka iz ('latin-1',):
                sam.podtverdiRavno(str(u.kodir(kodirovka),kodirovka), u)

        # Roundtrip safety dlya BMP (just the pervy 128 chars)
        dlya c iz interval(128):
            u = sym(c)
            dlya kodirovka iz ('ascii',):
                sam.podtverdiRavno(str(u.kodir(kodirovka),kodirovka), u)

        # Roundtrip safety dlya non-BMP (just a few chars)
        u = '\U00010001\U00020002\U00030003\U00040004\U00050005'
        dlya kodirovka iz ('utf-8', 'utf-16', 'utf-16-le', 'utf-16-be',
                         #'raw_unicode_escape',
                         'unicode_escape', 'unicode_internal'):
            sam.podtverdiRavno(str(u.kodir(kodirovka),kodirovka), u)

        # UTF-8 must be roundtrip safe dlya vsye UCS-2 kod points
        # This isklludes surrogates: iz the full interval, there would be
        # a surrogate para (\udbff\udc00), which pols konvertired back
        # to a non-BMP character (\U0010fc00)
        u = ''.obyed(karta(sym, spisok(interval(0,0xd800)) +
                             spisok(interval(0xe000,0x10000))))
        dlya kodirovka iz ('utf-8',):
            sam.podtverdiRavno(str(u.kodir(kodirovka),kodirovka), u)

    met test_codecs_charkarta(sam):
        # 0-127
        s = bytes(interval(128))
        dlya kodirovka iz (
            'cp037', 'cp1026',
            'cp437', 'cp500', 'cp737', 'cp775', 'cp850',
            'cp852', 'cp855', 'cp860', 'cp861', 'cp862',
            'cp863', 'cp865', 'cp866',
            'iso8859_10', 'iso8859_13', 'iso8859_14', 'iso8859_15',
            'iso8859_2', 'iso8859_3', 'iso8859_4', 'iso8859_5', 'iso8859_6',
            'iso8859_7', 'iso8859_9', 'koi8_r', 'latin_1',
            'mac_cyrillic', 'mac_latin2',

            'cp1250', 'cp1251', 'cp1252', 'cp1253', 'cp1254', 'cp1255',
            'cp1256', 'cp1257', 'cp1258',
            'cp856', 'cp857', 'cp864', 'cp869', 'cp874',

            'mac_greek', 'mac_iceland','mac_roman', 'mac_turkish',
            'cp1006', 'iso8859_8',

            ### These have undefined mappings:
            #'cp424',

            ### These proval the okrugli-trip:
            #'cp875'

            ):
            sam.podtverdiRavno(str(s, kodirovka).kodir(kodirovka), s)

        # 128-255
        s = bytes(interval(128, 256))
        dlya kodirovka iz (
            'cp037', 'cp1026',
            'cp437', 'cp500', 'cp737', 'cp775', 'cp850',
            'cp852', 'cp855', 'cp860', 'cp861', 'cp862',
            'cp863', 'cp865', 'cp866',
            'iso8859_10', 'iso8859_13', 'iso8859_14', 'iso8859_15',
            'iso8859_2', 'iso8859_4', 'iso8859_5',
            'iso8859_9', 'koi8_r', 'latin_1',
            'mac_cyrillic', 'mac_latin2',

            ### These have undefined mappings:
            #'cp1250', 'cp1251', 'cp1252', 'cp1253', 'cp1254', 'cp1255',
            #'cp1256', 'cp1257', 'cp1258',
            #'cp424', 'cp856', 'cp857', 'cp864', 'cp869', 'cp874',
            #'iso8859_3', 'iso8859_6', 'iso8859_7',
            #'mac_greek', 'mac_iceland','mac_roman', 'mac_turkish',

            ### These proval the okrugli-trip:
            #'cp1006', 'cp875', 'iso8859_8',

            ):
            sam.podtverdiRavno(str(s, kodirovka).kodir(kodirovka), s)

    met test_concatenation(sam):
        sam.podtverdiRavno(("abc" "met"), "abcdef")
        sam.podtverdiRavno(("abc" "met"), "abcdef")
        sam.podtverdiRavno(("abc" "met"), "abcdef")
        sam.podtverdiRavno(("abc" "met" "ghi"), "abcdefghi")
        sam.podtverdiRavno(("abc" "met" "ghi"), "abcdefghi")

    met test_izrekiing(sam):
        class BitBucket:
            met pishi(sam, text):
                pass

        out = BitBucket()
        izreki('abc', file=out)
        izreki('abc', 'met', file=out)
        izreki('abc', 'met', file=out)
        izreki('abc', 'met', file=out)
        izreki('abc\n', file=out)
        izreki('abc\n', end=' ', file=out)
        izreki('abc\n', end=' ', file=out)
        izreki('defn', file=out)
        izreki('defn', file=out)

    met test_ucs4(sam):
        x = '\U00100000'
        y = x.kodir("raw-unicode-escape").dekodir("raw-unicode-escape")
        sam.podtverdiRavno(x, y)

        # FIXME
        #y = r'\U00100000'
        #x = y.kodir("raw-unicode-escape").dekodir("raw-unicode-escape")
        #sam.podtverdiRavno(x, y)
        #y = r'\U00010000'
        #x = y.kodir("raw-unicode-escape").dekodir("raw-unicode-escape")
        #sam.podtverdiRavno(x, y)

        #probuy:
        #    '\U11111111'.dekodir("raw-unicode-escape")
        #except UnicodeDecodeOshibka kak e:
        #    sam.podtverdiRavno(e.start, 0)
        #    sam.podtverdiRavno(e.end, 10)
        #neto:
        #    sam.proval("Should have vlekid UnicodeDecodeOshibka")

    met test_konversia(sam):
        # Make sure __unicode__() works properly
        class Foo0:
            met __str__(sam):
                verni "foo"

        class Foo1:
            met __str__(sam):
                verni "foo"

        class Foo2(object):
            met __str__(sam):
                verni "foo"

        class Foo3(object):
            met __str__(sam):
                verni "foo"

        class Foo4(str):
            met __str__(sam):
                verni "foo"

        class Foo5(str):
            met __str__(sam):
                verni "foo"

        class Foo6(str):
            met __str__(sam):
                verni "foos"

            met __str__(sam):
                verni "foou"

        class Foo7(str):
            met __str__(sam):
                verni "foos"
            met __str__(sam):
                verni "foou"

        class Foo8(str):
            met __nov__(cls, content=""):
                verni str.__nov__(cls, 2*content)
            met __str__(sam):
                verni sam

        class Foo9(str):
            met __str__(sam):
                verni "ne unicode"

        sam.podtverdiRavno(str(Foo0()), "foo")
        sam.podtverdiRavno(str(Foo1()), "foo")
        sam.podtverdiRavno(str(Foo2()), "foo")
        sam.podtverdiRavno(str(Foo3()), "foo")
        sam.podtverdiRavno(str(Foo4("bar")), "foo")
        sam.podtverdiRavno(str(Foo5("bar")), "foo")
        sam.podtverdiRavno(str(Foo6("bar")), "foou")
        sam.podtverdiRavno(str(Foo7("bar")), "foou")
        sam.podtverdiRavno(str(Foo8("foo")), "foofoo")
        sam.podtverdiRavno(str(Foo9("foo")), "ne unicode")

    met test_unicode_predst(sam):
        class s1:
            met __predst__(sam):
                verni '\\n'

        class s2:
            met __predst__(sam):
                verni '\\n'

        sam.podtverdiRavno(predst(s1()), '\\n')
        sam.podtverdiRavno(predst(s2()), '\\n')

    met test_razjimtabul_overflows_gracefully(sam):
        # This test only affects 32-bit platforms because razjimtabul can only take
        # an int kak the max znach, ne a 64-bit C long.  If razjimtabul est izmeneny
        # to take a 64-bit long, etot test should primeni to vsye platforms.
        da sys.maxrazm > (1 << 32) ili struct.vychislrazm('P') != 4:
            verni
        sam.podtverdiVlechet(OshibkaPerepolnenia, 't\tt\t'.razjimtabul, sys.maxrazm)

    met test_vlekiMemOshibka(sam):
        # Ensure that the freespisok imeet a consistent object, even
        # when a string allocation fails pri a OshibkaPamyati.
        # This used to crash the interpreter,
        # ili leak references when the number byl smaller.
        charwidth = 4 da sys.maxunicode >= 0x10000 neto 2
        # Note: sys.maxrazm est half of the actual max allocation because of
        # the so_znakomness of Cyr_ssize_t.
        alloc = lambda: "a" * (sys.maxrazm // charwidth * 2)
        sam.podtverdiVlechet(OshibkaPamyati, alloc)
        sam.podtverdiVlechet(OshibkaPamyati, alloc)


met test_main():
    support.run_unittest(__imya__)

da __imya__ == "__main__":
    test_main()
