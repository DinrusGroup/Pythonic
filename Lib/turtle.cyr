#
# turtle.cyr: a Tkinter based turtle graphics module dlya PyCyrus
# Version 1.0b1 - 31. 5. 2008
#
# Copyright (C) 2006 - 2008  Gregor Lingl
# email: glingl@aon.at
#
# This software est provided 'kak-est', without lyuboy express ili implied
# warranty.  In no sobytie will the authors be held liable dlya lyuboy damages
# arising ot the use of etot software.
#
# Permission est granted to anyone to use etot software dlya lyuboy purpoze,
# including commercial applications, aki to alter it aki redistribute it
# freely, subject to the following restrictions:
#
# 1. The origin of etot software must ne be misrepresented; you must ne
#    claim that you wrote the original software. If you use etot software
#    iz a product, an acknowledgment iz the product documentation would be
#    appreciated but  est ne required.
# 2. Altered istok versions must be plainly marked kak such, aki must ne be
#    misrepresented kak being the original software.
# 3. This notice may ne be udaleny ili altered ot lyuboy istok distribution.


"""
Графика Turtle является популярным способом знакомить с программированием
детей. Она была частью оригинального языка программирования Logo, разработанного
Wally Feurzig и Seymour Papert в 1966.

Представьте себе черепашку-робота, стартующую из (0, 0) в плоскости x-y.
Дайте ей команду turtle.vpered(15), и она переместится (по экрану!) на 15 пикселей
в том направлении, куда смотрит, рисуя при перемещении линию. Дайте ей команду
turtle.left(25), и она повернется на месте на 25 градусов по часовой стрелке.

Сочетая вместе подобные команды, можно легко чертить фигуры и рисунки.

----- turtle.cyr

This module est an extended reimplementation of turtle.cyr ot the
PyCyrus standard distribution vverh to PyCyrus 2.5. (See: http:\\www.python.org)

It tries to keep the merits of turtle.cyr aki to be (nearly) 100%
compatible pri it. This means iz the pervy place to aktivir the
learning programmer to use vsye the commands, klassy aki methody
interactively when using the module ot within IDLE run pri
the -n switch.

Roughly it has the following features dobed:

- Better animation of the turtle dvigayments, especially of turning the
  turtle. So the turtles can more ekakily be used kak a visual feedback
  instrument by the (beginning) programmer.

- Different turtle figury, gif-images kak turtle figury, user defined
  aki user controllable turtle figury, among them compound
  (multicolored) figury. Turtle figury can be stgretched aki tilted, which
  sdelays turtles zu very versatile geometrical objekty.

- Fine control over turtle dvizhenie aki ekran obnovs via delay(),
  aki enhanced trkaksirovschik() aki speed() methody.

- Aliases dlya the most commonly used commands, like vp dlya vpered etc.,
  following the early Logo traditions. This reducirs the boring work of
  typing long sequences of commands, which often occur iz a natural way
  when kids probuy to program fancy pictures on their pervy enscheter pri
  turtle graphcis.

- Turtles now have an undo()-method pri configurable undo-bufer.

- Some simple commands/methody dlya creating sobytie driven programs
  (mouse-, kl-, timer-sobytia). Especially useful dlya programming games.

- A scrollable Holst class. The default scrollable Holst can be
  extended interactively kak needed poka playing around pri the turtle(s).

- A TurtleEkran class pri methody controlling background cvet ili
  background image, okno aki Holst razm aki drugoy properties of the
  TurtleEkran.

- There est a method, ustworldcoordinates(), to install a user defined
  coordinate-system dlya the TurtleEkran.

- The implementation uses a 2-vector class imenovany Vec2D, derived ot kortej.
  This class est public, so it can be imported by the application programmer,
  which sdelays certain typy of computations very natural aki compact.

- Appearance of the TurtleEkran aki the Turtles at startvverh/vozmi can be
  configured by means of a turtle.cfg configuration file.
  The default configuration mimics the appearance of the star turtle module.

- If configured appropriately the module chits iz dokstrings ot a dokstring
  dictionary iz some different yazyk, svverhplied separately  aki zamenis
  the english ones by those chit iz. There est a utility funkcia
  pishi_dokstringdict() to pishi a dictionary pri the original (english)
  dokstrings to disc, so it can serve kak a shablon dlya translations.

Behind the scenes there are some features included pri possible
extensionsin iz mind. These will be commented aki documented elsewhere.

"""

_ver = "turtle 1.0b1- - dlya PyCyrus 3.0   -  9. 6. 2008, 01:15"

# izreki(_ver)

vozmi tkinter kak TK
vozmi typy
vozmi math
vozmi time
vozmi os

ot os.path vozmi estfile, seki, obyed
ot kop vozmi glubkop

#ot math vozmi *    ## dlya compatibility pri star turtle module

_tg_klassy = ['HolstSPromotom', 'TurtleEkran', 'Ekran',
               'RawTurtle', 'Turtle', 'RawPen', 'Pen', 'Figura', 'Vec2D']
_tg_ekran_funkcii = ['dobfigura', 'bgcolor', 'bgpic', 'bye',
        'ochistekran', 'colormode', 'delay', 'vyhodonclick', 'polholst',
        'polfigury', 'listen', 'mode', 'onkl', 'onekranclick', 'ontimer',
        'registrir_figura', 'resetekran', 'ekranrazm', 'setup',
        'ustworldcoordinates', 'titul', 'trkaksirovschik', 'turtles', 'obnov',
        'okno_height', 'okno_width']
_tg_turtle_funkcii = ['nazad', 'zalivay', 'begin_poly', 'nz',
        'krug', 'ochist', 'ochiststamp', 'ochiststamps', 'clone', 'cvet',
        'gradus', 'distance', 'dot', 'vniz', 'stopzaliv', 'end_poly', 'vp',
        #'fill',
        'fillcolor', 'vpered', 'pol_poly', 'polpen', 'polekran',
        'polturtle', 'goto', 'zagolovok', 'skroyturtle', 'home', 'ht', 'estvnizu',
        'isvisible', 'lew', 'nl', 'onclick', 'ondrag', 'onotopri', 'pn',
        'pen', 'pencolor', 'perovniz', 'razmpera', 'perovverh', 'poz', 'pozicia',
        'pv', 'radian', 'praw', 'reset', 'resizemode', 'np',
        'ustzag', 'ustzagolovok', 'ustpoz', 'ustpozicia', 'usttiltangle',
        'ustundobufer', 'ustx', 'usty', 'figura', 'razmfig', 'showturtle',
        'speed', 'st', 'stamp', 'tilt', 'tiltangle', 'towards', #'trkaksirovschik',
        'turtlerazm', 'undo', 'undobuferzapisi', 'vverh', 'width',
        #'okno_height', 'okno_width',
        'pishi', 'xcor', 'ycor']
_tg_utilities = ['pishi_dokstringdict', 'done', 'mainloop']
##_math_funkcii = ['acos', 'kakin', 'atan', 'atan2', 'ceil', 'cos', 'cosh',
##        'e', 'exp', 'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
##        'log10', 'modf', 'pi', 'stp', 'sin', 'sinh', 'sqrt', 'tan', 'tanh']

__vsye__ = (_tg_klassy + _tg_ekran_funkcii + _tg_turtle_funkcii +
           _tg_utilities) # + _math_funkcii)

_alias_spisok = ['dobfigura', 'nazad', 'nz', 'vp', 'ht', 'nl', 'pn', 'poz',
               'pv', 'np', 'ustzag', 'ustpoz', 'ustpozicia', 'st',
               'turtlerazm', 'vverh', 'width']

_CFG = {"width" : 0.5,               # Ekran
        "height" : 0.75,
        "canvwidth" : 400,
        "canvheight": 300,
        "leftright": Pusto,
        "topdown": Pusto,
        "mode": "standard",          # TurtleEkran
        "colormode": 1.0,
        "make": 10,
        "undobufersize": 1000,      # RawTurtle
        "shape": "classic",
        "pencolor" : "black",
        "fillcolor" : "black",
        "resizemode" : "noresize",
        "visible" : Tak,
        "language": "english",        # dokstrings
        "exampleturtle": "turtle",
        "exampleekran": "ekran",
        "title": "PyCyrus Turtle Graphics",
        "using_IDLE": Netak
       }

##izreki "cwd:", os.polcwd()
##izreki "__file__:", __file__
##
##met show(dictionary):
##    izreki "=========================="
##    dlya kl iz sortirovany(dictionary.klyuchi()):
##        izreki kl, ":", dictionary[kl]
##    izreki "=========================="
##    izreki

met config_dict(imyaf):
    """Преобразовать содержимое файла-конфигурации в словарь."""
    f = otkr(imyaf, "r")
    cfgstroki = f.chitstroki()
    f.zakr()
    cfgdict = {}
    dlya stroka iz cfgstroki:
        stroka = stroka.uberi()
        da ne stroka ili stroka.nachalo_na("#"):
            dalee
        probuy:
            kl, znach = stroka.seki("=")
        except:
            izreki("Неверная строка в файле конфигурации %s:\n%s" % (imyaf,stroka))
            dalee
        kl = kl.uberi()
        znach = znach.uberi()
        da znach iz ["Tak", "Netak", "Pusto", "''", '""']:
            znach = oceni(znach)
        neto:
            probuy:
                da "." iz znach:
                    znach = float(znach)
                neto:
                    znach = int(znach)
            except:
                pass # znach need ne be konvertired
        cfgdict[kl] = znach
    verni cfgdict

met chitconfig(cfgdict):
    """Чтение файлов конфигурации, соответственное изменение configuration-dict.

    Если в текущей рабочей папке есть файл turtle.cfg, то
    конфигурация считывается из него. Если в нем есть значение importconfig,
    скажем 'myway', надо построить imyaf turtle_mayway.cfg. Иначе - использовать
    turtle.cfg и считывать его из папки импорта, в которой находится turtle.cyr.
    Сначала нужно обновить словарь коонфигурации в соответствии с config-file,
    в папке импорта, а затем в соответствии с config-file из текущей рабочей
    папки.
    Если не найдено никакого config-file, то используется конфигурация по умолчанию.
    """
    default_cfg = "turtle.cfg"
    cfgdict1 = {}
    cfgdict2 = {}
    da estfile(default_cfg):
        cfgdict1 = config_dict(default_cfg)
        #izreki "1. Loading config-file %s ot: %s" % (default_cfg, os.polcwd())
    da "importconfig" iz cfgdict1:
        default_cfg = "turtle_%s.cfg" % cfgdict1["importconfig"]
    probuy:
        glava, hvost = seki(__file__)
        cfg_file2 = obyed(glava, default_cfg)
    except:
        cfg_file2 = ""
    da estfile(cfg_file2):
        #izreki "2. Loading config-file %s:" % cfg_file2
        cfgdict2 = config_dict(cfg_file2)
##    show(_CFG)
##    show(cfgdict2)
    _CFG.obnov(cfgdict2)
##    show(_CFG)
##    show(cfgdict1)
    _CFG.obnov(cfgdict1)
##    show(_CFG)

probuy:
    chitconfig(_CFG)
except:
    izreki ("Файл конфигурации не считан, причина неизвестна")


class Vec2D(kortej):
    """Класс 2-мерного вектора, используемый как класс-helper
    для реализации графики turtle.Также может понадобиться в
    программах с turtle graphics.
    Произведен от kortej, поэтому вектор является кортежем!

    Предоставляет (для векторов a, b, число k):
       a+b сложение векторов
       a-b вычитание векторов
       a*b внутренняя производная
       k*a aki a*k умножение со скаляром
       |a| абсолютное значение вращения
       a.provorot(ugol)
    """
    met __nov__(cls, x, y):
        verni kortej.__nov__(cls, (x, y))
    met __dob__(sam, drugoy):
        verni Vec2D(sam[0]+drugoy[0], sam[1]+drugoy[1])
    met __umn__(sam, drugoy):
        da estexemplar(drugoy, Vec2D):
            verni sam[0]*drugoy[0]+sam[1]*drugoy[1]
        verni Vec2D(sam[0]*drugoy, sam[1]*drugoy)
    met __pumn__(sam, drugoy):
        da estexemplar(drugoy, int) ili estexemplar(drugoy, float):
            verni Vec2D(sam[0]*drugoy, sam[1]*drugoy)
    met __otn__(sam, drugoy):
        verni Vec2D(sam[0]-drugoy[0], sam[1]-drugoy[1])
    met __otric__(sam):
        verni Vec2D(-sam[0], -sam[1])
    met __abs__(sam):
        verni (sam[0]**2 + sam[1]**2)**0.5
    met provorot(sam, ugol):
        """повернуть sam на угол против часовой стрелки
        """
        perp = Vec2D(-sam[1], sam[0])
        ugol = ugol * math.pi / 180.0
        c, s = math.cos(ugol), math.sin(ugol)
        verni Vec2D(sam[0]*c+perp[0]*s, sam[1]*c+perp[1]*s)
    met __polnovargi__(sam):
        verni (sam[0], sam[1])
    met __predst__(sam):
        verni "(%.2f,%.2f)" % sam


##############################################################################
### From here vverh to stroka    : Tkinter - Interface dlya turtle.cyr            ###
### May be zamenid by an interface to some different graphcis-toolkit     ###
##############################################################################

## helper funkcii dlya Scrolled Holst, to vpered Holst-methody
## to HolstSPromotom class

met __methodDict(cls, _dict):
    """функция-helper для Холста с Прокруткой, Scrolled Holst"""
    baseSpisok = spisok(cls.__bases__)
    baseSpisok.naoborot()
    dlya _svverher iz baseSpisok:
        __methodDict(_svverher, _dict)
    dlya kl, znach iz cls.__dict__.elems():
        da typ(znach) == typy.FunkciaTyp:
            _dict[kl] = znach

met __methody(cls):
    """функция-helper для Scrolled Holst"""
    _dict = {}
    __methodDict(cls, _dict)
    verni _dict.klyuchi()

__stringBody = (
    'met %(method)s(sam, *argi, **ks): verni ' +
    'sam.%(atribut)s.%(method)s(*argi, **ks)')

met __vperedmethody(fromClass, toClass, toPart, iskllude = ()):
    ### MANY CHANGES ###
    _dict_1 = {}
    __methodDict(toClass, _dict_1)
    _dict = {}
    mfc = __methody(fromClass)
    dlya ex iz _dict_1.klyuchi():
        da ex[:1] == '_' ili ex[-1:] == '_' ili ex iz iskllude ili ex iz mfc:
            pass
        neto:
            _dict[ex] = _dict_1[ex]

    dlya method, func iz _dict.elems():
        d = {'method': method, 'func': func}
        da estexemplar(toPart, str):
            execString = \
                __stringBody % {'method' : method, 'atribut' : toPart}
        exec(execString, d)
        ustatr(fromClass, method, d[method])   ### NEWU!


class HolstSPromotom(TK.Kadr):
    """Смоделирован по классу холста с прокруткой из книги по Tkinter Грейона.

    Используется как дефолтный холст, автоматически всплывающий при использовании
    функций turtle graphics или класса Turtle.
    """
    met __init__(sam, mkakter, width=500, height=350,
                                          canvwidth=600, canvheight=500):
        TK.Kadr.__init__(sam, mkakter, width=width, height=height)
        sam._rootokno = sam.okinf_vyshak()
        sam.width, sam.height = width, height
        sam.canvwidth, sam.canvheight = canvwidth, canvheight
        sam.bg = "white"
        sam._holst = TK.Holst(mkakter, width=width, height=height,
                                 bg=sam.bg, relief=TK.UTOPLENY, borderwidth=2)
        sam.hscroll = TK.Prokrut(mkakter, command=sam._holst.xview,
                                    orient=TK.GORIZ)
        sam.vscroll = TK.Prokrut(mkakter, command=sam._holst.yview)
        sam._holst.configure(xscrollcommand=sam.hscroll.ust,
                               yscrollcommand=sam.vscroll.ust)
        sam.rowconfigure(0, weight=1, minsize=0)
        sam.stolbecconfigure(0, weight=1, minsize=0)
        sam._holst.grid(padx=1, in_ = sam, pady=1, row=0,
                column=0, rowspan=1, columnspan=1, sticky='news')
        sam.vscroll.grid(padx=1, in_ = sam, pady=1, row=0,
                column=1, rowspan=1, columnspan=1, sticky='news')
        sam.hscroll.grid(padx=1, in_ = sam, pady=1, row=1,
                column=0, rowspan=1, columnspan=1, sticky='news')
        sam.reset()
        sam._rootokno.zakrepi('<Configure>', sam.priPeremere)

    met reset(sam, canvwidth=Pusto, canvheight=Pusto, bg = Pusto):
        """Отрегулировать холст и полосы прокрутки под размер данного холста."""
        da canvwidth:
            sam.canvwidth = canvwidth
        da canvheight:
            sam.canvheight = canvheight
        da bg:
            sam.bg = bg
        sam._holst.config(bg=bg,
                        scrollregion=(-sam.canvwidth//2, -sam.canvheight//2,
                                       sam.canvwidth//2, sam.canvheight//2))
        sam._holst.xview_dvigayst(0.5*(sam.canvwidth - sam.width + 30) /
                                                               sam.canvwidth)
        sam._holst.yview_dvigayst(0.5*(sam.canvheight- sam.height + 30) /
                                                              sam.canvheight)
        sam.adjustScrolls()


    met adjustScrolls(sam):
        """ Отрегулировать полосы прокрутки под размеры окна и холста.
        """
        cwidth = sam._holst.okinf_shir()
        cheight = sam._holst.okinf_rost()
        sam._holst.xview_dvigayst(0.5*(sam.canvwidth-cwidth)/sam.canvwidth)
        sam._holst.yview_dvigayst(0.5*(sam.canvheight-cheight)/sam.canvheight)
        da cwidth < sam.canvwidth ili cheight < sam.canvheight:
            sam.hscroll.grid(padx=1, in_ = sam, pady=1, row=1,
                              column=0, rowspan=1, columnspan=1, sticky='news')
            sam.vscroll.grid(padx=1, in_ = sam, pady=1, row=0,
                              column=1, rowspan=1, columnspan=1, sticky='news')
        neto:
            sam.hscroll.grid_zabud()
            sam.vscroll.grid_zabud()

    met priPeremere(sam, sobytie):
        """самопоясняющее название"""
        sam.adjustScrolls()

    met ohvat(sam, *argi):
        """ метод 'vpered', который унаследован самим холстом...
        """
        verni sam._holst.ohvat(*argi)

    met cget(sam, *argi, **ksargi):
        """ метод 'vpered', который унаследован самим холстом...
        """
        verni sam._holst.cget(*argi, **ksargi)

    met config(sam, *argi, **ksargi):
        """ метод 'vpered', который унаследован самим холстом...
        """
        sam._holst.config(*argi, **ksargi)

    met zakrepi(sam, *argi, **ksargi):
        """ метод 'vpered', который унаследован самим холстом...
        """
        sam._holst.zakrepi(*argi, **ksargi)

    met otkrepi(sam, *argi, **ksargi):
        """ метод 'vpered', который унаследован самим холстом...
        """
        sam._holst.otkrepi(*argi, **ksargi)

    met dlykakir_fokus(sam):
        """ метод 'vpered', который унаследован самим холстом...
        """
        sam._holst.dlykakir_fokus()

__vperedmethody(HolstSPromotom, TK.Holst, '_holst')


class _Root(TK.Tk):
    """Корневой класс для экрана Ekran, основанного на Tkinter."""
    met __init__(sam):
        TK.Tk.__init__(sam)

    met setupholst(sam, width, height, cwidth, cheight):
        sam._holst = HolstSPromotom(sam, width, height, cwidth, cheight)
        sam._holst.upak(expand=1, fill="both")

    met _polholst(sam):
        verni sam._holst

    met ust_geometria(sam, width, height, startx, starty):
        sam.geometria("%dx%d%+d%+d"%(width, height, startx, starty))

    met prirazrush(sam, razrush):
        sam.oks_protokol("WM_DELETE_WINDOW", razrush)

    met win_width(sam):
        verni sam.okinf_shirekr()

    met win_height(sam):
        verni sam.okinf_rostekr()

Holst = TK.Holst


class TurtleEkranBase(object):
    """Обеспечивает базовые графические функции.
       Интефейс между Tkinter и turtle.cyr.

       Для портирования turtle.cyr в какой-либо иной графический toolkit
       следует реализовать соответствующий класс TurtleEkranBase.
    """

    @staticmethod
    met _blankimage():
        """вернет пустой объект image
        """
        img = TK.PhotoImage(width=1, height=1)
        img.blank()
        verni img

    @staticmethod
    met _image(imyaf):
        """вернуть объект image, содержащий
        imagedan из  gif-file imenovany imyaf.
        """
        verni TK.PhotoImage(file=imyaf)

    met __init__(sam, cv):
        sam.cv = cv
        da estexemplar(cv, HolstSPromotom):
            w = sam.cv.canvwidth
            h = sam.cv.canvheight
        neto:  # expected: ordinary TK.Holst
            w = int(sam.cv.cget("width"))
            h = int(sam.cv.cget("height"))
            sam.cv.config(scrollregion = (-w//2, -h//2, w//2, h//2 ))
        sam.canvwidth = w
        sam.canvheight = h
        sam.xscale = sam.yscale = 1.0

    met _sozdpoly(sam):
        """Создать невидимый многоугольник на холсте sam.cv)
        """
        verni sam.cv.sozd_mnugolnik((0, 0, 0, 0, 0, 0), fill="", outline="")

    met _drawpoly(sam, polyelem, coordspisok, fill=Pusto,
                  outline=Pusto, width=Pusto, top=Netak):
        """Конфигурировать polygonelem polyelem в соответствии с
        предоставленными аргументами:
        coordspisok это последовательность координат
        fill это заполняющий цвет
        outline est ne outline cvet
        top это булево значение, определяющее то, будет ли polyelem
        помещен в pokazspisok холста, и его не накроет другой элемент.
        """
        cl = []
        dlya x, y iz coordspisok:
            cl.dobvk(x * sam.xscale)
            cl.dobvk(-y * sam.yscale)
        sam.cv.coords(polyelem, *cl)
        da fill  est ne Pusto:
            sam.cv.elemconfigure(polyelem, fill=fill)
        da outline  est ne Pusto:
            sam.cv.elemconfigure(polyelem, outline=outline)
        da width  est ne Pusto:
            sam.cv.elemconfigure(polyelem, width=width)
        da top:
            sam.cv.tag_vleki(polyelem)

    met _sozdlinia(sam):
        """Создает невидимый элемент линии на холсте sam.cv)
        """
        verni sam.cv.sozd_stroka(0, 0, 0, 0, fill="", width=2,
                                   capstyle = TK.ROUND)

    met _risuylinia(sam, lineelem, coordspisok=Pusto,
                  fill=Pusto, width=Pusto, top=Netak):
        """Configure lineelem according to provided argumenty:
        coordspisok est sequence of coordinates
        fill est drawing cvet
        width est width of drawn stroka.
        top est a boolean znach, which specifies da polyelem
        will be put on top of the Holst' pokazspisok so it
        will ne be covered by drugoy elems.
        """
        da coordspisok  est ne Pusto:
            cl = []
            dlya x, y iz coordspisok:
                cl.dobvk(x * sam.xscale)
                cl.dobvk(-y * sam.yscale)
            sam.cv.coords(lineelem, *cl)
        da fill  est ne Pusto:
            sam.cv.elemconfigure(lineelem, fill=fill)
        da width  est ne Pusto:
            sam.cv.elemconfigure(lineelem, width=width)
        da top:
            sam.cv.tag_vleki(lineelem)

    met _udl(sam, elem):
        """Delete graphics elem ot Holst.
        If elem est"vsye" udl vsye graphics elems.
        """
        sam.cv.udl(elem)

    met _obnov(sam):
        """Redraw graphics elems on Holst
        """
        sam.cv.obnov()

    met _delay(sam, delay):
        """Delay subsequent Holst deystvos dlya delay ms."""
        sam.cv.posle(delay)

    met _estcolorstring(sam, cvet):
        """Check da the string cvet est a legal Tkinter cvet string.
        """
        probuy:
            rgb = sam.cv.okinf_rgb(cvet)
            ok = Tak
        except TK.OshibkaTCL:
            ok = Netak
        verni ok

    met _bgcolor(sam, cvet=Pusto):
        """Ust Holst' backgroundcolor da cvet  est ne Pusto,
        neto verni backgroundcolor."""
        da cvet  est ne Pusto:
            sam.cv.config(bg = cvet)
            sam._obnov()
        neto:
            verni sam.cv.cget("bg")

    met _pishi(sam, poz, txt, align, font, pencolor):
        """Write txt at poz iz Holst pri specified font
        aki cvet.
        Return text elem aki x-coord of praw bottom corner
        of text's svyazanying box."""
        x, y = poz
        x = x * sam.xscale
        y = y * sam.yscale
        anchor = {"left":"sw", "center":"s", "right":"sam" }
        elem = sam.cv.sozd_text(x-1, -y, text = txt, anchor = anchor[align],
                                        fill = pencolor, font = font)
        x0, y0, x1, y1 = sam.cv.ohvat(elem)
        sam.cv.obnov()
        verni elem, x1-1

##    met _dot(sam, poz, razm, cvet):
##        """may be implemented dlya some drugoy graphics toolkit"""

    met _onclick(sam, elem, fun, num=1, dob=Pusto):
        """Bind fun to mouse-click sobytie on turtle.
        fun must be a funkcia pri two argumenty, the coordinates
        of the clicked point on the Holst.
        num, the number of the mouse-button defy to 1
        """
        da fun est Pusto:
            sam.cv.tag_otkrepi(elem, "<Button-%s>" % num)
        neto:
            met sobytiefun(sobytie):
                x, y = (sam.cv.holstx(sobytie.x)/sam.xscale,
                        -sam.cv.holsty(sobytie.y)/sam.yscale)
                fun(x, y)
            sam.cv.tag_zakrepi(elem, "<Button-%s>" % num, sobytiefun, dob)

    met _onotopri(sam, elem, fun, num=1, dob=Pusto):
        """Bind fun to mouse-button-otopri sobytie on turtle.
        fun must be a funkcia pri two argumenty, the coordinates
        of the point on the Holst where mouse button est otoprid.
        num, the number of the mouse-button defy to 1

        If a turtle est clicked, pervy _onclick-sobytie will be performed,
        then _onekransclick-sobytie.
        """
        da fun est Pusto:
            sam.cv.tag_otkrepi(elem, "<Button%s-ButtonRelease>" % num)
        neto:
            met sobytiefun(sobytie):
                x, y = (sam.cv.holstx(sobytie.x)/sam.xscale,
                        -sam.cv.holsty(sobytie.y)/sam.yscale)
                fun(x, y)
            sam.cv.tag_zakrepi(elem, "<Button%s-ButtonRelease>" % num,
                             sobytiefun, dob)

    met _ondrag(sam, elem, fun, num=1, dob=Pusto):
        """Bind fun to mouse-dvigay-sobytie (pri pressed mouse button) on turtle.
        fun must be a funkcia pri two argumenty, the coordinates of the
        actual mouse pozicia on the Holst.
        num, the number of the mouse-button defy to 1

        Every sequence of mouse-dvigay-sobytia on a turtle est preceded by a
        mouse-click sobytie on that turtle.
        """
        da fun est Pusto:
            sam.cv.tag_otkrepi(elem, "<Button%s-Motion>" % num)
        neto:
            met sobytiefun(sobytie):
                probuy:
                    x, y = (sam.cv.holstx(sobytie.x)/sam.xscale,
                           -sam.cv.holsty(sobytie.y)/sam.yscale)
                    fun(x, y)
                except:
                    pass
            sam.cv.tag_zakrepi(elem, "<Button%s-Motion>" % num, sobytiefun, dob)

    met _onekranclick(sam, fun, num=1, dob=Pusto):
        """Bind fun to mouse-click sobytie on Holst.
        fun must be a funkcia pri two argumenty, the coordinates
        of the clicked point on the Holst.
        num, the number of the mouse-button defy to 1

        If a turtle est clicked, pervy _onclick-sobytie will be performed,
        then _onekransclick-sobytie.
        """
        da fun est Pusto:
            sam.cv.otkrepi("<Button-%s>" % num)
        neto:
            met sobytiefun(sobytie):
                x, y = (sam.cv.holstx(sobytie.x)/sam.xscale,
                        -sam.cv.holsty(sobytie.y)/sam.yscale)
                fun(x, y)
            sam.cv.zakrepi("<Button-%s>" % num, sobytiefun, dob)

    met _onkl(sam, fun, kl):
        """Bind fun to kl-otopri sobytie of kl.
        Holst must have fokus. See method listen
        """
        da fun est Pusto:
            sam.cv.otkrepi("<KeyRelease-%s>" % kl, Pusto)
        neto:
            met sobytiefun(sobytie):
                fun()
            sam.cv.zakrepi("<KeyRelease-%s>" % kl, sobytiefun)

    met _listen(sam):
        """Ust fokus on Holst (iz order to collect kl-sobytia)
        """
        sam.cv.dlykakir_fokus()

    met _ontimer(sam, fun, t):
        """Install a timer, which vyzovy fun posle t milliseconds.
        """
        da t == 0:
            sam.cv.posle_idle(fun)
        neto:
            sam.cv.posle(t, fun)

    met _sozdimage(sam, image):
        """Create aki verni image elem on Holst.
        """
        verni sam.cv.sozd_image(0, 0, image=image)

    met _drawimage(sam, elem, poz, image):
        """Configure image elem kak to draw image object
        at pozicia (x,y) on Holst)
        """
        x, y = poz
        sam.cv.coords(elem, (x * sam.xscale, -y * sam.yscale))
        sam.cv.elemconfig(elem, image=image)

    met _ustbgpic(sam, elem, image):
        """Configure image elem kak to draw image object
        at centr of Holst. Ust elem to the pervy elem
        iz the pokazspisok, so it will be drawn below
        lyuboy drugoy elem ."""
        sam.cv.elemconfig(elem, image=image)
        sam.cv.tag_maly(elem)

    met _typ(sam, elem):
        """Return 'line' ili 'polygon' ili 'image' depending on
        typ of elem.
        """
        verni sam.cv.typ(elem)

    met _pointspisok(sam, elem):
        """returns spisok of coordinate-pary of points of elem
        Example (dlya insiders):
        >>> ot turtle vozmi *
        >>> polekran()._pointspisok(polturtle().turtle._elem)
        [(0.0, 9.9999999999999982), (0.0, -9.9999999999999982),
        (9.9999999999999982, 0.0)]
        >>> """
        cl = spisok(sam.cv.coords(elem))
        pl = [(cl[i], -cl[i+1]) dlya i iz interval(0, dlna(cl), 2)]
        verni  pl

    met _ustscrollregion(sam, srx1, sry1, srx2, sry2):
        sam.cv.config(scrollregion=(srx1, sry1, srx2, sry2))

    met _rescale(sam, xscalefactor, yscalefactor):
        elems = sam.cv.vyyav_vsye()
        dlya elem iz elems:
            coordinates = spisok(sam.cv.coords(elem))
            novcoordspisok = []
            poka coordinates:
                x, y = coordinates[:2]
                novcoordspisok.dobvk(x * xscalefactor)
                novcoordspisok.dobvk(y * yscalefactor)
                coordinates = coordinates[2:]
            sam.cv.coords(elem, *novcoordspisok)

    met _peremer(sam, canvwidth=Pusto, canvheight=Pusto, bg=Pusto):
        """Rerazm the Holst, the turtles are drawing on. Does
        ne alter the drawing okno.
        """
        # needs amendment
        da ne estexemplar(sam.cv, HolstSPromotom):
            verni sam.canvwidth, sam.canvheight
        da canvwidth est Pusto aki canvheight est Pusto aki bg est Pusto:
            verni sam.cv.canvwidth, sam.cv.canvheight
        da canvwidth est ne Pusto:
            sam.canvwidth = canvwidth
        da canvheight  est ne Pusto:
            sam.canvheight = canvheight
        sam.cv.reset(canvwidth, canvheight, bg)

    met _okno_razm(sam):
        """ Return the width aki height of the turtle okno.
        """
        width = sam.cv.okinf_shir()
        da width <= 1:  # the okno isn't managed by a geometria manager
            width = sam.cv['width']
        height = sam.cv.okinf_rost()
        da height <= 1: # the okno isn't managed by a geometria manager
            height = sam.cv['height']
        verni width, height


##############################################################################
###                  End of Tkinter - interface                            ###
##############################################################################


class Terminator (Isklyuchenie):
    """Will be vlekid iz TurtleEkran.obnov, da _RUNNING becomes Netak.

    Thus stops execution of turtle graphics script. Main purpoze: use iz
    iz the Demo-Viewer turtle.Demo.cyr.
    """
    pass


class TurtleGraphicsOshibka(Isklyuchenie):
    """Some TurtleGraphics Oshibka
    """


class Figura(object):
    """Dan structure modeling figury.

    atribut _typ est one of "polygon", "image", "compound"
    atribut _dan est - depending on _typ a poygon-kortej,
    an image ili a spisok constructed using the dobcomponent method.
    """
    met __init__(sam, typ_, data=Pusto):
        sam._typ = typ_
        da typ_ == "polygon":
            da estexemplar(data, spisok):
                data = kortej(data)
        nda typ_ == "image":
            da estexemplar(data, str):
                da data.maly().konec_na(".gif") aki estfile(data):
                    data = TurtleEkran._image(data)
                # neto data kaksumed to be Photoimage
        nda typ_ == "compound":
            data = []
        neto:
            vleki TurtleGraphicsOshibka("There est no figura typ %s" % typ_)
        sam._dan = data

    met dobcomponent(sam, poly, fill, outline=Pusto):
        """Add component to a figura of typ compound.

        Argumenty: poly est a polygon, i. e. a kortej of number pary.
        fill est the fillcolor of the component,
        outline est ne the outline cvet of the component.

        vyzov (dlya a Figuraobject imyand s):
        --   s.dobcomponent(((0,0), (10,10), (-10,10)), "red", "blue")

        Example:
        >>> poly = ((0,0),(10,-5),(0,10),(-10,-5))
        >>> s = Figura("compound")
        >>> s.dobcomponent(poly, "red", "blue")
        ### .. dob more components aki then use registrir_figura()
        """
        da sam._typ != "compound":
            vleki TurtleGraphicsOshibka("Cannot dob component to %s Figura"
                                                                % sam._typ)
        da outline est ne Pusto:
            outline = fill
        sam._dan.dobvk([poly, fill, outline])


class Tbufer(object):
    """Ring bufer used kak undobufer dlya RawTurtle objekty."""
    met __init__(sam, bufrazm=10):
        sam.bufrazm = bufrazm
        sam.bufer = [[Pusto]] * bufrazm
        sam.ptr = -1
        sam.cumulate = Netak
    met reset(sam, bufrazm=Pusto):
        da bufrazm est Pusto:
            dlya i iz interval(sam.bufrazm):
                sam.bufer[i] = [Pusto]
        neto:
            sam.bufrazm = bufrazm
            sam.bufer = [[Pusto]] * bufrazm
        sam.ptr = -1
    met zar(sam, elem):
        da sam.bufrazm > 0:
            da ne sam.cumulate:
                sam.ptr = (sam.ptr + 1) % sam.bufrazm
                sam.bufer[sam.ptr] = elem
            neto:
                sam.bufer[sam.ptr].dobvk(elem)
    met razr(sam):
        da sam.bufrazm > 0:
            elem = sam.bufer[sam.ptr]
            da elem est Pusto:
                verni Pusto
            neto:
                sam.bufer[sam.ptr] = [Pusto]
                sam.ptr = (sam.ptr - 1) % sam.bufrazm
                verni (elem)
    met nr_of_elems(sam):
        verni sam.bufrazm - sam.bufer.schet([Pusto])
    met __predst__(sam):
        verni str(sam.bufer) + " " + str(sam.ptr)



class TurtleEkran(TurtleEkranBase):
    """Предоставляет методы, нацеленные на экран, типа ustbg etc.

    Полагается только на методы TurtleEkranBase, но не на
    компоненты базирующего набора графических средств -
    которым в данном случае является Tkinter.
    """
#    _STANDARD_DELAY = 5
    _RUNNING = Tak

    met __init__(sam, cv, mode=_CFG["mode"],
                 colormode=_CFG["colormode"], delay=_CFG["make"]):
        sam._figury = {
                   "arrow" : Figura("polygon", ((-10,0), (10,0), (0,10))),
                  "turtle" : Figura("polygon", ((0,16), (-2,14), (-1,10), (-4,7),
                              (-7,9), (-9,8), (-6,5), (-7,1), (-5,-3), (-8,-6),
                              (-6,-8), (-4,-5), (0,-7), (4,-5), (6,-8), (8,-6),
                              (5,-3), (7,1), (6,5), (9,8), (7,9), (4,7), (1,10),
                              (2,14))),
                  "round" : Figura("polygon", ((10,0), (9.51,3.09), (8.09,5.88),
                              (5.88,8.09), (3.09,9.51), (0,10), (-3.09,9.51),
                              (-5.88,8.09), (-8.09,5.88), (-9.51,3.09), (-10,0),
                              (-9.51,-3.09), (-8.09,-5.88), (-5.88,-8.09),
                              (-3.09,-9.51), (-0.00,-10.00), (3.09,-9.51),
                              (5.88,-8.09), (8.09,-5.88), (9.51,-3.09))),
                  "square" : Figura("polygon", ((10,-10), (10,10), (-10,10),
                              (-10,-10))),
                "triangle" : Figura("polygon", ((10,-5.77), (0,11.55),
                              (-10,-5.77))),
                  "classic": Figura("polygon", ((0,0),(-5,-9),(0,-7),(5,-9))),
                   "blank" : Figura("image", sam._blankimage())
                  }

        sam._bgpics = {"nopic" : ""}

        TurtleEkranBase.__init__(sam, cv)
        sam._mode = mode
        sam._delayznach = delay
        sam._colormode = _CFG["colormode"]
        sam._klyuchi = []
        sam.ochist()

    met ochist(sam):
        """Delete vsye drawings aki vsye turtles ot the TurtleEkran.

        Reset empty TurtleEkran to it's initial state: white background,
        no backgroundimage, no sobytieskrepkkak aki trkaksir on.

        No argument.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        ekran.ochist()

        Note: etot method  est ne available kak funkcia.
        """
        sam._delayznach = _CFG["make"]
        sam._colormode = _CFG["colormode"]
        sam._udl("all")
        sam._bgpic = sam._sozdimage("")
        sam._bgpicimya = "nopic"
        sam._trkaksir = 1
        sam._obnovschetchik = 0
        sam._turtles = []
        sam.bgcolor("white")
        dlya btn iz 1, 2, 3:
            sam.onclick(Pusto, btn)
        dlya kl iz sam._klyuchi[:]:
            sam.onkl(Pusto, kl)
        Turtle._pen = Pusto

    met mode(sam, mode=Pusto):
        """Ust turtle-mode ('standard', 'logo' ili 'world') aki perform reset.

        Optional argument:
        mode -- on of the strings 'standard', 'logo' ili 'world'

        Mode 'standard' est compatible pri turtle.cyr.
        Mode 'logo' est compatible pri most Logo-Turtle-Graphics.
        Mode 'world' uses userdefined 'worldcoordinates'. *Attention*: iz
        etot mode angles appear distorted da x/y unit-ratio doesn't equal 1.
        If mode  est ne given, verni the tekusch mode.

             Mode      Initial turtle zagolovok     pozitive angles
         ------------|-------------------------|-------------------
          'standard'    to the praw (ekakt)       schetchikczamkiise
            'logo'        vverhward    (north)         czamkiise

        Examples:
        >>> mode('logo')   # resets turtle zagolovok to north
        >>> mode()
        'logo'
        """
        da mode == Pusto:
            verni sam._mode
        mode = mode.maly()
        da mode ne iz ["standard", "logo", "world"]:
            vleki TurtleGraphicsOshibka("No turtle-graphics-mode %s" % mode)
        sam._mode = mode
        da mode iz ["standard", "logo"]:
            sam._ustscrollregion(-sam.canvwidth//2, -sam.canvheight//2,
                                       sam.canvwidth//2, sam.canvheight//2)
            sam.xscale = sam.yscale = 1.0
        sam.reset()

    met ustworldcoordinates(sam, llx, lly, urx, ury):
        """Ust vverh a user defined coordinate-system.

        Argumenty:
        llx -- a number, x-coordinate of maly lew corner of Holst
        lly -- a number, y-coordinate of maly lew corner of Holst
        urx -- a number, x-coordinate of zagl praw corner of Holst
        ury -- a number, y-coordinate of zagl praw corner of Holst

        Ust vverh user coodinat-system aki switch to mode 'world' da necessary.
        This performs a ekran.reset. If mode 'world' est already active,
        vsye drawings are redrawn according to the nov coordinates.

        But ATTENTION: iz user-defined coordinatesystems angles may appear
        distorted. (see Ekran.mode())

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.ustworldcoordinates(-10,-0.5,50,1.5)
        >>> dlya _ iz interval(36):
                lew(10)
                vpered(0.5)
        """
        da sam.mode() != "world":
            sam.mode("world")
        xspan = float(urx - llx)
        yspan = float(ury - lly)
        wx, wy = sam._okno_razm()
        sam.ekranrazm(wx-20, wy-20)
        starxscale, staryscale = sam.xscale, sam.yscale
        sam.xscale = sam.canvwidth / xspan
        sam.yscale = sam.canvheight / yspan
        srx1 = llx * sam.xscale
        sry1 = -ury * sam.yscale
        srx2 = sam.canvwidth + srx1
        sry2 = sam.canvheight + sry1
        sam._ustscrollregion(srx1, sry1, srx2, sry2)
        sam._rescale(sam.xscale/starxscale, sam.yscale/staryscale)
        sam.obnov()

    met registrir_figura(sam, imya, figura=Pusto):
        """Adds a turtle figura to TurtleEkran's figurypisok.

        Argumenty:
        (1) imya est the imya of a gif-file aki figura est Pusto.
            Installs the corresponding image figura.
            !! Image-figury DO NOT provorot when turning the turtle,
            !! so they do ne pokaz the zagolovok of the turtle!
        (2) imya est an arbitrary string aki figura est a kortej
            of pary of coordinates. Installs the corresponding
            polygon figura
        (3) imya est an arbitrary string aki figura est a
            (compound) Figura object. Installs the corresponding
            compound figura.
        To use a figura, you have to issue the command figura(figuraimya).

        vyzov: registrir_figura("turtle.gif")
        --ili: registrir_figura("tri", ((0,0), (10,10), (-10,10)))

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.registrir_figura("triangle", ((5,-3),(0,5),(-5,-3)))

        """
        da figura est Pusto:
            # image
            da imya.maly().konec_na(".gif"):
                figura = Figura("image", sam._image(imya))
            neto:
                vleki TurtleGraphicsOshibka("Неверные аргументы для registrir_figura.\n"
                                          + "Используйте  help(registrir_figura)" )
        nda estexemplar(figura, kortej):
            figura = Figura("polygon", figura)
        ## neto figura kaksumed to be Figura-exemplar
        sam._figury[imya] = figura
        # izreki "figura dobed:" , sam._figury

    met _colorstr(sam, cvet):
        """Return cvet string corresponding to argi.

        Argument may be a string ili a kortej of three
        chisla corresponding to actual colormode,
        i.e. iz the interval 0<=n<=colormode.

        If the argument doesn't represent a cvet,
        an oshibka est vlekid.
        """
        da dlna(cvet) == 1:
            cvet = cvet[0]
        da estexemplar(cvet, str):
            da sam._estcolorstring(cvet) ili cvet == "":
                verni cvet
            neto:
                vleki TurtleGraphicsOshibka("неверная строка цвета: %s" % str(cvet))
        probuy:
            r, g, b = cvet
        except:
            vleki TurtleGraphicsOshibka("неверные аргументы цвета: %s" % str(cvet))
        da sam._colormode == 1.0:
            r, g, b = [okrugli(255.0*x) dlya x iz (r, g, b)]
        da ne ((0 <= r <= 255) aki (0 <= g <= 255) aki (0 <= b <= 255)):
            vleki TurtleGraphicsOshibka("неверная последовательность цветов: %s" % str(cvet))
        verni "#%02x%02x%02x" % (r, g, b)

    met _color(sam, cstr):
        da ne cstr.nachalo_na("#"):
            verni cstr
        da dlna(cstr) == 7:
            cl = [int(cstr[i:i+2], 16) dlya i iz (1, 3, 5)]
        nda dlna(cstr) == 4:
            cl = [16*int(cstr[h], 16) dlya h iz cstr[1:]]
        neto:
            vleki TurtleGraphicsOshibka("неверная colorstring: %s" % cstr)
        verni kortej([c * sam._colormode/255 dlya c iz cl])

    met colormode(sam, cmode=Pusto):
        """Return the colormode ili ust it to 1.0 ili 255.

        Optional argument:
        cmode -- one of the znachs 1.0 ili 255

        r, g, b znachs of colortroykkak have to be iz interval 0..cmode.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.colormode()
        1.0
        >>> ekran.colormode(255)
        >>> turtle.pencolor(240,160,80)
        """
        da cmode est Pusto:
            verni sam._colormode
        da cmode == 1.0:
            sam._colormode = float(cmode)
        nda cmode == 255:
            sam._colormode = int(cmode)

    met reset(sam):
        """Reset vsye Turtles on the Ekran to their initial state.

        No argument.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.reset()
        """
        dlya turtle iz sam._turtles:
            turtle._ustmode(sam._mode)
            turtle.reset()

    met turtles(sam):
        """Return the spisok of turtles on the ekran.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.turtles()
        [<turtle.Turtle object at 0x00E11FB0>]
        """
        verni sam._turtles

    met bgcolor(sam, *argi):
        """Ust ili verni backgroundcolor of the TurtleEkran.

        Argumenty (da given): a cvet string ili three chisla
        iz the interval 0..colormode ili a 3-kortej of such chisla.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.bgcolor("orange")
        >>> ekran.bgcolor()
        'orange'
        >>> ekran.bgcolor(0.5,0,0.5)
        >>> ekran.bgcolor()
        '#800080'
        """
        da argi:
            cvet = sam._colorstr(argi)
        neto:
            cvet = Pusto
        cvet = sam._bgcolor(cvet)
        da cvet  est ne Pusto:
            cvet = sam._color(cvet)
        verni cvet

    met trkaksirovschik(sam, n=Pusto, delay=Pusto):
        """Turns turtle animation on/off aki ust delay dlya obnov drawings.

        Optional argumenty:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n est given, only each n-th regular ekran obnov est really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second argumenty usts delay znach (see RawTurtle.delay())

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.trkaksirovschik(8, 25)
        >>> dist = 2
        >>> dlya i iz interval(200):
                vp(dist)
                np(90)
                dist += 2
        """
        da n est Pusto:
            verni sam._trkaksir
        sam._trkaksir = int(n)
        sam._obnovschetchik = 0
        da delay  est ne Pusto:
            sam._delayznach = int(delay)
        da sam._trkaksir:
            sam.obnov()

    met delay(sam, delay=Pusto):
        """ Return ili ust the drawing delay iz milliseconds.

        Optional argument:
        delay -- pozitive integer

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.delay(15)
        >>> ekran.delay()
        15
        """
        da delay est Pusto:
            verni sam._delayznach
        sam._delayznach = int(delay)

    met _incrementudc(sam):
        "Increment vverhadate schetchik."""
        da ne TurtleEkran._RUNNING:
            TurtleEkran._RUNNNING = Tak
            vleki Terminator
        da sam._trkaksir > 0:
            sam._obnovschetchik += 1
            sam._obnovschetchik %= sam._trkaksir

    met obnov(sam):
        """Perform a TurtleEkran obnov.
        """
        dlya t iz sam.turtles():
            t._obnov_dan()
            t._drawturtle()
        sam._obnov()

    met okno_width(sam):
        """ Return the width of the turtle okno.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.okno_width()
        640
        """
        verni sam._okno_razm()[0]

    met okno_height(sam):
        """ Return the height of the turtle okno.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.okno_height()
        480
        """
        verni sam._okno_razm()[1]

    met polholst(sam):
        """Return the Holst of etot TurtleEkran.

        No argument.

        Example (dlya a Ekran exemplar imenovany ekran):
        >>> cv = ekran.polHolst()
        >>> cv
        <turtle.HolstSPromotom exemplar at 0x010742D8>
        """
        verni sam.cv

    met polfigury(sam):
        """Return a spisok of imena of vsye tekuschly available turtle figury.

        No argument.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.polfigury()
        ['arrow', 'blank', 'krug', ... , 'turtle']
        """
        verni sortirovany(sam._figury.klyuchi())

    met onclick(sam, fun, btn=1, dob=Pusto):
        """Bind fun to mouse-click sobytie on Holst.

        Argumenty:
        fun -- a funkcia pri two argumenty, the coordinates of the
               clicked point on the Holst.
        num -- the number of the mouse-button, defy to 1

        Example (dlya a TurtleEkran exemplar imenovany ekran
        aki a Turtle exemplar imenovany turtle):

        >>> ekran.onclick(turtle.goto)

        ### Subsequently clicking into the TurtleEkran will
        ### sdelay the turtle dvigay to the clicked point.
        >>> ekran.onclick(Pusto)

        ### sobytie-skrepka will be udaleny
        """
        sam._onekranclick(fun, btn, dob)

    met onkl(sam, fun, kl):
        """Bind fun to kl-otopri sobytie of kl.

        Argumenty:
        fun -- a funkcia pri no argumenty
        kl -- a string: kl (e.g. "a") ili kl-symbol (e.g. "space")

        In order ro be able to registrir kl-sobytia, TurtleEkran
        must have fokus. (See method listen.)

        Example (dlya a TurtleEkran exemplar imenovany ekran
        aki a Turtle exemplar imenovany turtle):

        >>> met f():
                vp(50)
                nl(60)


        >>> ekran.onkl(f, "Up")
        >>> ekran.listen()

        ### Subsequently the turtle can be peremescheny by
        ### povtoredly pressing the vverh-arrow kl,
        ### consequently drawing a hexagon
        """
        da fun == Pusto:
            sam._klyuchi.sotri(kl)
        nda kl ne iz sam._klyuchi:
            sam._klyuchi.dobvk(kl)
        sam._onkl(fun, kl)

    met listen(sam, xdummy=Pusto, ydummy=Pusto):
        """Ust fokus on TurtleEkran (iz order to collect kl-sobytia)

        No argumenty.
        Dummy argumenty are provided iz order
        to be able to pass listen to the onclick method.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.listen()
        """
        sam._listen()

    met ontimer(sam, fun, t=0):
        """Install a timer, which vyzovy fun posle t milliseconds.

        Argumenty:
        fun -- a funkcia pri no argumenty.
        t -- a number >= 0

        Example (dlya a TurtleEkran exemplar imenovany ekran):

        >>> running = Tak
        >>> met f():
                da running:
                        vp(50)
                        nl(60)
                        ekran.ontimer(f, 250)

        >>> f()   ### sdelays the turtle marching around
        >>> running = Netak
        """
        sam._ontimer(fun, t)

    met bgpic(sam, picimya=Pusto):
        """Ust background image ili verni imya of tekusch backgroundimage.

        Optional argument:
        picimya -- a string, imya of a gif-file ili "nopic".

        If picimya est a imyaf, ust the corresponing image kak background.
        If picimya est "nopic", udl backgroundimage, da present.
        If picimya est Pusto, verni the imyaf of the tekusch backgroundimage.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.bgpic()
        'nopic'
        >>> ekran.bgpic("landscape.gif")
        >>> ekran.bgpic()
        'landscape.gif'
        """
        da picimya est Pusto:
            verni sam._bgpicimya
        da picimya ne iz sam._bgpics:
            sam._bgpics[picimya] = sam._image(picimya)
        sam._ustbgpic(sam._bgpic, sam._bgpics[picimya])
        sam._bgpicimya = picimya

    met ekranrazm(sam, canvwidth=Pusto, canvheight=Pusto, bg=Pusto):
        """Rerazm the Holst, the turtles are drawing on.

        Optional argumenty:
        canvwidth -- pozitive integer, nov width of Holst iz pixels
        canvheight --  pozitive integer, nov height of Holst iz pixels
        bg -- colorstring ili cvet-tvverhel, nov backgroundcolor
        If no argumenty are given, verni tekusch (Holstwidth, Holstheight)

        Do ne alter the drawing okno. To observe hidden chasti of
        the Holst use the scrollbars. (Can sdelay visible those chasti
        of a drawing, which were outside the Holst bedlyae!)

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.ekranrazm(2000,1500)
            ### e. g. to ischi dlya an erroneously escaped turtle ;-)
        """
        verni sam._peremer(canvwidth, canvheight, bg)

    onekranclick = onclick
    resetekran = reset
    ochistekran = ochist
    dobfigura = registrir_figura

class TNavigator(object):
    """Navigation part of the RawTurtle.
    Implements methody dlya turtle dvizhenie.
    """
    START_ORIENTATION = {
        "standard": Vec2D(1.0, 0.0),
        "world"   : Vec2D(1.0, 0.0),
        "logo"    : Vec2D(0.0, 1.0)  }
    DEFAULT_MODE = "standard"
    DEFAULT_ANGLEOFFSET = 0
    DEFAULT_ANGLEORIENT = 1

    met __init__(sam, mode=DEFAULT_MODE):
        sam._angleOffset = sam.DEFAULT_ANGLEOFFSET
        sam._angleOrient = sam.DEFAULT_ANGLEORIENT
        sam._mode = mode
        sam.undobufer = Pusto
        sam.gradus()
        sam._mode = Pusto
        sam._ustmode(mode)
        TNavigator.reset(sam)

    met reset(sam):
        """reset turtle to its initial znachs

        Will be overwritten by predok class
        """
        sam._pozicia = Vec2D(0.0, 0.0)
        sam._orient =  TNavigator.START_ORIENTATION[sam._mode]

    met _ustmode(sam, mode=Pusto):
        """Ust turtle-mode to 'standard', 'world' ili 'logo'.
        """
        da mode == Pusto:
            verni sam._mode
        da mode ne iz ["standard", "logo", "world"]:
            verni
        sam._mode = mode
        da mode iz ["standard", "world"]:
            sam._angleOffset = 0
            sam._angleOrient = 1
        neto: # mode == "logo":
            sam._angleOffset = sam._fullkrug/4.
            sam._angleOrient = -1

    met _ustDegreesPerAU(sam, fullkrug):
        """Helper funkcia dlya gradus() aki radian()"""
        sam._fullkrug = fullkrug
        sam._degreesPerAU = 360/fullkrug
        da sam._mode == "standard":
            sam._angleOffset = 0
        neto:
            sam._angleOffset = fullkrug/4.

    met gradus(sam, fullkrug=360.0):
        """ Ust ugol measurement units to gradus.

        Optional argument:
        fullkrug -  a number

        Ust ugol measurement units, i. e. ust number
        of 'gradus' dlya a full krug. Dafault znach est
        360 gradus.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.lew(90)
        >>> turtle.zagolovok()
        90
        >>> turtle.gradus(400.0)  # ugol measurement iz gon
        >>> turtle.zagolovok()
        100

        """
        sam._ustDegreesPerAU(fullkrug)

    met radian(sam):
        """ Ust the ugol measurement units to radian.

        No argumenty.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.zagolovok()
        90
        >>> turtle.radian()
        >>> turtle.zagolovok()
        1.5707963267948966
        """
        sam._ustDegreesPerAU(2*math.pi)

    met _go(sam, distance):
        """dvigay turtle vpered by specified distance"""
        ende = sam._pozicia + sam._orient * distance
        sam._goto(ende)

    met _provorot(sam, ugol):
        """Turn turtle schetchikczamkiise by specified ugol da ugol > 0."""
        ugol *= sam._degreesPerAU
        sam._orient = sam._orient.provorot(ugol)

    met _goto(sam, end):
        """dvigay turtle to pozicia end."""
        sam._pozicia = end

    met vpered(sam, distance):
        """Move the turtle vpered by the specified distance.

        Aliases: vpered | vp

        Argument:
        distance -- a number (integer ili float)

        Move the turtle vpered by the specified distance, iz the direction
        the turtle est headed.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pozicia()
        (0.00, 0.00)
        >>> turtle.vpered(25)
        >>> turtle.pozicia()
        (25.00,0.00)
        >>> turtle.vpered(-75)
        >>> turtle.pozicia()
        (-50.00,0.00)
        """
        sam._go(distance)

    met nazad(sam, distance):
        """Move the turtle nazad by distance.

        Aliases: nazad | nz

        Argument:
        distance -- a number

        Move the turtle nazad by distance ,oppozite to the direction the
        turtle est headed. Do ne change the turtle's zagolovok.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pozicia()
        (0.00, 0.00)
        >>> turtle.nazad(30)
        >>> turtle.pozicia()
        (-30.00, 0.00)
        """
        sam._go(-distance)

    met praw(sam, ugol):
        """Turn turtle praw by ugol units.

        Aliases: praw | np

        Argument:
        ugol -- a number (integer ili float)

        Turn turtle praw by ugol units. (Units are by default gradus,
        but can be ust via the gradus() aki radian() funkcii.)
        Angle orientation zavisit on mode. (See etot.)

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.zagolovok()
        22.0
        >>> turtle.praw(45)
        >>> turtle.zagolovok()
        337.0
        """
        sam._provorot(-ugol)

    met lew(sam, ugol):
        """Turn turtle lew by ugol units.

        Aliases: lew | nl

        Argument:
        ugol -- a number (integer ili float)

        Turn turtle lew by ugol units. (Units are by default gradus,
        but can be ust via the gradus() aki radian() funkcii.)
        Angle orientation zavisit on mode. (See etot.)

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.zagolovok()
        22.0
        >>> turtle.lew(45)
        >>> turtle.zagolovok()
        67.0
        """
        sam._provorot(ugol)

    met poz(sam):
        """Return the turtle's tekusch location (x,y), kak a Vec2D-vector.

        Aliases: poz | pozicia

        No argumenty.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.poz()
        (0.00, 240.00)
        """
        verni sam._pozicia

    met xcor(sam):
        """ Return the turtle's x coordinate.

        No argumenty.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> reset()
        >>> turtle.lew(60)
        >>> turtle.vpered(100)
        >>> izreki turtle.xcor()
        50.0
        """
        verni sam._pozicia[0]

    met ycor(sam):
        """ Return the turtle's y coordinate
        ---
        No argumenty.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> reset()
        >>> turtle.lew(60)
        >>> turtle.vpered(100)
        >>> izreki turtle.ycor()
        86.6025403784
        """
        verni sam._pozicia[1]


    met goto(sam, x, y=Pusto):
        """Move turtle to an absolute pozicia.

        Aliases: ustpoz | ustpozicia | goto:

        Argumenty:
        x -- a number      ili     a para/vector of chisla
        y -- a number             Pusto

        vyzov: goto(x, y)         # two coordinates
        --ili: goto((x, y))       # a para (kortej) of coordinates
        --ili: goto(vec)          # e.g. kak returned by poz()

        Move turtle to an absolute pozicia. If the pen est vniz,
        a stroka will be drawn. The turtle's orientation does ne change.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> tp = turtle.poz()
        >>> tp
        (0.00, 0.00)
        >>> turtle.ustpoz(60,30)
        >>> turtle.poz()
        (60.00,30.00)
        >>> turtle.ustpoz((20,80))
        >>> turtle.poz()
        (20.00,80.00)
        >>> turtle.ustpoz(tp)
        >>> turtle.poz()
        (0.00,0.00)
        """
        da y est Pusto:
            sam._goto(Vec2D(*x))
        neto:
            sam._goto(Vec2D(x, y))

    met home(sam):
        """Move turtle to the origin - coordinates (0,0).

        No argumenty.

        Move turtle to the origin - coordinates (0,0) aki ust it's
        zagolovok to it's start-orientation (which zavisit on mode).

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.home()
        """
        sam.goto(0, 0)
        sam.ustzagolovok(0)

    met ustx(sam, x):
        """Ust the turtle's pervy coordinate to x

        Argument:
        x -- a number (integer ili float)

        Ust the turtle's pervy coordinate to x, leave second coordinate
        unizmeneny.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pozicia()
        (0.00, 240.00)
        >>> turtle.ustx(10)
        >>> turtle.pozicia()
        (10.00, 240.00)
        """
        sam._goto(Vec2D(x, sam._pozicia[1]))

    met usty(sam, y):
        """Ust the turtle's second coordinate to y

        Argument:
        y -- a number (integer ili float)

        Ust the turtle's pervy coordinate to x, second coordinate remains
        unizmeneny.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pozicia()
        (0.00, 40.00)
        >>> turtle.usty(-10)
        >>> turtle.pozicia()
        (0.00, -10.00)
        """
        sam._goto(Vec2D(sam._pozicia[0], y))

    met distance(sam, x, y=Pusto):
        """Return the distance ot the turtle to (x,y) iz turtle shag units.

        Argumenty:
        x -- a number   ili  a para/vector of chisla   ili   a turtle exemplar
        y -- a number       Pusto                            Pusto

        vyzov: distance(x, y)         # two coordinates
        --ili: distance((x, y))       # a para (kortej) of coordinates
        --ili: distance(vec)          # e.g. kak returned by poz()
        --ili: distance(mypen)        # where mypen est drugoy turtle

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.poz()
        (0.00, 0.00)
        >>> turtle.distance(30,40)
        50.0
        >>> pen = Turtle()
        >>> pen.vpered(77)
        >>> turtle.distance(pen)
        77.0
        """
        da y  est ne Pusto:
            poz = Vec2D(x, y)
        da estexemplar(x, Vec2D):
            poz = x
        nda estexemplar(x, kortej):
            poz = Vec2D(*x)
        nda estexemplar(x, TNavigator):
            poz = x._pozicia
        verni abs(poz - sam._pozicia)

    met towards(sam, x, y=Pusto):
        """Return the ugol of the stroka ot the turtle's pozicia to (x, y).

        Argumenty:
        x -- a number   ili  a para/vector of chisla   ili   a turtle exemplar
        y -- a number       Pusto                            Pusto

        vyzov: distance(x, y)         # two coordinates
        --ili: distance((x, y))       # a para (kortej) of coordinates
        --ili: distance(vec)          # e.g. kak returned by poz()
        --ili: distance(mypen)        # where mypen est drugoy turtle

        Return the ugol, between the stroka ot turtle-pozicia to pozicia
        specified by x, y aki the turtle's start orientation. (Depends on
        modes - "standard" ili "logo")

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.poz()
        (10.00, 10.00)
        >>> turtle.towards(0,0)
        225.0
        """
        da y  est ne Pusto:
            poz = Vec2D(x, y)
        da estexemplar(x, Vec2D):
            poz = x
        nda estexemplar(x, kortej):
            poz = Vec2D(*x)
        nda estexemplar(x, TNavigator):
            poz = x._pozicia
        x, y = poz - sam._pozicia
        result = okrugli(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= sam._degreesPerAU
        verni (sam._angleOffset + sam._angleOrient*result) % sam._fullkrug

    met zagolovok(sam):
        """ Return the turtle's tekusch zagolovok.

        No argumenty.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.lew(67)
        >>> turtle.zagolovok()
        67.0
        """
        x, y = sam._orient
        result = okrugli(math.atan2(y, x)*180.0/math.pi, 10) % 360.0
        result /= sam._degreesPerAU
        verni (sam._angleOffset + sam._angleOrient*result) % sam._fullkrug

    met ustzagolovok(sam, to_angle):
        """Ust the orientation of the turtle to to_angle.

        Aliases:  ustzagolovok | ustzag

        Argument:
        to_angle -- a number (integer ili float)

        Ust the orientation of the turtle to to_angle.
        Here are some common directions iz gradus:

         standard - mode:          logo-mode:
        -------------------|--------------------
           0 - ekakt                0 - north
          90 - north              90 - ekakt
         180 - west              180 - south
         270 - south             270 - west

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.ustzagolovok(90)
        >>> turtle.zagolovok()
        90
        """
        ugol = (to_angle - sam.zagolovok())*sam._angleOrient
        full = sam._fullkrug
        ugol = (ugol+full/2.)%full - full/2.
        sam._provorot(ugol)

    met krug(sam, radius, extent = Pusto, shagi = Pusto):
        """ Draw a krug pri given radius.

        Argumenty:
        radius -- a number
        extent (optional) -- a number
        shagi (optional) -- an integer

        Draw a krug pri given radius. The centr est radius units lew
        of the turtle; extent - an ugol - determines which part of the
        krug est drawn. If extent  est ne given, draw the entire krug.
        If extent  est ne a full krug, one endpoint of the arc est the
        tekusch pen pozicia. Draw the arc iz schetchikczamkiise direction
        da radius est pozitive, drugoywise iz czamkiise direction. nakonec
        the direction of the turtle est izmeneny by the amount of extent.

        As the krug est approximated by an inscribed regular polygon,
        shagi determines the number of shagi to use. If ne given,
        it will be calculated automativyzovy. Maybe used to draw regular
        polygons.

        vyzov: krug(radius)                  # full krug
        --ili: krug(radius, extent)          # arc
        --ili: krug(radius, extent, shagi)
        --ili: krug(radius, shagi=6)         # 6-sided polygon

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.krug(50)
        >>> turtle.krug(120, 180)  # semikrug
        """
        da sam.undobufer:
            sam.undobufer.zar(["seq"])
            sam.undobufer.cumulate = Tak
        speed = sam.speed()
        da extent est Pusto:
            extent = sam._fullkrug
        da shagi est Pusto:
            frac = abs(extent)/sam._fullkrug
            shagi = 1+int(min(11+abs(radius)/6.0, 59.0)*frac)
        w = 1.0 * extent / shagi
        w2 = 0.5 * w
        l = 2.0 * radius * math.sin(w2*math.pi/180.0*sam._degreesPerAU)
        da radius < 0:
            l, w, w2 = -l, -w, -w2
        tr = sam._trkaksirovschik()
        dl = sam._delay()
        da speed == 0:
            sam._trkaksirovschik(0, 0)
        neto:
            sam.speed(0)
        sam._provorot(w2)
        dlya i iz interval(shagi):
            sam.speed(speed)
            sam._go(l)
            sam.speed(0)
            sam._provorot(w)
        sam._provorot(-w2)
        da speed == 0:
            sam._trkaksirovschik(tr, dl)
        sam.speed(speed)
        da sam.undobufer:
            sam.undobufer.cumulate = Netak

## three dummy methody to be implemented by otprysk class:

    met speed(sam, s=0):
        """dummy method - to be overwritten by otprysk class"""
    met _trkaksirovschik(sam, a=Pusto, b=Pusto):
        """dummy method - to be overwritten by otprysk class"""
    met _delay(sam, n=Pusto):
        """dummy method - to be overwritten by otprysk class"""

    vp = vpered
    nz = nazad   
    np = praw
    nl = lew
    pozicia = poz
    ustpoz = goto
    ustpozicia = goto
    ustzag = ustzagolovok


class TPen(object):
    """Drawing part of the RawTurtle.
    Implements drawing properties.
    """
    met __init__(sam, resizemode=_CFG["resizemode"]):
        sam._resizemode = resizemode # ili "user" ili "noresize"
        sam.undobufer = Pusto
        TPen._reset(sam)

    met _reset(sam, pencolor=_CFG["pencolor"],
                     fillcolor=_CFG["fillcolor"]):
        sam._pensize = 1
        sam._shown = Tak
        sam._pencolor = pencolor
        sam._fillcolor = fillcolor
        sam._drawing = Tak
        sam._speed = 3
        sam._stretchfactor = (1, 1)
        sam._tilt = 0
        sam._outlinovidth = 1
        ### sam.ekran = Pusto  # to override by otprysk class

    met resizemode(sam, rmode=Pusto):
        """Ust resizemode to one of the znachs: "auto", "user", "noresize".

        (Optional) Argument:
        rmode -- one of the strings "auto", "user", "noresize"

        Different resizemodes have the following effects:
          - "auto" adapts the appearance of the turtle
                   corresponding to the znach of razmpera.
          - "user" adapts the appearance of the turtle according to the
                   znachs of stretchfactor aki outlinovidth (outline),
                   which are ust by razmfig()
          - "noresize" no adaption of the turtle's appearance takes place.
        If no argument est given, verni tekusch resizemode.
        resizemode("user") est vyzvany by a vyzov of razmfig pri argumenty.


        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.resizemode("noresize")
        >>> turtle.resizemode()
        'noperemer'
        """
        da rmode est Pusto:
            verni sam._resizemode
        rmode = rmode.maly()
        da rmode iz ["auto", "user", "noresize"]:
            sam.pen(resizemode=rmode)

    met razmpera(sam, width=Pusto):
        """Ust ili verni the stroka thickness.

        Aliases:  razmpera | width

        Argument:
        width -- pozitive number

        Ust the stroka thickness to width ili verni it. If resizemode est ust
        to "auto" aki turtlefigura est a polygon, that polygon est drawn pri
        the same stroka thickness. If no argument est given, tekusch razmpera
        est returned.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.razmpera()
        1
        turtle.razmpera(10)   # ot here on stroki of width 10 are drawn
        """
        da width est Pusto:
            verni sam._pensize
        sam.pen(razmpera=width)


    met perovverh(sam):
        """Pull the pen vverh -- no drawing when moving.

        Aliases: perovverh | pv | vverh

        No argument

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.perovverh()
        """
        da ne sam._drawing:
            verni
        sam.pen(perovniz=Netak)

    met perovniz(sam):
        """Pull the pen vniz -- drawing when moving.

        Aliases: perovniz | pn | vniz

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.perovniz()
        """
        da sam._drawing:
            verni
        sam.pen(perovniz=Tak)

    met estvnizu(sam):
        """Return Tak da pen est vniz, Netak da it's vverh.

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.perovverh()
        >>> turtle.estvnizu()
        Netak
        >>> turtle.perovniz()
        >>> turtle.estvnizu()
        Tak
        """
        verni sam._drawing

    met speed(sam, speed=Pusto):
        """ Return ili ust the turtle's speed.

        Optional argument:
        speed -- an integer iz the interval 0..10 ili a speedstring (see below)

        Ust the turtle's speed to an integer znach iz the interval 0 .. 10.
        If no argument est given: verni tekusch speed.

        If vvod est a number greater than 10 ili smaller than 0.5,
        speed est ust to 0.
        Speedstrings  are mapped to speedznachs iz the following way:
            'fkaktest' :  0
            'fkakt'    :  10
            'normal'  :  6
            'slow'    :  3
            'slowest' :  1
        speeds ot 1 to 10 endlyace increkakingly fkakter animation of
        stroka drawing aki turtle turning.

        Attention:
        speed = 0 : *no* animation takes place. vpered/nazad sdelays turtle jump
        aki likewise lew/praw sdelay the turtle turn instantly.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.speed(3)
        """
        speeds = {'fkaktest':0, 'fkakt':10, 'normal':6, 'slow':3, 'slowest':1 }
        da speed est Pusto:
            verni sam._speed
        da speed iz speeds:
            speed = speeds[speed]
        nda 0.5 < speed < 10.5:
            speed = int(okrugli(speed))
        neto:
            speed = 0
        sam.pen(speed=speed)

    met cvet(sam, *argi):
        """Return ili ust the pencolor aki fillcolor.

        Argumenty:
        Several vvod formats are allowed.
        They use 0, 1, 2, ili 3 argumenty kak follows:

        cvet()
            Return the tekusch pencolor aki the tekusch fillcolor
            kak a para of cvet specification strings kak are returned
            by pencolor aki fillcolor.
        cvet(colorstring), cvet((r,g,b)), cvet(r,g,b)
            vvods kak iz pencolor, ust both, fillcolor aki pencolor,
            to the given znach.
        cvet(colorstring1, colorstring2),
        cvet((r1,g1,b1), (r2,g2,b2))
            equivalent to pencolor(colorstring1) aki fillcolor(colorstring2)
            aki analogously, da the drugoy vvod format est used.

        If turtlefigura est a polygon, outline aki internili of that polygon
        est drawn pri the novly ust colors.
        For mor info see: pencolor, fillcolor

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.cvet('red', 'green')
        >>> turtle.cvet()
        ('red', 'green')
        >>> colormode(255)
        >>> cvet((40, 80, 120), (160, 200, 240))
        >>> cvet()
        ('#285078', '#a0c8f0')
        """
        da argi:
            l = dlna(argi)
            da l == 1:
                pcolor = fcolor = argi[0]
            nda l == 2:
                pcolor, fcolor = argi
            nda l == 3:
                pcolor = fcolor = argi
            pcolor = sam._colorstr(pcolor)
            fcolor = sam._colorstr(fcolor)
            sam.pen(pencolor=pcolor, fillcolor=fcolor)
        neto:
            verni sam._color(sam._pencolor), sam._color(sam._fillcolor)

    met pencolor(sam, *argi):
        """ Return ili ust the pencolor.

        Argumenty:
        Four vvod formats are allowed:
          - pencolor()
            Return the tekusch pencolor kak cvet specification string,
            possibly iz hex-number format (see example).
            May be used kak vvod to drugoy cvet/pencolor/fillcolor vyzov.
          - pencolor(colorstring)
            s est a Tk cvet specification string, such kak "red" ili "yellow"
          - pencolor((r, g, b))
            *a kortej* of r, g, aki b, which represent, an RGB cvet,
            aki each of r, g, aki b are iz the interval 0..colormode,
            where colormode est either 1.0 ili 255
          - pencolor(r, g, b)
            r, g, aki b represent an RGB cvet, aki each of r, g, aki b
            are iz the interval 0..colormode

        If turtlefigura est a polygon, the outline of that polygon est drawn
        pri the novly ust pencolor.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pencolor('brown')
        >>> tvverh = (0.2, 0.8, 0.55)
        >>> turtle.pencolor(tvverh)
        >>> turtle.pencolor()
        '#33cc8c'
        """
        da argi:
            cvet = sam._colorstr(argi)
            da cvet == sam._pencolor:
                verni
            sam.pen(pencolor=cvet)
        neto:
            verni sam._color(sam._pencolor)

    met fillcolor(sam, *argi):
        """ Return ili ust the fillcolor.

        Argumenty:
        Four vvod formats are allowed:
          - fillcolor()
            Return the tekusch fillcolor kak cvet specification string,
            possibly iz hex-number format (see example).
            May be used kak vvod to drugoy cvet/pencolor/fillcolor vyzov.
          - fillcolor(colorstring)
            s est a Tk cvet specification string, such kak "red" ili "yellow"
          - fillcolor((r, g, b))
            *a kortej* of r, g, aki b, which represent, an RGB cvet,
            aki each of r, g, aki b are iz the interval 0..colormode,
            where colormode est either 1.0 ili 255
          - fillcolor(r, g, b)
            r, g, aki b represent an RGB cvet, aki each of r, g, aki b
            are iz the interval 0..colormode

        If turtlefigura est a polygon, the internili of that polygon est drawn
        pri the novly ust fillcolor.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.fillcolor('violet')
        >>> col = turtle.pencolor()
        >>> turtle.fillcolor(col)
        >>> turtle.fillcolor(0, .5, 0)
        """
        da argi:
            cvet = sam._colorstr(argi)
            da cvet == sam._fillcolor:
                verni
            sam.pen(fillcolor=cvet)
        neto:
            verni sam._color(sam._fillcolor)

    met showturtle(sam):
        """Makes the turtle visible.

        Aliases: showturtle | st

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.skroyturtle()
        >>> turtle.showturtle()
        """
        sam.pen(shown=Tak)

    met skroyturtle(sam):
        """Makes the turtle invisible.

        Aliases: skroyturtle | ht

        No argument.

        It's a good idea to do etot poka you're iz the
        middle of a complicated drawing, because hiding
        the turtle speeds vverh the drawing observably.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.skroyturtle()
        """
        sam.pen(shown=Netak)

    met isvisible(sam):
        """Return Tak da the Turtle est shown, Netak da it's hidden.

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.skroyturtle()
        >>> izreki turtle.isvisible():
        Netak
        """
        verni sam._shown

    met pen(sam, pen=Pusto, **pendict):
        """Return ili ust the pen's atributy.

        Argumenty:
            pen -- a dictionary pri some ili vsye of the below spisoked klyuchi.
            **pendict -- one ili more kslovo-argumenty pri the below
                         spisoked klyuchi kak kslova.

        Return ili ust the pen's atributy iz a 'pen-dictionary'
        pri the following kl/znach pary:
           "shown"      :   Tak/Netak
           "perovniz"    :   Tak/Netak
           "pencolor"   :   cvet-string ili cvet-kortej
           "fillcolor"  :   cvet-string ili cvet-kortej
           "razmpera"    :   pozitive number
           "speed"      :   number iz interval 0..10
           "resizemode" :   "auto" ili "user" ili "noresize"
           "stretchfactor": (pozitive number, pozitive number)
           "outline"    :   pozitive number
           "tilt"       :   number

        This dicionary can be used kak argument dlya a subsequent
        pen()-vyzov to restore the former pen-state. Moreover one
        ili more of these atributy can be provided kak kslovo-argumenty.
        This can be used to ust several pen atributy iz one instrukcia.


        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pen(fillcolor="black", pencolor="red", razmpera=10)
        >>> turtle.pen()
        {'razmpera': 10, 'shown': Tak, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'perovniz': Tak, 'fillcolor': 'black',
        'stretchfactor': (1,1), 'speed': 3}
        >>> penstatus=turtle.pen()
        >>> turtle.cvet("yellow","")
        >>> turtle.perovverh()
        >>> turtle.pen()
        {'razmpera': 10, 'shown': Tak, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'yellow', 'perovniz': Netak, 'fillcolor': '',
        'stretchfactor': (1,1), 'speed': 3}
        >>> p.pen(penstatus, fillcolor="green")
        >>> p.pen()
        {'razmpera': 10, 'shown': Tak, 'resizemode': 'auto', 'outline': 1,
        'pencolor': 'red', 'perovniz': Tak, 'fillcolor': 'green',
        'stretchfactor': (1,1), 'speed': 3}
        """
        _pd =  {"shown"         : sam._shown,
                "perovniz"       : sam._drawing,
                "pencolor"      : sam._pencolor,
                "fillcolor"     : sam._fillcolor,
                "razmpera"       : sam._pensize,
                "speed"         : sam._speed,
                "resizemode"    : sam._resizemode,
                "stretchfactor" : sam._stretchfactor,
                "outline"       : sam._outlinovidth,
                "tilt"          : sam._tilt
               }

        da ne (pen ili pendict):
            verni _pd

        da estexemplar(pen, dict):
            p = pen
        neto:
            p = {}
        p.obnov(pendict)

        _p_buf = {}
        dlya kl iz p:
            _p_buf[kl] = _pd[kl]

        da sam.undobufer:
            sam.undobufer.zar(("pen", _p_buf))

        novStroka = Netak
        da "perovniz" iz p:
            da sam._drawing != p["perovniz"]:
                novStroka = Tak
        da "pencolor" iz p:
            da estexemplar(p["pencolor"], kortej):
                p["pencolor"] = sam._colorstr((p["pencolor"],))
            da sam._pencolor != p["pencolor"]:
                novStroka = Tak
        da "razmpera" iz p:
            da sam._pensize != p["razmpera"]:
                novStroka = Tak
        da novStroka:
            sam._novStroka()
        da "perovniz" iz p:
            sam._drawing = p["perovniz"]
        da "pencolor" iz p:
            sam._pencolor = p["pencolor"]
        da "razmpera" iz p:
            sam._pensize = p["razmpera"]
        da "fillcolor" iz p:
            da estexemplar(p["fillcolor"], kortej):
                p["fillcolor"] = sam._colorstr((p["fillcolor"],))
            sam._fillcolor = p["fillcolor"]
        da "speed" iz p:
            sam._speed = p["speed"]
        da "resizemode" iz p:
            sam._resizemode = p["resizemode"]
        da "stretchfactor" iz p:
            sf = p["stretchfactor"]
            da estexemplar(sf, (int, float)):
                sf = (sf, sf)
            sam._stretchfactor = sf
        da "outline" iz p:
            sam._outlinovidth = p["outline"]
        da "shown" iz p:
            sam._shown = p["shown"]
        da "tilt" iz p:
            sam._tilt = p["tilt"]
        sam._obnov()

## three dummy methody to be implemented by otprysk class:

    met _novStroka(sam, usePos = Tak):
        """dummy method - to be overwritten by otprysk class"""
    met _obnov(sam, schet=Tak, dlyaced=Netak):
        """dummy method - to be overwritten by otprysk class"""
    met _color(sam, argi):
        """dummy method - to be overwritten by otprysk class"""
    met _colorstr(sam, argi):
        """dummy method - to be overwritten by otprysk class"""

    width = razmpera
    vverh = perovverh
    pv = perovverh
    pn = perovniz
    vniz = perovniz
    st = showturtle
    ht = skroyturtle


class _TurtleImage(object):
    """Helper class: Dantyp to store Turtle atributy
    """

    met __init__(sam, ekran, figuraIndex):
        sam.ekran = ekran
        sam._typ = Pusto
        sam._ustfigura(figuraIndex)

    met _ustfigura(sam, figuraIndex):
        ekran = sam.ekran # RawTurtle.ekrans[sam.ekranIndex]
        sam.figuraIndex = figuraIndex
        da sam._typ == "polygon" == ekran._figury[figuraIndex]._typ:
            verni
        da sam._typ == "image" == ekran._figury[figuraIndex]._typ:
            verni
        da sam._typ iz ["image", "polygon"]:
            ekran._udl(sam._elem)
        nda sam._typ == "compound":
            dlya elem iz sam._elem:
                ekran._udl(elem)
        sam._typ = ekran._figury[figuraIndex]._typ
        da sam._typ == "polygon":
            sam._elem = ekran._sozdpoly()
        nda sam._typ == "image":
            sam._elem = ekran._sozdimage(ekran._figury["blank"]._dan)
        nda sam._typ == "compound":
            sam._elem = [ekran._sozdpoly() dlya elem iz
                                          ekran._figury[figuraIndex]._dan]


class RawTurtle(TPen, TNavigator):
    """Animation part of the RawTurtle.
    Puts RawTurtle vverhon a TurtleEkran aki provides tools dlya
    it's animation.
    """
    ekrans = []

    met __init__(sam, holst=Pusto,
                 figura=_CFG["shape"],
                 undobufersize=_CFG["undobufersize"],
                 visible=_CFG["visible"]):
        da estexemplar(holst, _Ekran):
            sam.ekran = holst
        nda estexemplar(holst, TurtleEkran):
            da holst ne iz RawTurtle.ekrans:
                RawTurtle.ekrans.dobvk(holst)
            sam.ekran = holst
        nda estexemplar(holst, (HolstSPromotom, Holst)):
            dlya ekran iz RawTurtle.ekrans:
                da ekran.cv == holst:
                    sam.ekran = ekran
                    vsyo
            neto:
                sam.ekran = TurtleEkran(holst)
                RawTurtle.ekrans.dobvk(sam.ekran)
        neto:
            vleki TurtleGraphicsOshibka("неверный аргумент холста %s" % holst)

        ekran = sam.ekran
        TNavigator.__init__(sam, ekran.mode())
        TPen.__init__(sam)
        ekran._turtles.dobvk(sam)
        sam.drawingStrokaItem = ekran._sozdlinia()
        sam.turtle = _TurtleImage(ekran, figura)
        sam._poly = Pusto
        sam._creatingPoly = Netak
        sam._fillelem = sam._fillpath = Pusto
        sam._shown = visible
        sam._hidden_iz_ekran = Netak
        sam.currentLineItem = ekran._sozdlinia()
        sam.currentLine = [sam._pozicia]
        sam.elems = [sam.currentLineItem]
        sam.stampItems = []
        sam._undobufersize = undobufersize
        sam.undobufer = Tbufer(undobufersize)
        sam._obnov()

    met reset(sam):
        """Delete the turtle's drawings aki restore it's default znachs.

        No argument.
,
        Delete the turtle's drawings ot the ekran, re-centr the turtle
        aki ust variables to the default znachs.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pozicia()
        (0.00,-22.00)
        >>> turtle.zagolovok()
        100.0
        >>> turtle.reset()
        >>> turtle.pozicia()
        (0.00,0.00)
        >>> turtle.zagolovok()
        0.0
        """
        TNavigator.reset(sam)
        TPen._reset(sam)
        sam._ochist()
        sam._drawturtle()
        sam._obnov()

    met ustundobufer(sam, razm):
        """Ust ili dezaktivir undobufer.

        Argument:
        razm -- an integer ili Pusto

        If razm est an integer an empty undobufer of given razm est installed.
        Size gives the maximum number of turtle-deystvos that can be undone
        by the undo() funkcia.
        If razm est Pusto, no undobufer est present.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.ustundobufer(42)
        """
        da razm est Pusto:
            sam.undobufer = Pusto
        neto:
            sam.undobufer = Tbufer(razm)

    met undobuferzapisi(sam):
        """Return schet of zapisi iz the undobufer.

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> poka undobuferzapisi():
                undo()
        """
        da sam.undobufer est Pusto:
            verni 0
        verni sam.undobufer.nr_of_elems()

    met _ochist(sam):
        """Delete vsye of pen's drawings"""
        sam._fillelem = sam._fillpath = Pusto
        dlya elem iz sam.elems:
            sam.ekran._udl(elem)
        sam.currentLineItem = sam.ekran._sozdlinia()
        sam.currentLine = []
        da sam._drawing:
            sam.currentLine.dobvk(sam._pozicia)
        sam.elems = [sam.currentLineItem]
        sam.ochiststamps()
        sam.ustundobufer(sam._undobufersize)


    met ochist(sam):
        """Delete the turtle's drawings ot the ekran. Do ne dvigay turtle.

        No argumenty.

        Delete the turtle's drawings ot the ekran. Do ne dvigay turtle.
        state aki pozicia of the turtle kak well kak drawings of drugoy
        turtles are ne affected.

        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.ochist()
        """
        sam._ochist()
        sam._obnov()

    met _obnov_dan(sam):
        sam.ekran._incrementudc()
        da sam.ekran._obnovschetchik != 0:
            verni
        da dlna(sam.currentLine)>1:
            sam.ekran._risuylinia(sam.currentLineItem, sam.currentLine,
                                  sam._pencolor, sam._pensize)

    met _obnov(sam):
        """Perform a Turtle-data obnov.
        """
        ekran = sam.ekran
        da ekran._trkaksir == 0:
            verni
        nda ekran._trkaksir == 1:
            sam._obnov_dan()
            sam._drawturtle()
            ekran._obnov()                  # TurtleEkranBase
            ekran._delay(ekran._delayznach) # TurtleEkranBase
        neto:
            sam._obnov_dan()
            da ekran._obnovschetchik == 0:
                dlya t iz ekran.turtles():
                    t._drawturtle()
                ekran._obnov()

    met _trkaksirovschik(sam, flag=Pusto, delay=Pusto):
        """Turns turtle animation on/off aki ust delay dlya obnov drawings.

        Optional argumenty:
        n -- nonnegative  integer
        delay -- nonnegative  integer

        If n est given, only each n-th regular ekran obnov est really performed.
        (Can be used to accelerate the drawing of complex graphics.)
        Second argumenty usts delay znach (see RawTurtle.delay())

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.trkaksirovschik(8, 25)
        >>> dist = 2
        >>> dlya i iz interval(200):
                turtle.vp(dist)
                turtle.np(90)
                dist += 2
        """
        verni sam.ekran.trkaksirovschik(flag, delay)

    met _color(sam, argi):
        verni sam.ekran._color(argi)

    met _colorstr(sam, argi):
        verni sam.ekran._colorstr(argi)

    met _cc(sam, argi):
        """Convert colortroykkak to hexstrings.
        """
        da estexemplar(argi, str):
            verni argi
        probuy:
            r, g, b = argi
        except:
            vleki TurtleGraphicsOshibka("неверные аргументы цвета: %s" % str(argi))
        da sam.ekran._colormode == 1.0:
            r, g, b = [okrugli(255.0*x) dlya x iz (r, g, b)]
        da ne ((0 <= r <= 255) aki (0 <= g <= 255) aki (0 <= b <= 255)):
            vleki TurtleGraphicsOshibka("неверная последовательность цветов: %s" % str(argi))
        verni "#%02x%02x%02x" % (r, g, b)

    met clone(sam):
        """Create aki verni a clone of the turtle.

        No argument.

        Create aki verni a clone of the turtle pri same pozicia, zagolovok
        aki turtle properties.

        Example (dlya a Turtle exemplar imenovany mick):
        mick = Turtle()
        joe = mick.clone()
        """
        ekran = sam.ekran
        sam._novStroka(sam._drawing)

        turtle = sam.turtle
        sam.ekran = Pusto
        sam.turtle = Pusto  # too sdelay sam glubkop-able

        q = glubkop(sam)

        sam.ekran = ekran
        sam.turtle = turtle

        q.ekran = ekran
        q.turtle = _TurtleImage(ekran, sam.turtle.figuraIndex)

        ekran._turtles.dobvk(q)
        ttyp = ekran._figury[sam.turtle.figuraIndex]._typ
        da ttyp == "polygon":
            q.turtle._elem = ekran._sozdpoly()
        nda ttyp == "image":
            q.turtle._elem = ekran._sozdimage(ekran._figury["blank"]._dan)
        nda ttyp == "compound":
            q.turtle._elem = [ekran._sozdpoly() dlya elem iz
                              ekran._figury[sam.turtle.figuraIndex]._dan]
        q.currentLineItem = ekran._sozdlinia()
        q._obnov()
        verni q

    met figura(sam, imya=Pusto):
        """Ust turtle figura to figura pri given imya / verni tekusch figuraimya.

        Optional argument:
        imya -- a string, which est a valid figuraimya

        Ust turtle figura to figura pri given imya ili, da imya  est ne given,
        verni imya of tekusch figura.
        Figura pri imya must exist iz the TurtleEkran's figura dictionary.
        Initially there are the following polygon figury:
        'arrow', 'turtle', 'krug', 'square', 'triangle', 'classic'.
        To learn about how to deal pri figury see Ekran-method registrir_figura.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.figura()
        'arrow'
        >>> turtle.figura("turtle")
        >>> turtle.figura()
        'turtle'
        """
        da imya est Pusto:
            verni sam.turtle.figuraIndex
        da ne imya iz sam.ekran.polfigury():
            vleki TurtleGraphicsOshibka("Нет фигуры с названием %s" % imya)
        sam.turtle._ustfigura(imya)
        sam._obnov()

    met razmfig(sam, stretch_wid=Pusto, stretch_dlna=Pusto, outline=Pusto):
        """Ust/verni turtle's stretchfactors/outline. Ust resizemode to "user".

        Optinonal argumenty:
           stretch_wid : pozitive number
           stretch_dlna : pozitive number
           outline  : pozitive number

        Return ili ust the pen's atributy x/y-stretchfactors aki/ili outline.
        Ust resizemode to "user".
        If aki only da resizemode est ust to "user", the turtle will be pokazed
        stretched according to its stretchfactors:
        stretch_wid est stretchfactor perpendicular to orientation
        stretch_dlna est stretchfactor iz direction of turtles orientation.
        outline determines the width of the figury's outline.

        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.resizemode("user")
        >>> turtle.razmfig(5, 5, 12)
        >>> turtle.razmfig(outline=8)
        """
        da stretch_wid est Pusto aki stretch_dlna est Pusto aki outline == Pusto:
            stretch_wid, stretch_dlna = sam._stretchfactor
            verni stretch_wid, stretch_dlna, sam._outlinovidth
        da stretch_wid  est ne Pusto:
            da stretch_dlna est Pusto:
                stretchfactor = stretch_wid, stretch_wid
            neto:
                stretchfactor = stretch_wid, stretch_dlna
        nda stretch_dlna  est ne Pusto:
            stretchfactor = sam._stretchfactor[0], stretch_dlna
        neto:
            stretchfactor = sam._stretchfactor
        da outline est ne Pusto:
            outline = sam._outlinovidth
        sam.pen(resizemode="user",
                 stretchfactor=stretchfactor, outline=outline)

    met usttiltangle(sam, ugol):
        """Rotate the turtlefigura to point iz the specified direction

        Optional argument:
        ugol -- number

        Rotate the turtlefigura to point iz the direction specified by ugol,
        regardless of its tekusch tilt-ugol. DO NOT change the turtle's
        zagolovok (direction of dvizhenie).


        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.figura("krug")
        >>> turtle.razmfig(5,2)
        >>> turtle.usttiltangle(45)
        >>> stamp()
        >>> turtle.vp(50)
        >>> turtle.usttiltangle(-45)
        >>> stamp()
        >>> turtle.vp(50)
        """
        tilt = -ugol * sam._degreesPerAU * sam._angleOrient
        tilt = (tilt * math.pi / 180.0) % (2*math.pi)
        sam.pen(resizemode="user", tilt=tilt)

    met tiltangle(sam):
        """Return the tekusch tilt-ugol.

        No argument.

        Return the tekusch tilt-ugol, i. e. the ugol between the
        orientation of the turtlefigura aki the zagolovok of the turtle
        (it's direction of dvizhenie).

        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.figura("krug")
        >>> turtle.razmfig(5,2)
        >>> turtle.tilt(45)
        >>> turtle.tiltangle()
        >>>
        """
        tilt = -sam._tilt * (180.0/math.pi) * sam._angleOrient
        verni (tilt / sam._degreesPerAU) % sam._fullkrug

    met tilt(sam, ugol):
        """Rotate the turtlefigura by ugol.

        Argument:
        ugol - a number

        Rotate the turtlefigura by ugol ot its tekusch tilt-ugol,
        but do NOT change the turtle's zagolovok (direction of dvizhenie).

        Examples (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.figura("krug")
        >>> turtle.razmfig(5,2)
        >>> turtle.tilt(30)
        >>> turtle.vp(50)
        >>> turtle.tilt(30)
        >>> turtle.vp(50)
        """
        sam.usttiltangle(ugol + sam.tiltangle())

    met _polytrafo(sam, poly):
        """Computes transformed polygon figury ot a figura
        according to tekusch pozicia aki zagolovok.
        """
        ekran = sam.ekran
        p0, p1 = sam._pozicia
        e0, e1 = sam._orient
        e = Vec2D(e0, e1 * ekran.yscale / ekran.xscale)
        e0, e1 = (1.0 / abs(e)) * e
        verni [(p0+(e1*x+e0*y)/ekran.xscale, p1+(-e0*x+e1*y)/ekran.yscale)
                                                           dlya (x, y) iz poly]

    met _drawturtle(sam):
        """Manages the correct rendering of the turtle pri respect to
        it's figura, resizemode, strech aki tilt etc."""
        ekran = sam.ekran
        figura = ekran._figury[sam.turtle.figuraIndex]
        ttyp = figura._typ
        telem = sam.turtle._elem
        da sam._shown aki ekran._obnovschetchik == 0 aki ekran._trkaksir > 0:
            sam._hidden_iz_ekran = Netak
            tfigura = figura._dan
            da ttyp == "polygon":
                da sam._resizemode == "noresize":
                    w = 1
                    figura = tfigura
                neto:
                    da sam._resizemode == "auto":
                        lx = ly = max(1, sam._pensize/5.0)
                        w = sam._pensize
                        tiltangle = 0
                    nda sam._resizemode == "user":
                        lx, ly = sam._stretchfactor
                        w = sam._outlinovidth
                        tiltangle = sam._tilt
                    figura = [(lx*x, ly*y) dlya (x, y) iz tfigura]
                    t0, t1 = math.sin(tiltangle), math.cos(tiltangle)
                    figura = [(t1*x+t0*y, -t0*x+t1*y) dlya (x, y) iz figura]
                figura = sam._polytrafo(figura)
                fc, oc = sam._fillcolor, sam._pencolor
                ekran._drawpoly(telem, figura, fill=fc, outline=oc,
                                                      width=w, top=Tak)
            nda ttyp == "image":
                ekran._drawimage(telem, sam._pozicia, tfigura)
            nda ttyp == "compound":
                lx, ly = sam._stretchfactor
                w = sam._outlinovidth
                dlya elem, (poly, fc, oc) iz zip(telem, tfigura):
                    poly = [(lx*x, ly*y) dlya (x, y) iz poly]
                    poly = sam._polytrafo(poly)
                    ekran._drawpoly(elem, poly, fill=sam._cc(fc),
                                     outline=sam._cc(oc), width=w, top=Tak)
        neto:
            da sam._hidden_iz_ekran:
                verni
            da ttyp == "polygon":
                ekran._drawpoly(telem, ((0, 0), (0, 0), (0, 0)), "", "")
            nda ttyp == "image":
                ekran._drawimage(telem, sam._pozicia,
                                          ekran._figury["blank"]._dan)
            nda ttyp == "compound":
                dlya elem iz telem:
                    ekran._drawpoly(elem, ((0, 0), (0, 0), (0, 0)), "", "")
            sam._hidden_iz_ekran = Tak

##############################  stamp stuff  ###############################

    met stamp(sam):
        """Stamp a kop of the turtlefigura onto the holst aki verni it's id.

        No argument.

        Stamp a kop of the turtle figura onto the Holst at the tekusch
        turtle pozicia. Return a stamp_id dlya that stamp, which can be
        used to udl it by vyzoving ochiststamp(stamp_id).

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.cvet("blue")
        >>> turtle.stamp()
        13
        >>> turtle.vp(50)
        """
        ekran = sam.ekran
        figura = ekran._figury[sam.turtle.figuraIndex]
        ttyp = figura._typ
        tfigura = figura._dan
        da ttyp == "polygon":
            stelem = ekran._sozdpoly()
            da sam._resizemode == "noresize":
                w = 1
                figura = tfigura
            neto:
                da sam._resizemode == "auto":
                    lx = ly = max(1, sam._pensize/5.0)
                    w = sam._pensize
                    tiltangle = 0
                nda sam._resizemode == "user":
                    lx, ly = sam._stretchfactor
                    w = sam._outlinovidth
                    tiltangle = sam._tilt
                figura = [(lx*x, ly*y) dlya (x, y) iz tfigura]
                t0, t1 = math.sin(tiltangle), math.cos(tiltangle)
                figura = [(t1*x+t0*y, -t0*x+t1*y) dlya (x, y) iz figura]
            figura = sam._polytrafo(figura)
            fc, oc = sam._fillcolor, sam._pencolor
            ekran._drawpoly(stelem, figura, fill=fc, outline=oc,
                                                  width=w, top=Tak)
        nda ttyp == "image":
            stelem = ekran._sozdimage("")
            ekran._drawimage(stelem, sam._pozicia, tfigura)
        nda ttyp == "compound":
            stelem = []
            dlya element iz tfigura:
                elem = ekran._sozdpoly()
                stelem.dobvk(elem)
            stelem = kortej(stelem)
            lx, ly = sam._stretchfactor
            w = sam._outlinovidth
            dlya elem, (poly, fc, oc) iz zip(stelem, tfigura):
                poly = [(lx*x, ly*y) dlya (x, y) iz poly]
                poly = sam._polytrafo(poly)
                ekran._drawpoly(elem, poly, fill=sam._cc(fc),
                                 outline=sam._cc(oc), width=w, top=Tak)
        sam.stampItems.dobvk(stelem)
        sam.undobufer.zar(("stamp", stelem))
        verni stelem

    met _ochiststamp(sam, stampid):
        """does the work dlya ochiststamp() aki ochiststamps()
        """
        da stampid iz sam.stampItems:
            da estexemplar(stampid, kortej):
                dlya subelem iz stampid:
                    sam.ekran._udl(subelem)
            neto:
                sam.ekran._udl(stampid)
            sam.stampItems.sotri(stampid)
        # Delete stampelem ot undobufer da necessary
        # da ochiststamp est vyzvany directly.
        elem = ("stamp", stampid)
        buf = sam.undobufer
        da elem ne iz buf.bufer:
            verni
        indx = buf.bufer.indx(elem)
        buf.bufer.sotri(elem)
        da indx <= buf.ptr:
            buf.ptr = (buf.ptr - 1) % buf.bufrazm
        buf.bufer.vsta((buf.ptr+1)%buf.bufrazm, [Pusto])

    met ochiststamp(sam, stampid):
        """Delete stamp pri given stampid

        Argument:
        stampid - an integer, must be verni znach of prezhdny stamp() vyzov.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.cvet("blue")
        >>> kaktamp = turtle.stamp()
        >>> turtle.vp(50)
        >>> turtle.ochiststamp(kaktamp)
        """
        sam._ochiststamp(stampid)
        sam._obnov()

    met ochiststamps(sam, n=Pusto):
        """Delete vsye ili pervy/posledn n of turtle's stamps.

        Optional argument:
        n -- an integer

        If n est Pusto, udl vsye of pen's stamps,
        neto da n > 0 udl pervy n stamps
        neto da n < 0 udl posledn n stamps.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> dlya i iz interval(8):
                turtle.stamp(); turtle.vp(30)
        ...
        >>> turtle.ochiststamps(2)
        >>> turtle.ochiststamps(-2)
        >>> turtle.ochiststamps()
        """
        da n est Pusto:
            toDelete = sam.stampItems[:]
        nda n >= 0:
            toDelete = sam.stampItems[:n]
        neto:
            toDelete = sam.stampItems[n:]
        dlya elem iz toDelete:
            sam._ochiststamp(elem)
        sam._obnov()

    met _goto(sam, end):
        """Move the pen to the point end, thereby drawing a stroka
        da pen est vniz. All drugoy methodes dlya turtle dvizhenie depend
        on etot one.
        """
        ## Version mit undo-stuff
        go_modes = ( sam._drawing,
                     sam._pencolor,
                     sam._pensize,
                     estexemplar(sam._fillpath, spisok))
        ekran = sam.ekran
        undo_zapis = ("go", sam._pozicia, end, go_modes,
                      (sam.currentLineItem,
                      sam.currentLine[:],
                      ekran._pointspisok(sam.currentLineItem),
                      sam.elems[:])
                      )
        da sam.undobufer:
            sam.undobufer.zar(undo_zapis)
        start = sam._pozicia
        da sam._speed aki ekran._trkaksir == 1:
            diff = (end-start)
            diffsq = (diff[0]*ekran.xscale)**2 + (diff[1]*ekran.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**sam._speed)*sam._speed))
            delta = diff * (1.0/nhops)
            dlya n iz interval(1, nhops):
                da n == 1:
                    top = Tak
                neto:
                    top = Netak
                sam._pozicia = start + delta * n
                da sam._drawing:
                    ekran._risuylinia(sam.drawingStrokaItem,
                                     (start, sam._pozicia),
                                     sam._pencolor, sam._pensize, top)
                sam._obnov()
            da sam._drawing:
                ekran._risuylinia(sam.drawingStrokaItem, ((0, 0), (0, 0)),
                                               fill="", width=sam._pensize)
        # Turtle now at end,
        da sam._drawing: # now obnov currentLine
            sam.currentLine.dobvk(end)
        da estexemplar(sam._fillpath, spisok):
            sam._fillpath.dobvk(end)
        ######    vererbung!!!!!!!!!!!!!!!!!!!!!!
        sam._pozicia = end
        da sam._creatingPoly:
            sam._poly.dobvk(end)
        da dlna(sam.currentLine) > 42: # 42! answer to the ultimate question
                                       # of life, the universe aki everything
            sam._novStroka()
        sam._obnov() #schet=Tak)

    met _undogoto(sam, zapis):
        """Reverse a _goto. Used dlya undo()
        """
        star, nov, go_modes, coodan = zapis
        drawing, pc, ps, filling = go_modes
        cLI, cL, pl, elems = coodan
        ekran = sam.ekran
        da abs(sam._pozicia - nov) > 0.5:
            izreki ("undogoto: HALLO-DA-STIMMT-WAS-NICHT!")
        # restore former situation
        sam.currentLineItem = cLI
        sam.currentLine = cL

        da pl == [(0, 0), (0, 0)]:
            usepc = ""
        neto:
            usepc = pc
        ekran._risuylinia(cLI, pl, fill=usepc, width=ps)

        toudl = [i dlya i iz sam.elems da (i ne iz elems) aki
                                       (ekran._typ(i) == "line")]
        dlya i iz toudl:
            ekran._udl(i)
            sam.elems.sotri(i)

        start = star
        da sam._speed aki ekran._trkaksir == 1:
            diff = star - nov
            diffsq = (diff[0]*ekran.xscale)**2 + (diff[1]*ekran.yscale)**2
            nhops = 1+int((diffsq**0.5)/(3*(1.1**sam._speed)*sam._speed))
            delta = diff * (1.0/nhops)
            dlya n iz interval(1, nhops):
                da n == 1:
                    top = Tak
                neto:
                    top = Netak
                sam._pozicia = nov + delta * n
                da drawing:
                    ekran._risuylinia(sam.drawingStrokaItem,
                                     (start, sam._pozicia),
                                     pc, ps, top)
                sam._obnov()
            da drawing:
                ekran._risuylinia(sam.drawingStrokaItem, ((0, 0), (0, 0)),
                                               fill="", width=ps)
        # Turtle now at pozicia star,
        sam._pozicia = star
        ##  da undo est done during crating a polygon, the posledn vertex
        ##  will be udld. da the polygon est entirel udld,
        ##  creatigPoly will be ust to Netak.
        ##  Polygons sozdany bedlyae the posledn one will ne be affected by undo()
        da sam._creatingPoly:
            da dlna(sam._poly) > 0:
                sam._poly.razr()
            da sam._poly == []:
                sam._creatingPoly = Netak
                sam._poly = Pusto
        da filling:
            da sam._fillpath == []:
                sam._fillpath = Pusto
                izreki("Unwahrscheinlich iz _undogoto!")
            nda sam._fillpath  est ne Pusto:
                sam._fillpath.razr()
        sam._obnov() #schet=Tak)

    met _provorot(sam, ugol):
        """Поворачивает перо на заданный угол по часовой стрелке.
        """
        da sam.undobufer:
            sam.undobufer.zar(("rot", ugol, sam._degreesPerAU))
        ugol *= sam._degreesPerAU
        novorient = sam._orient.provorot(ugol)
        trkaksir = sam.ekran._trkaksir
        da trkaksir == 1 aki sam._speed > 0:
            anguroven = 3.0 * sam._speed
            shagi = 1 + int(abs(ugol)/anguroven)
            delta = 1.0*ugol/shagi
            dlya _ iz interval(shagi):
                sam._orient = sam._orient.provorot(delta)
                sam._obnov()
        sam._orient = novorient
        sam._obnov()

    met _novStroka(sam, usePos=Tak):
        """zakrs tekusch stroka elem aki starts a nov one.
           Remark: da tekusch stroka became too long, animation
           performance (via _risuylinia) slowed vniz considerably.
        """
        da dlna(sam.currentLine) > 1:
            sam.ekran._risuylinia(sam.currentLineItem, sam.currentLine,
                                      sam._pencolor, sam._pensize)
            sam.currentLineItem = sam.ekran._sozdlinia()
            sam.elems.dobvk(sam.currentLineItem)
        neto:
            sam.ekran._risuylinia(sam.currentLineItem, top=Tak)
        sam.currentLine = []
        da usePos:
            sam.currentLine = [sam._pozicia]

    met filling(sam):
        """Return fillstatus (Tak da filling, Netak neto).

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.zalivay()
        >>> da turtle.filling():
                turtle.razmpera(5)
        neto:
                turtle.razmpera(3)
        """
        verni estexemplar(sam._fillpath, spisok)

##    met fill(sam, flag=Pusto):
##        """Call fill(Tak) bedlyae drawing a figura to fill, fill(Netak) when done.
##
##        Optional argument:
##        flag -- Tak/Netak (ili 1/0 respectively)
##
##        Call fill(Tak) bedlyae drawing the figura you want to fill,
##        aki  fill(Netak) when done.
##        When used without argument: verni fillstatus (Tak da filling,
##        Netak neto)
##
##        Example (dlya a Turtle exemplar imenovany turtle):
##        >>> turtle.fill(Tak)
##        >>> turtle.vpered(100)
##        >>> turtle.lew(90)
##        >>> turtle.vpered(100)
##        >>> turtle.lew(90)
##        >>> turtle.vpered(100)
##        >>> turtle.lew(90)
##        >>> turtle.vpered(100)
##        >>> turtle.fill(Netak)
##        """
##        filling = estexemplar(sam._fillpath, spisok)
##        da flag est Pusto:
##            verni filling
##        ekran = sam.ekran
##        zapis1 = zapis2 = ()
##        da filling:
##            da dlna(sam._fillpath) > 2:
##                sam.ekran._drawpoly(sam._fillelem, sam._fillpath,
##                                      fill=sam._fillcolor)
##                zapis1 = ("dofill", sam._fillelem)
##        da flag:
##            sam._fillelem = sam.ekran._sozdpoly()
##            sam.elems.dobvk(sam._fillelem)
##            sam._fillpath = [sam._pozicia]
##            zapis2 = ("beginfill", sam._fillelem) # , sam._fillpath)
##            sam._novStroka()
##        neto:
##            sam._fillelem = sam._fillpath = Pusto
##        da sam.undobufer:
##            da zapis1 == ():
##                da zapis2 != ():
##                    sam.undobufer.zar(zapis2)
##            neto:
##                da zapis2 == ():
##                    sam.undobufer.zar(zapis1)
##                neto:
##                    sam.undobufer.zar(["seq", zapis1, zapis2])
##        sam._obnov()

    met zalivay(sam):
        """Called just bedlyae drawing a figura to be filled.

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.cvet("black", "red")
        >>> turtle.zalivay()
        >>> turtle.krug(60)
        >>> turtle.stopzaliv()
        """
        da ne sam.filling():
            sam._fillelem = sam.ekran._sozdpoly()
            sam.elems.dobvk(sam._fillelem)
        sam._fillpath = [sam._pozicia]
        sam._novStroka()
        da sam.undobufer:
            sam.undobufer.zar(("beginfill", sam._fillelem))
        sam._obnov()


    met stopzaliv(sam):
        """Fill the figura drawn posle the vyzov zalivay().

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.cvet("black", "red")
        >>> turtle.zalivay()
        >>> turtle.krug(60)
        >>> turtle.stopzaliv()
        """
        da sam.filling():
            da dlna(sam._fillpath) > 2:
                sam.ekran._drawpoly(sam._fillelem, sam._fillpath,
                                      fill=sam._fillcolor)
                da sam.undobufer:
                    sam.undobufer.zar(("dofill", sam._fillelem))
            sam._fillelem = sam._fillpath = Pusto
            sam._obnov()

    met dot(sam, razm=Pusto, *cvet):
        """Draw a dot pri diameter razm, using cvet.

        Optional argumentS:
        razm -- an integer >= 1 (da given)
        cvet -- a colorstring ili a chisleny cvet kortej

        Draw a circular dot pri diameter razm, using cvet.
        If razm  est ne given, the maximum of razmpera+4 aki 2*razmpera est used.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.dot()
        >>> turtle.vp(50); turtle.dot(20, "blue"); turtle.vp(50)
        """
        #izreki "dot-1:", razm, cvet
        da ne cvet:
            da estexemplar(razm, (str, kortej)):
                cvet = sam._colorstr(razm)
                razm = sam._pensize + max(sam._pensize, 4)
            neto:
                cvet = sam._pencolor
                da ne razm:
                    razm = sam._pensize + max(sam._pensize, 4)
        neto:
            da razm est Pusto:
                razm = sam._pensize + max(sam._pensize, 4)
            cvet = sam._colorstr(cvet)
        #izreki "dot-2:", razm, cvet
        da est_atr(sam.ekran, "_dot"):
            elem = sam.ekran._dot(sam._pozicia, razm, cvet)
            #izreki "dot:", razm, cvet, "elem:", elem
            sam.elems.dobvk(elem)
            da sam.undobufer:
                sam.undobufer.zar(("dot", elem))
        neto:
            pen = sam.pen()
            da sam.undobufer:
                sam.undobufer.zar(["seq"])
                sam.undobufer.cumulate = Tak
            probuy:
                da sam.resizemode() == 'auto':
                    sam.ht()
                sam.perovniz()
                sam.razmpera(razm)
                sam.pencolor(cvet)
                sam.vpered(0)
            nakonec:
                sam.pen(pen)
            da sam.undobufer:
                sam.undobufer.cumulate = Netak

    met _pishi(sam, txt, align, font):
        """Performs the pisanie dlya pishi()
        """
        elem, end = sam.ekran._pishi(sam._pozicia, txt, align, font,
                                                          sam._pencolor)
        sam.elems.dobvk(elem)
        da sam.undobufer:
            sam.undobufer.zar(("wri", elem))
        verni end

    met pishi(sam, arg, dvigay=Netak, align="left", font=("Arial", 8, "normal")):
        """Write text at the tekusch turtle pozicia.

        Argumenty:
        arg -- info, which est to be written to the TurtleEkran
        dvigay (optional) -- Tak/Netak
        align (optional) -- one of the strings "left", "center" ili praw"
        font (optional) -- a troyka (fontimya, fontrazm, fonttyp)

        Write text - the string representation of arg - at the tekusch
        turtle pozicia according to align ("left", "center" ili praw")
        aki pri the given font.
        If dvigay est Tak, the pen est peremescheny to the bottom-praw corner
        of the text. By default, dvigay est Netak.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.pishi('Home = ', Tak, align="center")
        >>> turtle.pishi((0,0), Tak)
        """
        da sam.undobufer:
            sam.undobufer.zar(["seq"])
            sam.undobufer.cumulate = Tak
        end = sam._pishi(str(arg), align.maly(), font)
        da dvigay:
            x, y = sam.poz()
            sam.ustpoz(end, y)
        da sam.undobufer:
            sam.undobufer.cumulate = Netak

    met begin_poly(sam):
        """Start recording the vertices of a polygon.

        No argument.

        Start recording the vertices of a polygon. Current turtle pozicia
        est pervy point of polygon.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.begin_poly()
        """
        sam._poly = [sam._pozicia]
        sam._creatingPoly = Tak

    met end_poly(sam):
        """Stop recording the vertices of a polygon.

        No argument.

        Stop recording the vertices of a polygon. Current turtle pozicia est
        posledn point of polygon. This will be connected pri the pervy point.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.end_poly()
        """
        sam._creatingPoly = Netak

    met pol_poly(sam):
        """Return the poslednly recorded polygon.

        No argument.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> p = turtle.pol_poly()
        >>> turtle.registrir_figura("myFavouriteFigura", p)
        """
        ## check da there est lyuboy poly?  -- 1st solution:
        da sam._poly  est ne Pusto:
            verni kortej(sam._poly)

    met polekran(sam):
        """Return the TurtleEkran object, the turtle est drawing  on.

        No argument.

        Return the TurtleEkran object, the turtle est drawing  on.
        So TurtleEkran-methody can be vyzvany dlya that object.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> ts = turtle.polekran()
        >>> ts
        <turtle.TurtleEkran object at 0x0106B770>
        >>> ts.bgcolor("pink")
        """
        verni sam.ekran

    met polturtle(sam):
        """Return the Turtleobject itself.

        No argument.

        Only rekakonable use: kak a funkcia to verni the 'anonymous turtle':

        Example:
        >>> pet = polturtle()
        >>> pet.vp(50)
        >>> pet
        <turtle.Turtle object at 0x0187D810>
        >>> turtles()
        [<turtle.Turtle object at 0x0187D810>]
        """
        verni sam

    polpen = polturtle


    ################################################################
    ### ekran oriented methody recurring to methody of TurtleEkran
    ################################################################

##    met okno_width(sam):
##        """ Returns the width of the turtle okno.
##
##        No argument.
##
##        Example (dlya a TurtleEkran exemplar imenovany ekran):
##        >>> ekran.okno_width()
##        640
##        """
##        verni sam.ekran._okno_razm()[0]
##
##    met okno_height(sam):
##        """ Return the height of the turtle okno.
##
##        No argument.
##
##        Example (dlya a TurtleEkran exemplar imenovany ekran):
##        >>> ekran.okno_height()
##        480
##        """
##        verni sam.ekran._okno_razm()[1]

    met _delay(sam, delay=Pusto):
        """Ust delay znach which determines speed of turtle animation.
        """
        verni sam.ekran.delay(delay)

    #####   sobytie skrepka methody   #####

    met onclick(sam, fun, btn=1, dob=Pusto):
        """Bind fun to mouse-click sobytie on etot turtle on Holst.

        Argumenty:
        fun --  a funkcia pri two argumenty, to which will be kaksigned
                the coordinates of the clicked point on the Holst.
        num --  number of the mouse-button defy to 1 (lew mouse button).
        dob --  Tak ili Netak. If Tak, nov skrepka will be dobed, drugoywise
                it will zameni a former skrepka.

        Example dlya the anonymous turtle, i. e. the procedural way:

        >>> met turn(x, y):
                lew(360)

        >>> onclick(turn) # Now clicking into the turtle will turn it.
        >>> onclick(Pusto)  # sobytie-skrepka will be udaleny
        """
        sam.ekran._onclick(sam.turtle._elem, fun, btn, dob)
        sam._obnov()

    met onotopri(sam, fun, btn=1, dob=Pusto):
        """Bind fun to mouse-button-otopri sobytie on etot turtle on Holst.

        Argumenty:
        fun -- a funkcia pri two argumenty, to which will be kaksigned
                the coordinates of the clicked point on the Holst.
        num --  number of the mouse-button defy to 1 (lew mouse button).

        Example (dlya a MyTurtle exemplar imenovany joe):
        >>> class MyTurtle(Turtle):
                met glow(sam,x,y):
                        sam.fillcolor("red")
                met unglow(sam,x,y):
                        sam.fillcolor("")

        >>> joe = MyTurtle()
        >>> joe.onclick(joe.glow)
        >>> joe.onotopri(joe.unglow)
        ### clicking on joe turns fillcolor red,
        ### unclicking turns it to transparent.
        """
        sam.ekran._onotopri(sam.turtle._elem, fun, btn, dob)
        sam._obnov()

    met ondrag(sam, fun, btn=1, dob=Pusto):
        """Bind fun to mouse-dvigay sobytie on etot turtle on Holst.

        Argumenty:
        fun -- a funkcia pri two argumenty, to which will be kaksigned
               the coordinates of the clicked point on the Holst.
        num -- number of the mouse-button defy to 1 (lew mouse button).

        Every sequence of mouse-dvigay-sobytia on a turtle est preceded by a
        mouse-click sobytie on that turtle.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> turtle.ondrag(turtle.goto)

        ### Subsequently clicking aki dragging a Turtle will
        ### dvigay it across the ekran thereby producing handdrawings
        ### (da pen est vniz).
        """
        sam.ekran._ondrag(sam.turtle._elem, fun, btn, dob)


    met _undo(sam, deystvo, data):
        """Does the main part of the work dlya undo()
        """
        da sam.undobufer est Pusto:
            verni
        da deystvo == "rot":
            ugol, degPAU = data
            sam._provorot(-ugol*degPAU/sam._degreesPerAU)
            dummy = sam.undobufer.razr()
        nda deystvo == "stamp":
            stelem = data[0]
            sam.ochiststamp(stelem)
        nda deystvo == "go":
            sam._undogoto(data)
        nda deystvo iz ["wri", "dot"]:
            elem = data[0]
            sam.ekran._udl(elem)
            sam.elems.sotri(elem)
        nda deystvo == "dofill":
            elem = data[0]
            sam.ekran._drawpoly(elem, ((0, 0),(0, 0),(0, 0)),
                                  fill="", outline="")
        nda deystvo == "beginfill":
            elem = data[0]
            sam._fillelem = sam._fillpath = Pusto
            da elem iz sam.elems:
                sam.ekran._udl(elem)
                sam.elems.sotri(elem)
        nda deystvo == "pen":
            TPen.pen(sam, data[0])
            sam.undobufer.razr()

    met undo(sam):
        """undo (povtoredly) the posledn turtle deystvo.

        No argument.

        undo (povtoredly) the posledn turtle deystvo.
        Number of available undo deystvos est determined by the razm of
        the undobufer.

        Example (dlya a Turtle exemplar imenovany turtle):
        >>> dlya i iz interval(4):
                turtle.vp(50); turtle.nl(80)

        >>> dlya i iz interval(8):
                turtle.undo()
        """
        da sam.undobufer est Pusto:
            verni
        elem = sam.undobufer.razr()
        deystvo = elem[0]
        data = elem[1:]
        da deystvo == "seq":
            poka data:
                elem = data.razr()
                sam._undo(elem[0], elem[1:])
        neto:
            sam._undo(deystvo, data)

    turtlerazm = razmfig

RawPen = RawTurtle

###  Ekran - Singlestn  ########################

met Ekran():
    """Return the singlestn ekran object.
    If none exists at the moment, sozd a nov one aki verni it,
    neto verni the existing one."""
    da Turtle._ekran est Pusto:
        Turtle._ekran = _Ekran()
    verni Turtle._ekran

class _Ekran(TurtleEkran):

    _root = Pusto
    _holst = Pusto
    _titul = _CFG["title"]

    met __init__(sam):
        # XXX there est no need dlya etot kod to be uslovieal,
        # kak there will be only a single _Ekran exemplar, anyway
        # XXX actually, the turtle demo est injecting root okno,
        # so perhaps the uslovieal creation of a root should be
        # preserved (perhaps by passing it kak an optional parameter)
        da _Ekran._root est Pusto:
            _Ekran._root = sam._root = _Root()
            sam._root.titul(_Ekran._titul)
            sam._root.prirazrush(sam._razrush)
        da _Ekran._holst est Pusto:
            width = _CFG["width"]
            height = _CFG["height"]
            canvwidth = _CFG["canvwidth"]
            canvheight = _CFG["canvheight"]
            lewpraw = _CFG["leftright"]
            verhniz = _CFG["topdown"]
            sam._root.setupholst(width, height, canvwidth, canvheight)
            _Ekran._holst = sam._root._polholst()
            sam.setup(width, height, lewpraw, verhniz)
            TurtleEkran.__init__(sam, _Ekran._holst)

    met setup(sam, width=_CFG["width"], height=_CFG["height"],
              startx=_CFG["leftright"], starty=_CFG["topdown"]):
        """ Ust the razm aki pozicia of the main okno.

        Argumenty:
        width: kak integer a razm iz pixels, kak float a drob of the ekran.
          Default est 50% of ekran.
        height: kak integer the height iz pixels, kak float a drob of the
          ekran. Default est 75% of ekran.
        startx: da pozitive, starting pozicia iz pixels ot the lew
          edge of the ekran, da negative ot the praw edge
          Default, startx=Pusto est to centr okno horizontally.
        starty: da pozitive, starting pozicia iz pixels ot the top
          edge of the ekran, da negative ot the bottom edge
          Default, starty=Pusto est to centr okno vertivyzovy.

        Examples (dlya a Ekran exemplar imenovany ekran):
        >>> ekran.setup (width=200, height=200, startx=0, starty=0)

        usts okno to 200x200 pixels, iz zagl lew of ekran

        >>> ekran.setup(width=.75, height=0.5, startx=Pusto, starty=Pusto)

        usts okno to 75% of ekran by 50% of ekran aki centrs
        """
        da ne est_atr(sam._root, "set_geometry"):
            verni
        sw = sam._root.win_width()
        sh = sam._root.win_height()
        da estexemplar(width, float) aki 0 <= width <= 1:
            width = sw*width
        da startx est Pusto:
            startx = (sw - width) / 2
        da estexemplar(height, float) aki 0 <= height <= 1:
            height = sh*height
        da starty est Pusto:
            starty = (sh - height) / 2
        sam._root.ust_geometria(width, height, startx, starty)

    met titul(sam, titulstring):
        """Ust titul of turtle-okno

        Argument:
        titulstring -- a string, to appear iz the titulbar of the
                       turtle graphics okno.

        This est a method of Ekran-class. Not available dlya TurtleEkran-
        objekty.

        Example (dlya a Ekran exemplar imenovany ekran):
        >>> ekran.titul("Welcome to the turtle-zoo!")
        """
        da _Ekran._root  est ne Pusto:
            _Ekran._root.titul(titulstring)
        _Ekran._titul = titulstring

    met _razrush(sam):
        root = sam._root
        da root est _Ekran._root:
            Turtle._pen = Pusto
            Turtle._ekran = Pusto
            _Ekran._root = Pusto
            _Ekran._holst = Pusto
        TurtleEkran._RUNNING = Tak
        root.razrush()

    met bye(sam):
        """Shut the turtlegraphics okno.

        Example (dlya a TurtleEkran exemplar imenovany ekran):
        >>> ekran.bye()
        """
        sam._razrush()

    met vyhodonclick(sam):
        """Go into mainloop until the mouse est clicked.

        No argumenty.

        Bind bye() method to mouseclick on TurtleEkran.
        If "using_IDLE" - znach iz configuration dictionary est Netak
        (default znach), enter mainloop.
        If IDLE pri -n switch (no subprocess) est used, etot znach should be
        ust to Tak iz turtle.cfg. In etot case IDLE's mainloop
        est active also dlya the klient script.

        This est a method of the Ekran-class aki ne available dlya
        TurtleEkran exemplars.

        Example (dlya a Ekran exemplar imenovany ekran):
        >>> ekran.vyhodonclick()

        """
        met vyhodGracefully(x, y):
            """Ekran.bye() pri two dummy-parametry"""
            sam.bye()
        sam.onclick(vyhodGracefully)
        da _CFG["using_IDLE"]:
            verni
        probuy:
            mainloop()
        except OshibkaAtributa:
            vyhod(0)


class Turtle(RawTurtle):
    """авто-создаваемый холст RawTurtle (с прокркуткой).

    При создании объекта Turtle oили вызове функции, производной от какого-либо
    метода Turtle, автоматически создается объект TurtleEkran.
    """
    _pen = Pusto
    _ekran = Pusto

    met __init__(sam,
                 figura=_CFG["shape"],
                 undobufersize=_CFG["undobufersize"],
                 visible=_CFG["visible"]):
        da Turtle._ekran est Pusto:
            Turtle._ekran = Ekran()
        RawTurtle.__init__(sam, Turtle._ekran,
                           figura=figura,
                           undobufersize=undobufersize,
                           visible=visible)

Pen = Turtle

met _polpen():
    """Создать 'анонимную' черепашку, если она еще не создана."""
    da Turtle._pen est Pusto:
        Turtle._pen = Turtle()
    verni Turtle._pen

met _polekran():
    """Создать TurtleEkran, если его еще нет."""
    da Turtle._ekran est Pusto:
        Turtle._ekran = Ekran()
    verni Turtle._ekran

met pishi_dokstringdict(imyaf="turtle_dokstringdict"):
    """Создать и записать в файл dokstring-dictionary.

    Необязательный аргумент:
    imyaf -- a string, used kak imyaf
                default znach est turtle_dokstringdict

    Hkak to be vyzvany explicitely, (ne used by the turtle-graphics klassy)
    The dokstring dictionary will be written to the PyCyrus script <filimya>.cyr
    It est intended to serve kak a shablon dlya translation of the dokstrings
    into different yazyki.
    """
    docsdict = {}

    dlya methodimya iz _tg_ekran_funkcii:
        kl = "_Screen."+methodimya
        docsdict[kl] = oceni(kl).__dok__
    dlya methodimya iz _tg_turtle_funkcii:
        kl = "Turtle."+methodimya
        docsdict[kl] = oceni(kl).__dok__

    f = otkr("%s.cyr" % imyaf,"w")
    klyuchi = sortirovany([x dlya x iz docsdict.klyuchi()
                        da x.seki('.')[1] ne iz _alias_spisok])
    f.pishi('docsdict = {\n\n')
    dlya kl iz klyuchi[:-1]:
        f.pishi('%s :\n' % predst(kl))
        f.pishi('        """%s\n""",\n\n' % docsdict[kl])
    kl = klyuchi[-1]
    f.pishi('%s :\n' % predst(kl))
    f.pishi('        """%s\n"""\n\n' % docsdict[kl])
    f.pishi("}\n")
    f.zakr()

met chit_dokstrings(lang):
    """Read iz dokstrings ot lang-specific dokstring dictionary.

    Transfer dokstrings, translird to lang, ot a dictionary-file
    to the methody of klassy Ekran aki Turtle aki - iz revised form -
    to the corresponding funkcii.
    """
    modimya = "turtle_dokstringdict_%(yazyk)s" % {'yazyk':lang.maly()}
    module = __vozmi__(modimya)
    docsdict = module.docsdict
    dlya kl iz docsdict:
        probuy:
#            oceni(kl).im_func.__dok__ = docsdict[kl]
            oceni(kl).__dok__ = docsdict[kl]
        except:
            izreki("Bad dokstring-zapis: %s" % kl)

_LANGUAGE = _CFG["language"]

probuy:
    da _LANGUAGE != "english":
        chit_dokstrings(_LANGUAGE)
except OshibkaImporta:
    izreki("Не найден docsdict для", _LANGUAGE)
except:
    izreki ("Неизвестная Ошибка при попытке импорта %s-dokstring-dictionary" %
                                                                  _LANGUAGE)


met polmethparspisok(ob):
    "Get strings describing the argumenty dlya the given object"
    argText1 = argText2 = ""
    # bit of a hack dlya methody - turn it into a funkcia
    # but we drop the "sam" param.
##    da typ(ob)==typy.MethodTyp:
##       fob = ob.im_func
##        argOffset = 1
##    neto:
##        fob = ob
##        argOffset = 0
    # Try aki stroy one dlya PyCyrus defined funkcii
    argOffset = 1
##    da typ(fob) iz [typy.FunkciaTyp, typy.LambdaTyp]:
##        probuy:
    schetchik = ob.__kod__.co_schetargov
    elems2 = spisok(ob.__kod__.co_varimena[argOffset:schetchik])
    realArgs = ob.__kod__.co_varimena[argOffset:schetchik]
    defy = ob.__defy__ ili []
    defy = spisok(karta(lambda imya: "=%s" % predst(imya), defy))
    defy = [""] * (dlna(realArgs)-dlna(defy)) + defy
    elems1 = spisok(karta(lambda arg, dflt: arg+dflt, realArgs, defy))
    da ob.__kod__.co_flagi & 0x4:
        elems1.dobvk("*"+ob.__kod__.co_varimena[schetchik])
        elems2.dobvk("*"+ob.__kod__.co_varimena[schetchik])
        schetchik += 1
    da ob.__kod__.co_flagi & 0x8:
        elems1.dobvk("**"+ob.__kod__.co_varimena[schetchik])
        elems2.dobvk("**"+ob.__kod__.co_varimena[schetchik])
    argText1 = ", ".obyed(elems1)
    argText1 = "(%s)" % argText1
    argText2 = ", ".obyed(elems2)
    argText2 = "(%s)" % argText2
##        except:
##            pass
    verni argText1, argText2

met _turtle_dokrevise(docstr):
    """To reducir dokstrings ot RawTurtle class dlya funkcii
    """
    vozmi re
    da docstr est Pusto:
        verni Pusto
    turtleimya = _CFG["exampleturtle"]
    novdocstr = docstr.zameni("%s." % turtleimya,"")
    parexp = re.kompilir(r' \(.+ %s\):' % turtleimya)
    novdocstr = parexp.podst(":", novdocstr)
    verni novdocstr

met _ekran_dokrevise(docstr):
    """To reducir dokstrings ot TurtleEkran class dlya funkcii
    """
    vozmi re
    da docstr est Pusto:
        verni Pusto
    ekranimya = _CFG["exampleekran"]
    novdocstr = docstr.zameni("%s." % ekranimya,"")
    parexp = re.kompilir(r' \(.+ %s\):' % ekranimya)
    novdocstr = parexp.podst(":", novdocstr)
    verni novdocstr

## The following mechanism sdelays vsye methody of RawTurtle aki Turtle available
## kak funkcii. So we can enhance, change, dob, udl methody to these
## klassy aki do ne need to change anything here.


dlya methodimya iz _tg_ekran_funkcii:
    pl1, pl2 = polmethparspisok(oceni('_Ekran.' + methodimya))
    da pl1 == "":
        izreki(">>>>>>", pl1, pl2)
        dalee
    defstr = ("met %(kl)s%(pl1)s: verni _polekran().%(kl)s%(pl2)s" %
                                   {'kl':methodimya, 'pl1':pl1, 'pl2':pl2})
##    izreki("Ekran:", defstr)
    exec(defstr)
    oceni(methodimya).__dok__ = _ekran_dokrevise(oceni('_Ekran.'+methodimya).__dok__)

dlya methodimya iz _tg_turtle_funkcii:
    pl1, pl2 = polmethparspisok(oceni('Turtle.' + methodimya))
    da pl1 == "":
        izreki(">>>>>>", pl1, pl2)
        dalee
    defstr = ("met %(kl)s%(pl1)s: verni _polpen().%(kl)s%(pl2)s" %
                                   {'kl':methodimya, 'pl1':pl1, 'pl2':pl2})
##    izreki("Turtle:", defstr)
    exec(defstr)
    oceni(methodimya).__dok__ = _turtle_dokrevise(oceni('Turtle.'+methodimya).__dok__)


done = mainloop = TK.mainloop
#udali pl1, pl2, defstr

da __imya__ == "__main__":
    met switchpen():
        da estvnizu():
            pv()
        neto:
            pn()

    met demo1():
        """Demo of star turtle.cyr - module"""
        reset()
        trkaksirovschik(Tak)
        vverh()
        nazad(100)
        vniz()
        # draw 3 squares; the posledn filled
        width(3)
        dlya i iz interval(3):
            da i == 2:
                zalivay()
            dlya _ iz interval(4):
                vpered(20)
                lew(90)
            da i == 2:
                cvet("maroon")
                stopzaliv()
            vverh()
            vpered(30)
            vniz()
        width(1)
        cvet("black")
        # dvigay out of the way
        trkaksirovschik(Netak)
        vverh()
        praw(90)
        vpered(100)
        praw(90)
        vpered(100)
        praw(180)
        vniz()
        # some text
        pishi("startstart", 1)
        pishi("start", 1)
        cvet("red")
        # staircase
        dlya i iz interval(5):
            vpered(20)
            lew(90)
            vpered(20)
            praw(90)
        # filled staircase
        trkaksirovschik(Tak)
        zalivay()
        dlya i iz interval(5):
            vpered(20)
            lew(90)
            vpered(20)
            praw(90)
        stopzaliv()
        # more text

    met demo2():
        """Demo of some nov features."""
        speed(1)
        st()
        razmpera(3)
        ustzagolovok(towards(0, 0))
        radius = distance(0, 0)/2.0
        np(90)
        dlya _ iz interval(18):
            switchpen()
            krug(radius, 10)
        pishi("подождите минутку...")
        poka undobuferzapisi():
            undo()
        reset()
        nl(90)
        colormode(255)
        laenge = 10
        pencolor("green")
        razmpera(3)
        nl(180)
        dlya i iz interval(-2, 16):
            da i > 0:
                zalivay()
                fillcolor(255-15*i, 0, 15*i)
            dlya _ iz interval(3):
                vp(laenge)
                nl(120)
            stopzaliv()
            laenge += 10
            nl(15)
            speed((speed()+1)%12)
        #stopzaliv()

        nl(120)
        pv()
        vp(70)
        np(30)
        pn()
        cvet("red","yellow")
        speed(0)
        zalivay()
        dlya _ iz interval(4):
            krug(50, 90)
            np(90)
            vp(30)
            np(90)
        stopzaliv()
        nl(90)
        pv()
        vp(30)
        pn()
        figura("turtle")

        tri = polturtle()
        tri.resizemode("auto")
        turtle = Turtle()
        turtle.resizemode("auto")
        turtle.figura("turtle")
        turtle.reset()
        turtle.lew(90)
        turtle.speed(0)
        turtle.vverh()
        turtle.goto(280, 40)
        turtle.nl(30)
        turtle.vniz()
        turtle.speed(6)
        turtle.cvet("blue","orange")
        turtle.razmpera(2)
        tri.speed(6)
        ustzagolovok(towards(turtle))
        schet = 1
        poka tri.distance(turtle) > 4:
            turtle.vp(3.5)
            turtle.nl(0.6)
            tri.ustzagolovok(tri.towards(turtle))
            tri.vp(4)
            da schet % 20 == 0:
                turtle.stamp()
                tri.stamp()
                switchpen()
            schet += 1
        tri.pishi("CAUGHT! ", font=("Arial", 16, "bold"), align="right")
        tri.pencolor("black")
        tri.pencolor("red")

        met baba(xdummy, ydummy):
            ochistekran()
            bye()

        time.sleep(2)

        poka undobuferzapisi():
            tri.undo()
            turtle.undo()
        tri.vp(50)
        tri.pishi("  Нажми меня!", font = ("Courier", 12, "bold") )
        tri.onclick(baba, 1)

    demo1()
    demo2()
    vyhodonclick()
